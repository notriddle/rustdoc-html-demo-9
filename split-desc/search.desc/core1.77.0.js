RUSTDOC_SEARCH_DESC=RUSTDOC_SEARCH_DESC||new Map();RUSTDOC_SEARCH_DESC.set('core',"The Rust Core Library\nThe size of this integer type in bits.\nThe size of this integer type in bits.\nThe size of this integer type in bits.\nThe size of this integer type in bits.\nThe size of this integer type in bits.\nThe size of this integer type in bits.\nThe size of this integer type in bits.\nThe size of this integer type in bits.\nThe size of this integer type in bits.\nThe size of this integer type in bits.\nThe size of this integer type in bits.\nThe size of this integer type in bits.\nApproximate number of significant digits in base 10.\nApproximate number of significant digits in base 10.\nMachine epsilon value for <code>f32</code>.\nMachine epsilon value for <code>f64</code>.\nInfinity (∞).\nInfinity (∞).\nNumber of significant digits in base 2.\nNumber of significant digits in base 2.\nThe highest valid code point a <code>char</code> can have, <code>&#39;\\u{10FFFF}&#39;</code>.\nLargest finite <code>f32</code> value.\nLargest finite <code>f64</code> value.\nThe largest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nMaximum x for which 10x is normal.\nMaximum x for which 10x is normal.\nMaximum possible power of 2 exponent.\nMaximum possible power of 2 exponent.\nThe lowest valid code point a <code>char</code> can have, <code>&#39;\\0&#39;</code>.\nSmallest finite <code>f32</code> value.\nSmallest finite <code>f64</code> value.\nThe smallest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nMinimum x for which 10x is normal.\nMinimum x for which 10x is normal.\nOne greater than the minimum possible normal power of 2 …\nOne greater than the minimum possible normal power of 2 …\nSmallest positive normal <code>f32</code> value.\nSmallest positive normal <code>f64</code> value.\nNot a Number (NaN).\nNot a Number (NaN).\nNegative infinity (−∞).\nNegative infinity (−∞).\nThe radix or base of the internal representation of <code>f32</code>.\nThe radix or base of the internal representation of <code>f64</code>.\n<code>U+FFFD REPLACEMENT CHARACTER</code> (�) is used in Unicode to …\nThe version of Unicode that the Unicode parts of <code>char</code> and …\nComputes the absolute value of <code>self</code>.\nComputes the absolute value of <code>self</code>.\nComputes the absolute value of <code>self</code>.\nComputes the absolute value of <code>self</code>.\nComputes the absolute value of <code>self</code>.\nComputes the absolute value of <code>self</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nCalculates the offset from a pointer (convenience for …\nCalculates the offset from a pointer (convenience for …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGets the “address” portion of the pointer.\nGets the “address” portion of the pointer.\nComputes the offset that needs to be applied to the …\nComputes the offset that needs to be applied to the …\nTransmute the slice to a slice of another type, ensuring …\nTransmute the mutable slice to a mutable slice of another …\nMemory allocation APIs\nUtilities for dynamic typing or type reflection.\nSIMD and vendor intrinsics module.\nA fixed-size array, denoted <code>[T; N]</code>, for the element type, <code>T</code>…\nUtilities for the array primitive type.\nReturns an iterator over <code>N</code> elements of the slice at a …\nReturns an iterator over <code>N</code> elements of the slice at a …\nReturns an iterator over overlapping windows of <code>N</code> elements …\nReturns <code>Some</code> if the value is within the ASCII range, or …\nConverts this array of bytes into a array of ASCII …\nIf this slice <code>is_ascii</code>, returns it as a slice of ASCII …\nIf this string slice <code>is_ascii</code>, returns it as a slice of …\nIf the value of this byte is within the ASCII range, …\nConverts this array of bytes into a array of ASCII …\nConverts this slice of bytes into a slice of ASCII …\nViews this slice of ASCII characters as a slice of <code>u8</code> …\nConverts a string slice to a byte slice. To convert the …\nConverts a mutable string slice to a mutable byte slice.\nSplits the slice into a slice of <code>N</code>-element arrays, …\nSplits the slice into a slice of <code>N</code>-element arrays, …\nSplits the slice into a slice of <code>N</code>-element arrays, …\nSplits the slice into a slice of <code>N</code>-element arrays, …\nReturns <code>None</code> if the pointer is null, or else returns a …\n\n\n\nReturns a raw pointer to the slice’s buffer.\nReturns an unsafe mutable pointer to the slice’s buffer.\nConverts a mutable string slice to a raw pointer.\nReturns the two unsafe mutable pointers spanning the slice.\nReturns a mutable slice containing the entire array. …\nReturns a raw pointer to the slice’s buffer.\nReturns a raw pointer to the slice’s buffer.\nConverts a string slice to a raw pointer.\nReturns the two raw pointers spanning the slice.\nSplits the slice into a slice of <code>N</code>-element arrays, …\nSplits the slice into a slice of <code>N</code>-element arrays, …\nReturns <code>None</code> if the pointer is null, or else returns a …\nReturns <code>None</code> if the pointer is null, or else returns a …\n\n\n\n\nSplit a slice into a prefix, a middle of aligned SIMD …\nSplit a mutable slice into a mutable prefix, a middle of …\nReturns a slice containing the entire array. Equivalent to …\n\n\nViews this slice of ASCII characters as a UTF-8 <code>str</code>.\nReturns <code>None</code> if the pointer is null, or else returns a …\nReturns <code>None</code> if the pointer is null, or else returns a …\nReturns <code>None</code> if the pointer is null, or else returns a …\nReturns <code>None</code> if the pointer is null, or else returns a …\nReturns <code>None</code> if the pointer is null, or else returns a …\nReturns <code>None</code> if the pointer is null, or else returns a …\nOperations on ASCII strings and characters.\nAsserts that a boolean expression is <code>true</code> at runtime.\nAsserts that two expressions are equal to each other …\nUnstable module containing the unstable <code>assert_matches</code> …\nAsserts that two expressions are not equal to each other …\nComposable asynchronous iteration.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBinary searches this slice for a given element. If the …\nBinary searches this slice with a comparator function.\nBinary searches this slice with a key extraction function.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe boolean type.\nUtilities for working with borrowed data.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCalculates <code>self</code> − <code>rhs</code> − <code>borrow</code> and checks for overflow.\nCalculates <code>self</code> − <code>rhs</code> − <code>borrow</code> and checks for overflow.\nCalculates <code>self</code> − <code>rhs</code> − <code>borrow</code> and checks for overflow.\nCalculates <code>self</code> − <code>rhs</code> − <code>borrow</code> and checks for overflow.\nCalculates <code>self</code> − <code>rhs</code> − <code>borrow</code> and checks for overflow.\nCalculates <code>self</code> − <code>rhs</code> − <code>borrow</code> and returns a tuple …\nCalculates <code>self</code> − <code>rhs</code> − <code>borrow</code> and returns a tuple …\nCalculates <code>self</code> − <code>rhs</code> − <code>borrow</code> and returns a tuple …\nCalculates <code>self</code> − <code>rhs</code> − <code>borrow</code> and returns a tuple …\nCalculates <code>self</code> − <code>rhs</code> − <code>borrow</code> and returns a tuple …\nCalculates <code>self</code> − <code>rhs</code> − <code>borrow</code> and checks for overflow.\nCalculates <code>self</code> − <code>rhs</code> − <code>borrow</code> and returns a tuple …\nCalculates the offset from a pointer in bytes (convenience …\nCalculates the offset from a pointer in bytes (convenience …\nCalculates the offset from a pointer in bytes.\nCalculates the offset from a pointer in bytes.\nCalculates the distance between two pointers. The returned …\nCalculates the distance between two pointers. The returned …\nCalculates the offset from a pointer in bytes (convenience …\nCalculates the offset from a pointer in bytes (convenience …\nAn iterator over the bytes of a string slice.\nCalculates <code>self</code> + <code>rhs</code> + <code>carry</code> and checks for overflow.\nCalculates <code>self</code> + <code>rhs</code> + <code>carry</code> and checks for overflow.\nCalculates <code>self</code> + <code>rhs</code> + <code>carry</code> and checks for overflow.\nCalculates <code>self</code> + <code>rhs</code> + <code>carry</code> and checks for overflow.\nCalculates <code>self</code> + <code>rhs</code> + <code>carry</code> and checks for overflow.\nCalculates <code>self</code> + <code>rhs</code> + <code>carry</code> and returns a tuple …\nCalculates <code>self</code> + <code>rhs</code> + <code>carry</code> and returns a tuple …\nCalculates <code>self</code> + <code>rhs</code> + <code>carry</code> and returns a tuple …\nCalculates <code>self</code> + <code>rhs</code> + <code>carry</code> and returns a tuple …\nCalculates <code>self</code> + <code>rhs</code> + <code>carry</code> and returns a tuple …\nCalculates <code>self</code> + <code>rhs</code> + <code>carry</code> and checks for overflow.\nCalculates <code>self</code> + <code>rhs</code> + <code>carry</code> and returns a tuple …\nCalculates the “full multiplication” <code>self * rhs + carry</code>\nCalculates the “full multiplication” <code>self * rhs + carry</code>\nCalculates the “full multiplication” <code>self * rhs + carry</code>\nCalculates the “full multiplication” <code>self * rhs + carry</code>\nCalculates the “full multiplication” <code>self * rhs + carry</code>\nCasts to a pointer of another type.\nCasts to a pointer of another type.\nChanges constness without changing the type.\nChanges constness without changing the type.\nFinds the closest <code>x</code> not below <code>index</code> where …\nShareable mutable containers.\nEvaluates boolean combinations of configuration flags at …\nA macro for defining <code>#[cfg]</code> match-like statements.\nA character type.\nUtilities for the <code>char</code> primitive type.\nReturns an iterator over the <code>char</code>s of a string slice, and …\nReturns an iterator over the <code>char</code>s of a string slice.\nChecked absolute value. Computes <code>self.abs()</code>, returning <code>None</code>…\nChecked absolute value. Computes <code>self.abs()</code>, returning <code>None</code>…\nChecked absolute value. Computes <code>self.abs()</code>, returning <code>None</code>…\nChecked absolute value. Computes <code>self.abs()</code>, returning <code>None</code>…\nChecked absolute value. Computes <code>self.abs()</code>, returning <code>None</code>…\nChecked absolute value. Computes <code>self.abs()</code>, returning <code>None</code>…\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked addition with a signed integer. Computes <code>self + rhs</code>…\nChecked addition with a signed integer. Computes <code>self + rhs</code>…\nChecked addition with a signed integer. Computes <code>self + rhs</code>…\nChecked addition with a signed integer. Computes <code>self + rhs</code>…\nChecked addition with a signed integer. Computes <code>self + rhs</code>…\nChecked addition with a signed integer. Computes <code>self + rhs</code>…\nChecked addition with an unsigned integer. Computes …\nChecked addition with an unsigned integer. Computes …\nChecked addition with an unsigned integer. Computes …\nChecked addition with an unsigned integer. Computes …\nChecked addition with an unsigned integer. Computes …\nChecked addition with an unsigned integer. Computes …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> if …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> if …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> if …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> if …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> if …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> unless …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> unless …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> unless …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> unless …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> unless …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> if …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> unless …\nIf <code>rhs</code> is positive, calculates the smallest value greater …\nIf <code>rhs</code> is positive, calculates the smallest value greater …\nIf <code>rhs</code> is positive, calculates the smallest value greater …\nIf <code>rhs</code> is positive, calculates the smallest value greater …\nIf <code>rhs</code> is positive, calculates the smallest value greater …\nCalculates the smallest value greater than or equal to <code>self</code>…\nCalculates the smallest value greater than or equal to <code>self</code>…\nCalculates the smallest value greater than or equal to <code>self</code>…\nCalculates the smallest value greater than or equal to <code>self</code>…\nCalculates the smallest value greater than or equal to <code>self</code>…\nIf <code>rhs</code> is positive, calculates the smallest value greater …\nCalculates the smallest value greater than or equal to <code>self</code>…\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nChecked Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nChecked Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nChecked Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nChecked Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nChecked Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>, …\nChecked Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>, …\nChecked Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>, …\nChecked Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>, …\nChecked Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>, …\nChecked Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nChecked Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>, …\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked integer subtraction. Computes <code>self - rhs</code>, …\nChecked integer subtraction. Computes <code>self - rhs</code>, …\nChecked integer subtraction. Computes <code>self - rhs</code>, …\nChecked integer subtraction. Computes <code>self - rhs</code>, …\nChecked integer subtraction. Computes <code>self - rhs</code>, …\nChecked integer subtraction. Computes <code>self - rhs</code>, returning\nChecked integer subtraction. Computes <code>self - rhs</code>, returning\nChecked integer subtraction. Computes <code>self - rhs</code>, returning\nChecked integer subtraction. Computes <code>self - rhs</code>, returning\nChecked integer subtraction. Computes <code>self - rhs</code>, returning\nChecked integer subtraction. Computes <code>self - rhs</code>, …\nChecked integer subtraction. Computes <code>self - rhs</code>, returning\nChecked subtraction with an unsigned integer. Computes …\nChecked subtraction with an unsigned integer. Computes …\nChecked subtraction with an unsigned integer. Computes …\nChecked subtraction with an unsigned integer. Computes …\nChecked subtraction with an unsigned integer. Computes …\nChecked subtraction with an unsigned integer. Computes …\nReturns an iterator over <code>chunk_size</code> elements of the slice …\nReturns an iterator over <code>chunk_size</code> elements of the slice …\nReturns an iterator over <code>chunk_size</code> elements of the slice …\nReturns an iterator over <code>chunk_size</code> elements of the slice …\n\nRestrict a value to a certain interval unless it is NaN.\nRestrict a value to a certain interval unless it is NaN.\nReturns the floating point category of the number. If only …\nReturns the floating point category of the number. If only …\nThe <code>Clone</code> trait for types that cannot be ‘implicitly …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCopies the elements from <code>src</code> into <code>self</code>.\nUtilities for comparing and ordering values.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExpands to the column number at which it was invoked.\nCauses compilation to fail with the given error message …\nConcatenates literals into a static string slice.\nConcatenates literals into a byte slice.\nConcatenates identifiers into one identifier.\nSame as <code>format_args</code>, but can be used in some const …\nReturns <code>true</code> if the slice contains an element with the …\nReturns <code>true</code> if the given pattern matches a sub-slice of …\nTraits for conversions between types.\nCopies <code>count * size_of&lt;T&gt;</code> bytes from <code>src</code> to <code>self</code>. The …\nCopies <code>count * size_of&lt;T&gt;</code> bytes from <code>src</code> to <code>self</code>. The …\nCopies all elements from <code>src</code> into <code>self</code>, using a memcpy.\nCopies <code>count * size_of&lt;T&gt;</code> bytes from <code>self</code> to <code>dest</code>. The …\nCopies <code>count * size_of&lt;T&gt;</code> bytes from <code>self</code> to <code>dest</code>. The …\nCopies <code>count * size_of&lt;T&gt;</code> bytes from <code>self</code> to <code>dest</code>. The …\nCopies <code>count * size_of&lt;T&gt;</code> bytes from <code>self</code> to <code>dest</code>. The …\nCopies elements from one part of the slice to another part …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nAsserts that a boolean expression is <code>true</code> at runtime.\nAsserts that two expressions are equal to each other.\nAsserts that two expressions are not equal to each other.\nCreates an iterator over the UTF-16 encoded code points in …\nThe <code>Default</code> trait for types with a default value.\nReturns the default value of <code>false</code>\nReturns the default value of <code>\\x00</code>\nReturns the default value of <code>()</code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreates a mutable empty slice.\nCreates an empty slice.\nCreates an empty str\nCreates an empty mutable str\n\nReturns the default value of <code>0.0</code>\nReturns the default value of <code>0.0</code>\nReturns the default value of <code>0</code>\nReturns the default value of <code>0</code>\nReturns the default value of <code>0</code>\nReturns the default value of <code>0</code>\nReturns the default value of <code>0</code>\nReturns the default value of <code>0</code>\nReturns the default value of <code>0</code>\nReturns the default value of <code>0</code>\nReturns the default value of <code>0</code>\nReturns the default value of <code>0</code>\nReturns the default value of <code>0</code>\nReturns the default value of <code>0</code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis operation rounds towards zero, truncating any …\n\n\nThis operation rounds towards zero, truncating any …\n\n\n\n\n\nThis operation rounds towards zero, truncating any …\n\nThis operation rounds towards zero, truncating any …\n\n\n\n\n\n\nThis operation rounds towards zero, truncating any …\n\n\n\n\n\n\n\nThis operation rounds towards zero, truncating any …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of Euclidean division of <code>self</code> by …\nCalculates the quotient of Euclidean division of <code>self</code> by …\nCalculates the quotient of Euclidean division of <code>self</code> by …\nCalculates the quotient of Euclidean division of <code>self</code> by …\nCalculates the quotient of Euclidean division of <code>self</code> by …\nPerforms Euclidean division.\nPerforms Euclidean division.\nPerforms Euclidean division.\nPerforms Euclidean division.\nPerforms Euclidean division.\nCalculates the quotient of Euclidean division of <code>self</code> by …\nPerforms Euclidean division.\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nCalculates the quotient of <code>self</code> and <code>rhs</code>, rounding the …\nExecutes the destructor (if any) of the pointed-to value.\nBorrows each element mutably and returns an array of …\nBorrows each element and returns an array of references …\nEncodes this character as UTF-16 into the provided <code>u16</code> …\nReturns an iterator of <code>u16</code> over the string encoded as …\nEncodes this character as UTF-8 into the provided byte …\n\n\nReturns <code>true</code> if <code>needle</code> is a suffix of the slice.\nReturns <code>true</code> if the given pattern matches a suffix of this …\nInspects an environment variable at compile time.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChecks that two values are an ASCII case-insensitive match.\nChecks that two slices are an ASCII case-insensitive match.\nChecks that two strings are an ASCII case-insensitive …\nChecks that two values are an ASCII case-insensitive match.\nInterfaces for working with Errors.\nReturns an iterator that produces an escaped version of …\nReturns an iterator that produces an escaped version of a …\nReturns an iterator that yields the literal escape code of …\nReturn an iterator that escapes each char in <code>self</code> with …\nReturns an iterator that yields the literal escape code of …\nReturn an iterator that escapes each char in <code>self</code> with …\nReturns an iterator that yields the hexadecimal Unicode …\nReturn an iterator that escapes each char in <code>self</code> with …\nGets the “address” portion of the pointer, and ‘…\nGets the “address” portion of the pointer, and ‘…\n\nAllows to <code>extend</code> a tuple of collections that also …\n\n\n\nA 32-bit floating point type (specifically, the “binary32…\nConstants for the <code>f32</code> single-precision floating point type.\nA 64-bit floating point type (specifically, the “binary64…\nConstants for the <code>f64</code> double-precision floating point type.\nPlatform-specific types, as defined by C.\nExpands to the file name in which it was invoked.\nFills <code>self</code> with elements by cloning <code>value</code>.\nFills <code>self</code> with elements returned by calling a closure …\nReturns the byte index of the first character of this …\nReturns the first element of the slice, or <code>None</code> if it is …\nReturns the first <code>N</code> elements of the slice, or <code>None</code> if it …\nReturns a mutable reference to the first <code>N</code> elements of the …\nReturns a mutable pointer to the first element of the …\nTakes a <code>&amp;[[T; N]]</code>, and flattens it to a <code>&amp;[T]</code>.\nTakes a <code>&amp;mut [[T; N]]</code>, and flattens it to a <code>&amp;mut [T]</code>.\nFinds the closest <code>x</code> not exceeding <code>index</code> where …\nUtilities for formatting and printing strings.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFunction pointers, like <code>fn(usize) -&gt; bool</code>.\nConstructs parameters for the other string-formatting …\nSame as <code>format_args</code>, but adds a newline in the end.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\nConverts a <code>u8</code> into a <code>char</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n\n\n\nReturns the argument unchanged.\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\nConverts <code>u8</code> to <code>f32</code> losslessly.\nReturns the argument unchanged.\nConverts <code>bool</code> to <code>f32</code> losslessly. The resulting value is …\nConverts <code>i8</code> to <code>f32</code> losslessly.\nConverts <code>u16</code> to <code>f32</code> losslessly.\nConverts <code>i16</code> to <code>f32</code> losslessly.\nConverts <code>i32</code> to <code>f64</code> losslessly.\nReturns the argument unchanged.\nConverts <code>u16</code> to <code>f64</code> losslessly.\nConverts <code>f32</code> to <code>f64</code> losslessly.\nConverts <code>i16</code> to <code>f64</code> losslessly.\nConverts <code>u8</code> to <code>f64</code> losslessly.\nConverts <code>bool</code> to <code>f64</code> losslessly. The resulting value is …\nConverts <code>i8</code> to <code>f64</code> losslessly.\nConverts <code>u32</code> to <code>f64</code> losslessly.\nConverts a <code>NonZeroI8</code> into an <code>i8</code>\nReturns the argument unchanged.\nConverts a <code>bool</code> to a <code>i8</code>. The resulting value is <code>0</code> for <code>false</code>…\nConverts a <code>NonZeroI16</code> into an <code>i16</code>\nConverts a <code>bool</code> to a <code>i16</code>. The resulting value is <code>0</code> for …\nReturns the argument unchanged.\nConverts <code>i8</code> to <code>i16</code> losslessly.\nConverts <code>u8</code> to <code>i16</code> losslessly.\nConverts <code>u16</code> to <code>i32</code> losslessly.\nConverts <code>u8</code> to <code>i32</code> losslessly.\nConverts <code>i8</code> to <code>i32</code> losslessly.\nConverts a <code>NonZeroI32</code> into an <code>i32</code>\nConverts a <code>bool</code> to a <code>i32</code>. The resulting value is <code>0</code> for …\nConverts <code>i16</code> to <code>i32</code> losslessly.\nReturns the argument unchanged.\nConverts <code>i32</code> to <code>i64</code> losslessly.\nConverts <code>u8</code> to <code>i64</code> losslessly.\nConverts <code>i16</code> to <code>i64</code> losslessly.\nConverts <code>i8</code> to <code>i64</code> losslessly.\nConverts <code>u32</code> to <code>i64</code> losslessly.\nReturns the argument unchanged.\nConverts a <code>bool</code> to a <code>i64</code>. The resulting value is <code>0</code> for …\nConverts a <code>NonZeroI64</code> into an <code>i64</code>\nConverts <code>u16</code> to <code>i64</code> losslessly.\nConverts a <code>NonZeroI128</code> into an <code>i128</code>\nConverts <code>u32</code> to <code>i128</code> losslessly.\nConverts <code>u16</code> to <code>i128</code> losslessly.\nReturns the argument unchanged.\nConverts <code>i16</code> to <code>i128</code> losslessly.\nConverts a <code>bool</code> to a <code>i128</code>. The resulting value is <code>0</code> for …\nConverts <code>u8</code> to <code>i128</code> losslessly.\nConverts <code>i32</code> to <code>i128</code> losslessly.\nConverts <code>u64</code> to <code>i128</code> losslessly.\nConverts <code>i64</code> to <code>i128</code> losslessly.\nConverts <code>i8</code> to <code>i128</code> losslessly.\nConverts a <code>NonZeroU8</code> into an <code>u8</code>\nConverts a <code>bool</code> to a <code>u8</code>. The resulting value is <code>0</code> for <code>false</code>…\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts <code>u8</code> to <code>u16</code> losslessly.\nConverts a <code>NonZeroU16</code> into an <code>u16</code>\nConverts a <code>bool</code> to a <code>u16</code>. The resulting value is <code>0</code> for …\nConverts a <code>bool</code> to a <code>u32</code>. The resulting value is <code>0</code> for …\nUses <code>Ipv4Addr::to_bits</code> to convert an IPv4 address to a …\nConverts a <code>char</code> into a <code>u32</code>.\nReturns the argument unchanged.\nConverts <code>u16</code> to <code>u32</code> losslessly.\nConverts a <code>NonZeroU32</code> into an <code>u32</code>\nConverts <code>u8</code> to <code>u32</code> losslessly.\nConverts a <code>char</code> into a <code>u64</code>.\nConverts a <code>NonZeroU64</code> into an <code>u64</code>\nConverts a <code>bool</code> to a <code>u64</code>. The resulting value is <code>0</code> for …\nConverts <code>u16</code> to <code>u64</code> losslessly.\nConverts <code>u32</code> to <code>u64</code> losslessly.\nConverts <code>u8</code> to <code>u64</code> losslessly.\nReturns the argument unchanged.\nConverts <code>u32</code> to <code>u128</code> losslessly.\nConverts a <code>NonZeroU128</code> into an <code>u128</code>\nConverts <code>u8</code> to <code>u128</code> losslessly.\nUses <code>Ipv6Addr::to_bits</code> to convert an IPv6 address to a …\nConverts <code>u64</code> to <code>u128</code> losslessly.\nConverts a <code>bool</code> to a <code>u128</code>. The resulting value is <code>0</code> for …\nConverts <code>u16</code> to <code>u128</code> losslessly.\nConverts a <code>char</code> into a <code>u128</code>.\nReturns the argument unchanged.\nConverts <code>i8</code> to <code>isize</code> losslessly.\nConverts <code>u8</code> to <code>isize</code> losslessly.\nConverts <code>i16</code> to <code>isize</code> losslessly.\nReturns the argument unchanged.\nConverts a <code>NonZeroIsize</code> into an <code>isize</code>\nConverts a <code>bool</code> to a <code>isize</code>. The resulting value is <code>0</code> for …\nReturns the argument unchanged.\nConverts a <code>bool</code> to a <code>usize</code>. The resulting value is <code>0</code> for …\n\nConverts a <code>NonZeroUsize</code> into an <code>usize</code>\nConverts <code>u16</code> to <code>usize</code> losslessly.\nConverts <code>u8</code> to <code>usize</code> losslessly.\nReturns the argument unchanged.\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nCreate a floating point value from its representation as a …\nCreate a floating point value from its representation as a …\nCreate an integer value from its representation as a byte …\nCreate an integer value from its representation as a byte …\nCreate an integer value from its representation as a byte …\nCreate an integer value from its representation as a byte …\nCreate an integer value from its representation as a byte …\nCreate a native endian integer value from its …\nCreate a native endian integer value from its …\nCreate a native endian integer value from its …\nCreate a native endian integer value from its …\nCreate a native endian integer value from its …\nCreate an integer value from its representation as a byte …\nCreate a native endian integer value from its …\nCreates a pointer from its raw bits.\nCreates a pointer from its raw bits.\nRaw transmutation from <code>u32</code>.\nRaw transmutation from <code>u64</code>.\nConverts a digit in the given radix to a <code>char</code>.\n\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nCreate a floating point value from its representation as a …\nCreate a floating point value from its representation as a …\nCreate an integer value from its representation as a byte …\nCreate an integer value from its representation as a byte …\nCreate an integer value from its representation as a byte …\nCreate an integer value from its representation as a byte …\nCreate an integer value from its representation as a byte …\nCreate a native endian integer value from its …\nCreate a native endian integer value from its …\nCreate a native endian integer value from its …\nCreate a native endian integer value from its …\nCreate a native endian integer value from its …\nCreate an integer value from its representation as a byte …\nCreate a native endian integer value from its …\nCreate a floating point value from its representation as a …\nCreate a floating point value from its representation as a …\nCreate an integer value from its memory representation as …\nCreate an integer value from its memory representation as …\nCreate an integer value from its memory representation as …\nCreate an integer value from its memory representation as …\nCreate an integer value from its memory representation as …\nCreate a native endian integer value from its memory …\nCreate a native endian integer value from its memory …\nCreate a native endian integer value from its memory …\nCreate a native endian integer value from its memory …\nCreate a native endian integer value from its memory …\nCreate an integer value from its memory representation as …\nCreate a native endian integer value from its memory …\nParse a <code>bool</code> from a string.\n\nConverts a string in base 10 to a float. Accepts an …\nConverts a string in base 10 to a float. Accepts an …\n\n\n\n\n\n\n\n\n\n\n\n\nConverts a string slice in a given base to an integer.\nConverts a string slice in a given base to an integer.\nConverts a string slice in a given base to an integer.\nConverts a string slice in a given base to an integer.\nConverts a string slice in a given base to an integer.\nConverts a string slice in a given base to an integer.\nConverts a string slice in a given base to an integer.\nConverts a string slice in a given base to an integer.\nConverts a string slice in a given base to an integer.\nConverts a string slice in a given base to an integer.\nConverts a string slice in a given base to an integer.\nConverts a string slice in a given base to an integer.\nConverts a <code>u32</code> to a <code>char</code>.\nConverts a <code>u32</code> to a <code>char</code>, ignoring validity.\nAsynchronous basic functionality.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns a reference to an element or subslice depending on …\nReturns a subslice of <code>str</code>.\n\n\n\nReturns mutable references to many indices at once.\nReturns mutable references to many indices at once, …\nReturns a mutable reference to an element or subslice …\nReturns a mutable subslice of <code>str</code>.\n\n\n\nReturns a raw pointer to an element or subslice, without …\nReturns a reference to an element or subslice, without …\nReturns an unchecked subslice of <code>str</code>.\n\n\n\nReturns a raw pointer to an element or subslice, without …\nReturns a mutable reference to an element or subslice, …\nReturns a mutable, unchecked subslice of <code>str</code>.\n\n\n\nReturns an iterator over the slice producing …\nReturns an iterator over the slice producing …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns whether two pointers are guaranteed to be equal.\nReturns whether two pointers are guaranteed to be equal.\nReturns whether two pointers are guaranteed to be inequal.\nReturns whether two pointers are guaranteed to be inequal.\nGeneric hashing support.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHints to compiler that affects how code should be emitted …\nThe 128-bit signed integer type.\nRedundant constants module for the <code>i128</code> primitive type.\nThe 16-bit signed integer type.\nRedundant constants module for the <code>i16</code> primitive type.\nThe 32-bit signed integer type.\nRedundant constants module for the <code>i32</code> primitive type.\nThe 64-bit signed integer type.\nRedundant constants module for the <code>i64</code> primitive type.\nThe 8-bit signed integer type.\nRedundant constants module for the <code>i8</code> primitive type.\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the logarithm of the number with respect to an …\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nParses a file as an expression or an item according to the …\nIncludes a file as a reference to a byte array.\nIncludes a UTF-8 encoded file as a string.\n\n\n\n\n\n\n\n\n\n\n\n\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n\n\nCreates a consuming iterator, that is, one that moves each …\n\n\n\n\n\n\n\n\n\nCompiler intrinsics.\nTraits, helpers, and type definitions for core I/O …\nReturns whether the pointer is properly aligned for <code>T</code>.\nReturns whether the pointer is properly aligned for <code>T</code>.\nReturns whether the pointer is aligned to <code>align</code>.\nReturns whether the pointer is aligned to <code>align</code>.\nReturns <code>true</code> if this <code>char</code> has the <code>Alphabetic</code> property.\nReturns <code>true</code> if this <code>char</code> satisfies either <code>is_alphabetic()</code> …\nChecks if the value is within the ASCII range.\nChecks if all bytes in this slice are within the ASCII …\nChecks if all characters in this string are within the …\nChecks if the value is within the ASCII range.\nChecks if the value is an ASCII alphabetic character:\nChecks if the value is an ASCII alphabetic character:\nChecks if the value is an ASCII alphanumeric character:\nChecks if the value is an ASCII alphanumeric character:\nChecks if the value is an ASCII control character: U+0000 …\nChecks if the value is an ASCII control character: U+0000 …\nChecks if the value is an ASCII decimal digit: U+0030 ‘0…\nChecks if the value is an ASCII decimal digit: U+0030 ‘0…\nChecks if the value is an ASCII graphic character: U+0021 …\nChecks if the value is an ASCII graphic character: U+0021 …\nChecks if the value is an ASCII hexadecimal digit:\nChecks if the value is an ASCII hexadecimal digit:\nChecks if the value is an ASCII lowercase character: …\nChecks if the value is an ASCII lowercase character: …\nChecks if the value is an ASCII octal digit: U+0030 ‘0’…\nChecks if the value is an ASCII octal digit: U+0030 ‘0’…\nChecks if the value is an ASCII punctuation character:\nChecks if the value is an ASCII punctuation character:\nChecks if the value is an ASCII uppercase character: …\nChecks if the value is an ASCII uppercase character: …\nChecks if the value is an ASCII whitespace character: …\nChecks if the value is an ASCII whitespace character: …\nChecks that <code>index</code>-th byte is the first byte in a UTF-8 …\n\n\n\n\n\nChecks whether the pattern matches anywhere in the haystack\n\nReturns <code>true</code> if this <code>char</code> has the general category for …\nChecks if a <code>char</code> is a digit in the given radix.\nReturns <code>true</code> if the raw slice has a length of 0.\nReturns <code>true</code> if the raw slice has a length of 0.\nReturns <code>true</code> if the slice has a length of 0.\nReturns <code>true</code> if <code>self</code> has a length of zero bytes.\nReturns <code>true</code> if this number is neither infinite nor NaN.\nReturns <code>true</code> if this number is neither infinite nor NaN.\nReturns <code>true</code> if this value is positive infinity or …\nReturns <code>true</code> if this value is positive infinity or …\nReturns <code>true</code> if this <code>char</code> has the <code>Lowercase</code> property.\nReturns <code>true</code> if this value is NaN.\nReturns <code>true</code> if this value is NaN.\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if the number is neither zero, infinite, …\nReturns <code>true</code> if the number is neither zero, infinite, …\nReturns <code>true</code> if the pointer is null.\nReturns <code>true</code> if the pointer is null.\nReturns <code>true</code> if this <code>char</code> has one of the general …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\n\n\n\n\n\nChecks whether the pattern matches at the front of the …\n\nReturns <code>true</code> if <code>self</code> has a negative sign, including <code>-0.0</code>, …\nReturns <code>true</code> if <code>self</code> has a negative sign, including <code>-0.0</code>, …\nReturns <code>true</code> if <code>self</code> has a positive sign, including <code>+0.0</code>, …\nReturns <code>true</code> if <code>self</code> has a positive sign, including <code>+0.0</code>, …\nChecks if the elements of this slice are sorted.\nChecks if the elements of this slice are sorted using the …\nChecks if the elements of this slice are sorted using the …\nReturns <code>true</code> if the number is subnormal.\nReturns <code>true</code> if the number is subnormal.\n\n\n\n\nChecks whether the pattern matches at the back of the …\n\n\nReturns <code>true</code> if this <code>char</code> has the <code>Uppercase</code> property.\nChecks if the value is a Unicode surrogate code point, …\nReturns <code>true</code> if this <code>char</code> has the <code>White_Space</code> property.\nThe pointer-sized signed integer type.\nRedundant constants module for the <code>isize</code> primitive type.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nReturns the square root of the number, rounded down.\nComposable external iteration.\nReturns an iterator over the slice.\nReturns an iterator that allows modifying each value.\nReturns the last element of the slice, or <code>None</code> if it is …\nReturns the last element of the slice, or <code>None</code> if it is …\nReturns a mutable pointer to the last item in the slice.\nReturns a mutable pointer to the last item in the slice.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the number of leading ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the length of a raw slice.\nReturns the length of a raw slice.\nReturns the number of elements in the slice.\nReturns the length of <code>self</code>.\nReturns the number of 16-bit code units this <code>char</code> would …\nReturns the number of bytes this <code>char</code> would need if …\nExpands to the line number on which it was invoked.\nAn iterator over the lines of a string, as string slices.\nAn iterator over the lines of a string.\nPrints passed tokens into the standard output.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConverts this type to its ASCII lower case equivalent …\nConverts this slice to its ASCII lower case equivalent …\nConverts this string to its ASCII lower case equivalent …\nConverts this value to its ASCII lower case equivalent …\nConverts this type to its ASCII upper case equivalent …\nConverts this slice to its ASCII upper case equivalent …\nConverts this string to its ASCII upper case equivalent …\nConverts this value to its ASCII upper case equivalent …\nReturns an array of the same size as <code>self</code>, with function <code>f</code> …\nCreates a new pointer by mapping <code>self</code>’s address to a new …\nCreates a new pointer by mapping <code>self</code>’s address to a new …\nPrimitive traits and types representing basic properties …\nMasks out bits of the pointer according to a mask.\nMasks out bits of the pointer according to a mask.\nAn iterator over the disjoint matches of a pattern within …\nAn iterator over the disjoint matches of a pattern within …\nReturns whether the given expression matches any of the …\n\nReturns the maximum of the two numbers, ignoring NaN.\nReturns the maximum of the two numbers, ignoring NaN.\nNew code should prefer to use <code>i8::MAX</code> instead.\nNew code should prefer to use <code>i16::MAX</code> instead.\nNew code should prefer to use <code>i32::MAX</code> instead.\nNew code should prefer to use <code>i64::MAX</code> instead.\nNew code should prefer to use <code>i128::MAX</code> instead.\nNew code should prefer to use <code>u8::MAX</code> instead.\nNew code should prefer to use <code>u16::MAX</code> instead.\nNew code should prefer to use <code>u32::MAX</code> instead.\nNew code should prefer to use <code>u64::MAX</code> instead.\nNew code should prefer to use <code>u128::MAX</code> instead.\nNew code should prefer to use <code>isize::MAX</code> instead.\nNew code should prefer to use <code>usize::MAX</code> instead.\nReturns the maximum of the two numbers, propagating NaN.\nReturns the maximum of the two numbers, propagating NaN.\nBasic functions for dealing with memory.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\n\nReturns the minimum of the two numbers, ignoring NaN.\nReturns the minimum of the two numbers, ignoring NaN.\nNew code should prefer to use <code>i8::MIN</code> instead.\nNew code should prefer to use <code>i16::MIN</code> instead.\nNew code should prefer to use <code>i32::MIN</code> instead.\nNew code should prefer to use <code>i64::MIN</code> instead.\nNew code should prefer to use <code>i128::MIN</code> instead.\nNew code should prefer to use <code>u8::MIN</code> instead.\nNew code should prefer to use <code>u16::MIN</code> instead.\nNew code should prefer to use <code>u32::MIN</code> instead.\nNew code should prefer to use <code>u64::MIN</code> instead.\nNew code should prefer to use <code>u128::MIN</code> instead.\nNew code should prefer to use <code>isize::MIN</code> instead.\nNew code should prefer to use <code>usize::MIN</code> instead.\nReturns the minimum of the two numbers, propagating NaN.\nReturns the minimum of the two numbers, propagating NaN.\nExpands to a string that represents the current module …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNetworking primitives for IP communication.\nThe <code>!</code> type, also called “never”.\nReturns the greatest number less than <code>self</code>.\nReturns the greatest number less than <code>self</code>.\nIf <code>rhs</code> is positive, calculates the smallest value greater …\nIf <code>rhs</code> is positive, calculates the smallest value greater …\nIf <code>rhs</code> is positive, calculates the smallest value greater …\nIf <code>rhs</code> is positive, calculates the smallest value greater …\nIf <code>rhs</code> is positive, calculates the smallest value greater …\nCalculates the smallest value greater than or equal to <code>self</code>…\nCalculates the smallest value greater than or equal to <code>self</code>…\nCalculates the smallest value greater than or equal to <code>self</code>…\nCalculates the smallest value greater than or equal to <code>self</code>…\nCalculates the smallest value greater than or equal to <code>self</code>…\nIf <code>rhs</code> is positive, calculates the smallest value greater …\nCalculates the smallest value greater than or equal to <code>self</code>…\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the least number greater than <code>self</code>.\nReturns the least number greater than <code>self</code>.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNumeric traits and functions for the built-in numeric …\nCalculates the offset from a pointer.\nCalculates the offset from a pointer.\nCalculates the distance between two pointers. The returned …\nCalculates the distance between two pointers. The returned …\nOverloadable operators.\nOptional values.\nOptionally inspects an environment variable at compile …\nComputes the absolute value of <code>self</code>.\nComputes the absolute value of <code>self</code>.\nComputes the absolute value of <code>self</code>.\nComputes the absolute value of <code>self</code>.\nComputes the absolute value of <code>self</code>.\nComputes the absolute value of <code>self</code>.\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code> with a signed <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code> with a signed <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code> with a signed <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code> with a signed <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code> with a signed <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code> with a signed <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code> with an unsigned <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code> with an unsigned <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code> with an unsigned <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code> with an unsigned <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code> with an unsigned <code>rhs</code>\nCalculates <code>self</code> + <code>rhs</code> with an unsigned <code>rhs</code>\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the quotient of Euclidean division …\nCalculates the quotient of Euclidean division …\nCalculates the quotient of Euclidean division …\nCalculates the quotient of Euclidean division …\nCalculates the quotient of Euclidean division …\nCalculates the quotient of Euclidean division …\nCalculates the quotient of Euclidean division …\nCalculates the quotient of Euclidean division …\nCalculates the quotient of Euclidean division …\nCalculates the quotient of Euclidean division …\nCalculates the quotient of Euclidean division …\nCalculates the quotient of Euclidean division …\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nNegates self, overflowing if this is equal to the minimum …\nNegates self, overflowing if this is equal to the minimum …\nNegates self, overflowing if this is equal to the minimum …\nNegates self, overflowing if this is equal to the minimum …\nNegates self, overflowing if this is equal to the minimum …\nNegates self in an overflowing fashion.\nNegates self in an overflowing fashion.\nNegates self in an overflowing fashion.\nNegates self in an overflowing fashion.\nNegates self in an overflowing fashion.\nNegates self, overflowing if this is equal to the minimum …\nNegates self in an overflowing fashion.\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nOverflowing Euclidean remainder. Calculates …\nOverflowing Euclidean remainder. Calculates …\nOverflowing Euclidean remainder. Calculates …\nOverflowing Euclidean remainder. Calculates …\nOverflowing Euclidean remainder. Calculates …\nCalculates the remainder <code>self.rem_euclid(rhs)</code> as if by …\nCalculates the remainder <code>self.rem_euclid(rhs)</code> as if by …\nCalculates the remainder <code>self.rem_euclid(rhs)</code> as if by …\nCalculates the remainder <code>self.rem_euclid(rhs)</code> as if by …\nCalculates the remainder <code>self.rem_euclid(rhs)</code> as if by …\nOverflowing Euclidean remainder. Calculates …\nCalculates the remainder <code>self.rem_euclid(rhs)</code> as if by …\nShifts self left by <code>rhs</code> bits.\nShifts self left by <code>rhs</code> bits.\nShifts self left by <code>rhs</code> bits.\nShifts self left by <code>rhs</code> bits.\nShifts self left by <code>rhs</code> bits.\nShifts self left by <code>rhs</code> bits.\nShifts self left by <code>rhs</code> bits.\nShifts self left by <code>rhs</code> bits.\nShifts self left by <code>rhs</code> bits.\nShifts self left by <code>rhs</code> bits.\nShifts self left by <code>rhs</code> bits.\nShifts self left by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nCalculates <code>self</code> - <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code> with an unsigned <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code> with an unsigned <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code> with an unsigned <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code> with an unsigned <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code> with an unsigned <code>rhs</code>\nCalculates <code>self</code> - <code>rhs</code> with an unsigned <code>rhs</code>\nPanic support in the standard library.\nPanics the current thread.\nPanic support for core\nParses this string slice into another type.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMoves all consecutive repeated elements to the end of the …\nMoves all but the first of consecutive elements to the end …\nMoves all but the first of consecutive elements to the end …\nReturns the index of the partition point according to the …\nTypes that pin data to a location in memory.\nRaw, unsafe pointers, <code>*const T</code>, and <code>*mut T</code>.\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nThe core prelude\nThis module reexports the primitive types to allow usage …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nManually manage memory through raw pointers.\nReturns an iterator over <code>chunk_size</code> elements of the slice …\nReturns an iterator over <code>chunk_size</code> elements of the slice …\nReturns an iterator over <code>chunk_size</code> elements of the slice …\nReturns an iterator over <code>chunk_size</code> elements of the slice …\nReads the value from <code>self</code> without moving it. This leaves …\nReads the value from <code>self</code> without moving it. This leaves …\nReads the value from <code>self</code> without moving it. This leaves …\nReads the value from <code>self</code> without moving it. This leaves …\nPerforms a volatile read of the value from <code>self</code> without …\nPerforms a volatile read of the value from <code>self</code> without …\nTakes the reciprocal (inverse) of a number, <code>1/x</code>.\nTakes the reciprocal (inverse) of a number, <code>1/x</code>.\nReferences, <code>&amp;T</code> and <code>&amp;mut T</code>.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis operation satisfies <code>n % d == n - (n / d) * d</code>, and …\n\n\n\n\nThis operation satisfies <code>n % d == n - (n / d) * d</code>, and …\n\n\n\n\n\n\nThis operation satisfies <code>n % d == n - (n / d) * d</code>, and …\n\n\n\n\nThis operation satisfies <code>n % d == n - (n / d) * d</code>, and …\n\n\n\n\nThis operation satisfies <code>n % d == n - (n / d) * d</code>, and …\n\n\n\n\n\nThis operation satisfies <code>n % d == n - (n / d) * d</code>, and …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCalculates the least nonnegative remainder of …\nCalculates the least nonnegative remainder of …\nCalculates the least nonnegative remainder of …\nCalculates the least nonnegative remainder of …\nCalculates the least nonnegative remainder of …\nCalculates the least remainder of <code>self (mod rhs)</code>.\nCalculates the least remainder of <code>self (mod rhs)</code>.\nCalculates the least remainder of <code>self (mod rhs)</code>.\nCalculates the least remainder of <code>self (mod rhs)</code>.\nCalculates the least remainder of <code>self (mod rhs)</code>.\nCalculates the least nonnegative remainder of …\nCalculates the least remainder of <code>self (mod rhs)</code>.\nReplaces the value at <code>self</code> with <code>src</code>, returning the old …\nError handling with the <code>Result</code> type.\nReverses the order of elements in the slice, in place.\nReverses the order of bits in the integer. The least …\nReverses the order of bits in the integer. The least …\nReverses the order of bits in the integer. The least …\nReverses the order of bits in the integer. The least …\nReverses the order of bits in the integer. The least …\nReverses the order of bits in the integer. The least …\nReverses the order of bits in the integer. The least …\nReverses the order of bits in the integer. The least …\nReverses the order of bits in the integer. The least …\nReverses the order of bits in the integer. The least …\nReverses the order of bits in the integer. The least …\nReverses the order of bits in the integer. The least …\nReturns the byte index for the first character of the last …\nAn iterator over the disjoint matches of a pattern within …\nAn iterator over the disjoint matches of a pattern within …\nRotates the slice in-place such that the first <code>mid</code> …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nRotates the slice in-place such that the first …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nReturns an iterator over subslices separated by elements …\nAn iterator over substrings of the given string slice, …\nDivides one mutable array reference into two at an index …\nDivides one mutable slice into an array and a remainder …\nDivides one array reference into two at an index from the …\nDivides one slice into an array and a remainder slice at …\nReturns an iterator over mutable subslices separated by …\nSplits the slice on the last element that matches the …\nSplits the string on the last occurrence of the specified …\nAn iterator over substrings of <code>self</code>, separated by …\nReturns an iterator over subslices separated by elements …\nAn iterator over substrings of this string slice, …\nReturns an iterator over subslices separated by elements …\nSaturating absolute value. Computes <code>self.abs()</code>, returning …\nSaturating absolute value. Computes <code>self.abs()</code>, returning …\nSaturating absolute value. Computes <code>self.abs()</code>, returning …\nSaturating absolute value. Computes <code>self.abs()</code>, returning …\nSaturating absolute value. Computes <code>self.abs()</code>, returning …\nSaturating absolute value. Computes <code>self.abs()</code>, returning …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating addition with a signed integer. Computes …\nSaturating addition with a signed integer. Computes …\nSaturating addition with a signed integer. Computes …\nSaturating addition with a signed integer. Computes …\nSaturating addition with a signed integer. Computes …\nSaturating addition with a signed integer. Computes …\nSaturating addition with an unsigned integer. Computes …\nSaturating addition with an unsigned integer. Computes …\nSaturating addition with an unsigned integer. Computes …\nSaturating addition with an unsigned integer. Computes …\nSaturating addition with an unsigned integer. Computes …\nSaturating addition with an unsigned integer. Computes …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer negation. Computes <code>-self</code>, returning <code>MAX</code> …\nSaturating integer negation. Computes <code>-self</code>, returning <code>MAX</code> …\nSaturating integer negation. Computes <code>-self</code>, returning <code>MAX</code> …\nSaturating integer negation. Computes <code>-self</code>, returning <code>MAX</code> …\nSaturating integer negation. Computes <code>-self</code>, returning <code>MAX</code> …\nSaturating integer negation. Computes <code>-self</code>, returning <code>MAX</code> …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nSaturating subtraction with an unsigned integer. Computes …\nSaturating subtraction with an unsigned integer. Computes …\nSaturating subtraction with an unsigned integer. Computes …\nSaturating subtraction with an unsigned integer. Computes …\nSaturating subtraction with an unsigned integer. Computes …\nSaturating subtraction with an unsigned integer. Computes …\nReorder the slice such that the element at <code>index</code> is at its …\nReorder the slice with a comparator function such that the …\nReorder the slice with a key extraction function such that …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns a number representing sign of <code>self</code>.\nReturns a number representing sign of <code>self</code>.\nReturns a number representing sign of <code>self</code>.\nReturns a number representing sign of <code>self</code>.\nReturns a number representing sign of <code>self</code>.\nReturns a number representing sign of <code>self</code>.\nPortable SIMD module.\nA dynamically-sized view into a contiguous sequence, <code>[T]</code>. …\nSlice management and manipulation.\nCreates a string slice from another string slice, …\nCreates a string slice from another string slice, …\nSorts the slice of floats.\nSorts the slice of floats.\nSorts the slice, but might not preserve the order of equal …\nSorts the slice with a comparator function, but might not …\nSorts the slice with a key extraction function, but might …\nReturns an iterator over subslices separated by elements …\nAn iterator over substrings of this string slice, …\nDivides one mutable array reference into two at an index.\nDivides one mutable slice into an array and a remainder …\nDivides one array reference into two at an index.\nDivides one slice into an array and a remainder slice at …\nSplits a string slice by ASCII whitespace.\nDivides one slice into two at an index.\nDivide one string slice into two at an index.\nDivides one mutable raw slice into two at an index.\nDivides one mutable slice into two at an index.\nDivide one mutable string slice into two at an index.\nDivides one mutable raw slice into two at an index, …\nDivides one mutable slice into two at an index, without …\nDivides one slice into two at an index, without doing …\nReturns the first and all the rest of the elements of the …\nReturns the first <code>N</code> elements of the slice and the …\nReturns a mutable reference to the first <code>N</code> elements of the …\nReturns the first and all the rest of the elements of the …\nReturns an iterator over subslices separated by elements …\nAn iterator over substrings of this string slice, …\nReturns an iterator over mutable subslices separated by …\nReturns the last and all the rest of the elements of the …\nReturns the last <code>N</code> elements of the slice and the remainder,\nReturns the last and all the rest of the elements of the …\nReturns the last and all the rest of the elements of the …\nReturns an iterator over mutable subslices separated by …\nSplits the slice on the first element that matches the …\nSplits the string on the first occurrence of the specified …\nAn iterator over substrings of the given string slice, …\nSplits a string slice by whitespace.\nReturns an iterator over subslices separated by elements …\nAn iterator over substrings of the given string slice, …\nReturns an iterator over mutable subslices separated by …\n\n\nReturns <code>true</code> if <code>needle</code> is a prefix of the slice.\nReturns <code>true</code> if the given pattern matches a prefix of this …\n\n\n\n\n\n\n\n\n\n\n\n\n\nString slices.\nString manipulation.\nStringifies its arguments.\nReturns a subslice with the prefix removed.\nReturns a string slice with the prefix removed.\n\n\n\n\n\nRemoves the pattern from the front of haystack, if it …\n\nReturns a subslice with the suffix removed.\nReturns a string slice with the suffix removed.\n\n\n\n\n\nRemoves the pattern from the back of haystack, if it …\n\nCalculates the offset from a pointer (convenience for …\nCalculates the offset from a pointer (convenience for …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCalculates the distance between two pointers, <em>where it’s </em>…\nCalculates the distance between two pointers, <em>where it’s </em>…\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSwaps the values at two mutable locations of the same …\nSwaps two elements in the slice.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nSwaps two elements in the slice, without doing bounds …\nSwaps all elements in <code>self</code> with those in <code>other</code>.\nSynchronization primitives\nRemoves the subslice corresponding to the given range and …\nRemoves the first element of the slice and returns a …\nRemoves the first element of the slice and returns a …\nRemoves the last element of the slice and returns a …\nRemoves the last element of the slice and returns a mutable\nRemoves the subslice corresponding to the given range and …\nTypes and Traits for working with asynchronous tasks.\nReturns <code>Some(f())</code> if the <code>bool</code> is <code>true</code>, or <code>None</code> otherwise.\nReturns <code>Some(t)</code> if the <code>bool</code> is <code>true</code>, or <code>None</code> otherwise.\nTemporal quantification.\nMakes a copy of the value in its ASCII lower case …\nMakes a copy of the value in its ASCII lower case …\nMakes a copy of the value in its ASCII upper case …\nMakes a copy of the value in its ASCII upper case …\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nReturn the memory representation of this floating point …\nReturn the memory representation of this floating point …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nCasts a pointer to its raw bits.\nCasts a pointer to its raw bits.\nRaw transmutation to <code>u32</code>.\nRaw transmutation to <code>u64</code>.\nConverts radians to degrees.\nConverts radians to degrees.\nConverts a <code>char</code> to a digit in the given radix.\nRounds toward zero and converts to any primitive integer …\nRounds toward zero and converts to any primitive integer …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nReturn the memory representation of this floating point …\nReturn the memory representation of this floating point …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturns an iterator that yields the lowercase mapping of …\nReturn the memory representation of this floating point …\nReturn the memory representation of this floating point …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nConverts degrees to radians.\nConverts degrees to radians.\nDecompose a (possibly wide) pointer into its address and …\nDecompose a (possibly wide) pointer into its address and …\nReturns an iterator that yields the uppercase mapping of …\nIndicates unfinished code.\nReturn the ordering between <code>self</code> and <code>other</code>.\nReturn the ordering between <code>self</code> and <code>other</code>.\nEnables or disables tracing functionality used for …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nTransposes a <code>[MaybeUninit&lt;T&gt;; N]</code> into a <code>MaybeUninit&lt;[T; N]&gt;</code>…\nReturns a string slice with leading and trailing …\nReturns a byte slice with leading and trailing ASCII …\nReturns a string slice with leading and trailing ASCII …\nReturns a byte slice with trailing ASCII whitespace bytes …\nReturns a string slice with trailing ASCII whitespace …\nReturns a byte slice with leading ASCII whitespace bytes …\nReturns a string slice with leading ASCII whitespace …\nReturns a string slice with trailing whitespace removed.\nReturns a string slice with all suffixes that match a …\nReturns a string slice with leading whitespace removed.\nReturns a string slice with all prefixes that match a …\nReturns a string slice with all prefixes and suffixes that …\nReturns a string slice with trailing whitespace removed.\nReturns a string slice with all suffixes that match a …\nReturns a string slice with leading whitespace removed.\nReturns a string slice with all prefixes that match a …\nUnwraps a result or propagates its error.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\n\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\n\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\n\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\n\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\n\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\n\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTries to convert a <code>char</code> into a <code>u8</code>.\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTries to convert a <code>char</code> into a <code>u16</code>.\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\n\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\n\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\n\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\n\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\n\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\n\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\nTry to create the target number type from a source number …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA fallible function <code>f</code> applied to each element on array <code>self</code>…\nA finite heterogeneous sequence, <code>(T, U, ..)</code>.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe 128-bit unsigned integer type.\nRedundant constants module for the <code>u128</code> primitive type.\nThe 16-bit unsigned integer type.\nRedundant constants module for the <code>u16</code> primitive type.\nThe 32-bit unsigned integer type.\nRedundant constants module for the <code>u32</code> primitive type.\nThe 64-bit unsigned integer type.\nRedundant constants module for the <code>u64</code> primitive type.\nThe 8-bit unsigned integer type.\nRedundant constants module for the <code>u8</code> primitive type.\nUnchecked integer addition. Computes <code>self + rhs</code>, assuming …\nUnchecked integer addition. Computes <code>self + rhs</code>, assuming …\nUnchecked integer addition. Computes <code>self + rhs</code>, assuming …\nUnchecked integer addition. Computes <code>self + rhs</code>, assuming …\nUnchecked integer addition. Computes <code>self + rhs</code>, assuming …\nUnchecked integer addition. Computes <code>self + rhs</code>, assuming …\nUnchecked integer addition. Computes <code>self + rhs</code>, assuming …\nUnchecked integer addition. Computes <code>self + rhs</code>, assuming …\nUnchecked integer addition. Computes <code>self + rhs</code>, assuming …\nUnchecked integer addition. Computes <code>self + rhs</code>, assuming …\nUnchecked integer addition. Computes <code>self + rhs</code>, assuming …\nUnchecked integer addition. Computes <code>self + rhs</code>, assuming …\nUnchecked integer multiplication. Computes <code>self * rhs</code>, …\nUnchecked integer multiplication. Computes <code>self * rhs</code>, …\nUnchecked integer multiplication. Computes <code>self * rhs</code>, …\nUnchecked integer multiplication. Computes <code>self * rhs</code>, …\nUnchecked integer multiplication. Computes <code>self * rhs</code>, …\nUnchecked integer multiplication. Computes <code>self * rhs</code>, …\nUnchecked integer multiplication. Computes <code>self * rhs</code>, …\nUnchecked integer multiplication. Computes <code>self * rhs</code>, …\nUnchecked integer multiplication. Computes <code>self * rhs</code>, …\nUnchecked integer multiplication. Computes <code>self * rhs</code>, …\nUnchecked integer multiplication. Computes <code>self * rhs</code>, …\nUnchecked integer multiplication. Computes <code>self * rhs</code>, …\nUnchecked negation. Computes <code>-self</code>, assuming overflow …\nUnchecked negation. Computes <code>-self</code>, assuming overflow …\nUnchecked negation. Computes <code>-self</code>, assuming overflow …\nUnchecked negation. Computes <code>-self</code>, assuming overflow …\nUnchecked negation. Computes <code>-self</code>, assuming overflow …\nUnchecked negation. Computes <code>-self</code>, assuming overflow …\nUnchecked shift left. Computes <code>self &lt;&lt; rhs</code>, assuming that …\nUnchecked shift left. Computes <code>self &lt;&lt; rhs</code>, assuming that …\nUnchecked shift left. Computes <code>self &lt;&lt; rhs</code>, assuming that …\nUnchecked shift left. Computes <code>self &lt;&lt; rhs</code>, assuming that …\nUnchecked shift left. Computes <code>self &lt;&lt; rhs</code>, assuming that …\nUnchecked shift left. Computes <code>self &lt;&lt; rhs</code>, assuming that …\nUnchecked shift left. Computes <code>self &lt;&lt; rhs</code>, assuming that …\nUnchecked shift left. Computes <code>self &lt;&lt; rhs</code>, assuming that …\nUnchecked shift left. Computes <code>self &lt;&lt; rhs</code>, assuming that …\nUnchecked shift left. Computes <code>self &lt;&lt; rhs</code>, assuming that …\nUnchecked shift left. Computes <code>self &lt;&lt; rhs</code>, assuming that …\nUnchecked shift left. Computes <code>self &lt;&lt; rhs</code>, assuming that …\nUnchecked shift right. Computes <code>self &gt;&gt; rhs</code>, assuming that …\nUnchecked shift right. Computes <code>self &gt;&gt; rhs</code>, assuming that …\nUnchecked shift right. Computes <code>self &gt;&gt; rhs</code>, assuming that …\nUnchecked shift right. Computes <code>self &gt;&gt; rhs</code>, assuming that …\nUnchecked shift right. Computes <code>self &gt;&gt; rhs</code>, assuming that …\nUnchecked shift right. Computes <code>self &gt;&gt; rhs</code>, assuming that …\nUnchecked shift right. Computes <code>self &gt;&gt; rhs</code>, assuming that …\nUnchecked shift right. Computes <code>self &gt;&gt; rhs</code>, assuming that …\nUnchecked shift right. Computes <code>self &gt;&gt; rhs</code>, assuming that …\nUnchecked shift right. Computes <code>self &gt;&gt; rhs</code>, assuming that …\nUnchecked shift right. Computes <code>self &gt;&gt; rhs</code>, assuming that …\nUnchecked shift right. Computes <code>self &gt;&gt; rhs</code>, assuming that …\nUnchecked integer subtraction. Computes <code>self - rhs</code>, …\nUnchecked integer subtraction. Computes <code>self - rhs</code>, …\nUnchecked integer subtraction. Computes <code>self - rhs</code>, …\nUnchecked integer subtraction. Computes <code>self - rhs</code>, …\nUnchecked integer subtraction. Computes <code>self - rhs</code>, …\nUnchecked integer subtraction. Computes <code>self - rhs</code>, …\nUnchecked integer subtraction. Computes <code>self - rhs</code>, …\nUnchecked integer subtraction. Computes <code>self - rhs</code>, …\nUnchecked integer subtraction. Computes <code>self - rhs</code>, …\nUnchecked integer subtraction. Computes <code>self - rhs</code>, …\nUnchecked integer subtraction. Computes <code>self - rhs</code>, …\nUnchecked integer subtraction. Computes <code>self - rhs</code>, …\n\nIndicates unimplemented code by panicking with a message …\nThe <code>()</code> type, also called “unit”.\nIndicates unreachable code.\nComputes the absolute value of <code>self</code> without any wrapping …\nComputes the absolute value of <code>self</code> without any wrapping …\nComputes the absolute value of <code>self</code> without any wrapping …\nComputes the absolute value of <code>self</code> without any wrapping …\nComputes the absolute value of <code>self</code> without any wrapping …\nComputes the absolute value of <code>self</code> without any wrapping …\nThe pointer-sized unsigned integer type.\nRedundant constants module for the <code>usize</code> primitive type.\nCalculates the complete product <code>self * rhs</code> without the …\nCalculates the complete product <code>self * rhs</code> without the …\nCalculates the complete product <code>self * rhs</code> without the …\nCalculates the complete product <code>self * rhs</code> without the …\nCalculates the complete product <code>self * rhs</code> without the …\nReturns an iterator over all contiguous windows of length …\nCreates a new pointer with the given address.\nCreates a new pointer with the given address.\nUse the pointer value in a new pointer of another type.\nUse the pointer value in a new pointer of another type.\nWrapping (modular) absolute value. Computes <code>self.abs()</code>, …\nWrapping (modular) absolute value. Computes <code>self.abs()</code>, …\nWrapping (modular) absolute value. Computes <code>self.abs()</code>, …\nWrapping (modular) absolute value. Computes <code>self.abs()</code>, …\nWrapping (modular) absolute value. Computes <code>self.abs()</code>, …\nWrapping (modular) absolute value. Computes <code>self.abs()</code>, …\nCalculates the offset from a pointer using wrapping …\nCalculates the offset from a pointer using wrapping …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) addition with a signed integer. Computes\nWrapping (modular) addition with a signed integer. Computes\nWrapping (modular) addition with a signed integer. Computes\nWrapping (modular) addition with a signed integer. Computes\nWrapping (modular) addition with a signed integer. Computes\nWrapping (modular) addition with a signed integer. Computes\nWrapping (modular) addition with an unsigned integer. …\nWrapping (modular) addition with an unsigned integer. …\nWrapping (modular) addition with an unsigned integer. …\nWrapping (modular) addition with an unsigned integer. …\nWrapping (modular) addition with an unsigned integer. …\nWrapping (modular) addition with an unsigned integer. …\nCalculates the offset from a pointer in bytes using …\nCalculates the offset from a pointer in bytes using …\nCalculates the offset from a pointer in bytes using …\nCalculates the offset from a pointer in bytes using …\nCalculates the offset from a pointer in bytes using …\nCalculates the offset from a pointer in bytes using …\nWrapping (modular) division. Computes <code>self / rhs</code>, wrapping …\nWrapping (modular) division. Computes <code>self / rhs</code>, wrapping …\nWrapping (modular) division. Computes <code>self / rhs</code>, wrapping …\nWrapping (modular) division. Computes <code>self / rhs</code>, wrapping …\nWrapping (modular) division. Computes <code>self / rhs</code>, wrapping …\nWrapping (modular) division. Computes <code>self / rhs</code>. Wrapped …\nWrapping (modular) division. Computes <code>self / rhs</code>. Wrapped …\nWrapping (modular) division. Computes <code>self / rhs</code>. Wrapped …\nWrapping (modular) division. Computes <code>self / rhs</code>. Wrapped …\nWrapping (modular) division. Computes <code>self / rhs</code>. Wrapped …\nWrapping (modular) division. Computes <code>self / rhs</code>, wrapping …\nWrapping (modular) division. Computes <code>self / rhs</code>. Wrapped …\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>,\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>,\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>,\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>,\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>,\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>.\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>.\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>.\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>.\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>.\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>,\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>.\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nCalculates the offset from a pointer using wrapping …\nCalculates the offset from a pointer using wrapping …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) remainder. Computes <code>self % rhs</code>, …\nWrapping (modular) remainder. Computes <code>self % rhs</code>, …\nWrapping (modular) remainder. Computes <code>self % rhs</code>, …\nWrapping (modular) remainder. Computes <code>self % rhs</code>, …\nWrapping (modular) remainder. Computes <code>self % rhs</code>, …\nWrapping (modular) remainder. Computes <code>self % rhs</code>. Wrapped …\nWrapping (modular) remainder. Computes <code>self % rhs</code>. Wrapped …\nWrapping (modular) remainder. Computes <code>self % rhs</code>. Wrapped …\nWrapping (modular) remainder. Computes <code>self % rhs</code>. Wrapped …\nWrapping (modular) remainder. Computes <code>self % rhs</code>. Wrapped …\nWrapping (modular) remainder. Computes <code>self % rhs</code>, …\nWrapping (modular) remainder. Computes <code>self % rhs</code>. Wrapped …\nWrapping Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nWrapping Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nWrapping Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nWrapping Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nWrapping Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nWrapping Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>. …\nWrapping Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>. …\nWrapping Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>. …\nWrapping Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>. …\nWrapping Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>. …\nWrapping Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nWrapping Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>. …\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nCalculates the offset from a pointer using wrapping …\nCalculates the offset from a pointer using wrapping …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrapping (modular) subtraction with an unsigned integer. …\nWrapping (modular) subtraction with an unsigned integer. …\nWrapping (modular) subtraction with an unsigned integer. …\nWrapping (modular) subtraction with an unsigned integer. …\nWrapping (modular) subtraction with an unsigned integer. …\nWrapping (modular) subtraction with an unsigned integer. …\nOverwrites a memory location with the given value without …\nWrites formatted data into a buffer.\nInvokes memset on the specified pointer, setting …\nOverwrites a memory location with the given value without …\nPerforms a volatile write of a memory location with the …\nWrite formatted data into a buffer, with a newline …\nThe <code>AllocError</code> error indicates an allocation failure that …\nAn implementation of <code>Allocator</code> can allocate, grow, shrink, …\nA memory allocator that can be registered as the standard …\nLayout of a block of memory.\n\nThe parameters given to <code>Layout::from_size_align</code> or some …\nThe minimum byte alignment for a memory block of this …\nCreates a layout describing the record that can hold a …\nAllocate memory as described by the given <code>layout</code>.\nBehaves like <code>alloc</code>, but also ensures that the contents are …\nBehaves like <code>alloc</code>, but also ensures that the contents are …\nAttempts to allocate a block of memory.\nBehaves like <code>allocate</code>, but also ensures that the returned …\nCreates a layout describing the record for a <code>[T; n]</code>.\n\n\n\n\n\n\nCreates a “by reference” adapter for this instance of …\n\n\n\nCreates a <code>NonNull</code> that is dangling, but well-aligned for …\nDeallocate the block of memory at the given <code>ptr</code> pointer …\nDeallocates the memory referenced by <code>ptr</code>.\n\n\n\nCreates a layout describing the record for <code>self</code> followed by\nCreates a layout describing the record for <code>self</code> followed by\n\n\n\n\n\nProduces layout describing a record that could be used to …\nProduces layout describing a record that could be used to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs a <code>Layout</code> from a given <code>size</code> and <code>align</code>, or …\nCreates a layout, bypassing all checks.\nAttempts to extend the memory block.\nBehaves like <code>grow</code>, but also ensures that the new contents …\n\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstructs a <code>Layout</code> suitable for holding a value of type <code>T</code>.\nCreates a layout by rounding the size of this layout up to …\nReturns the amount of padding we must insert after <code>self</code> to …\nShrink or grow a block of memory to the given <code>new_size</code> in …\nShrink or grow a block of memory to the given <code>new_size</code> in …\nCreates a layout describing the record for <code>n</code> instances of …\nCreates a layout describing the record for <code>n</code> instances of …\nAttempts to shrink the memory block.\nThe minimum size in bytes for a memory block of this …\n\n\n\n\n\n\n\n\n\nA trait to emulate dynamic typing.\nA <code>TypeId</code> represents a globally unique identifier for a …\n\n\n\n\nForwards to the method defined on the type <code>dyn Any</code>.\nReturns some mutable reference to the inner value if it is …\nForwards to the method defined on the type <code>Any</code>.\nForwards to the method defined on the type <code>dyn Any</code>.\nForwards to the method defined on the type <code>Any</code>.\nReturns a mutable reference to the inner value as type …\nForwards to the method defined on the type <code>Any</code>.\nReturns some reference to the inner value if it is of type …\nForwards to the method defined on the type <code>dyn Any</code>.\nForwards to the method defined on the type <code>dyn Any</code>.\nReturns a reference to the inner value as type <code>dyn T</code>.\nForwards to the method defined on the type <code>Any</code>.\n\n\n\n\n\nReturns the argument unchanged.\n\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the inner type is the same as <code>T</code>.\nForwards to the method defined on the type <code>Any</code>.\nForwards to the method defined on the type <code>dyn Any</code>.\nReturns the <code>TypeId</code> of the type this generic function has …\n\n\n\nGets the <code>TypeId</code> of <code>self</code>.\n\nReturns the name of a type as a string slice.\nReturns the type name of the pointed-to value as a string …\nPlatform-specific intrinsics for the <code>aarch64</code> platform.\nPlatform-specific intrinsics for the <code>arm</code> platform.\nInline assembly.\nModule-level inline assembly.\nPlatform-specific intrinsics for the <code>mips</code> platform.\nPlatform-specific intrinsics for the <code>mips64</code> platform.\nPlatform-specific intrinsics for the <code>NVPTX</code> platform.\nPlatform-specific intrinsics for the <code>PowerPC</code> platform.\nPlatform-specific intrinsics for the <code>PowerPC64</code> platform.\nPlatform-specific intrinsics for the <code>riscv32</code> platform.\nPlatform-specific intrinsics for the <code>riscv64</code> platform.\nPlatform-specific intrinsics for the <code>wasm</code> target family.\nPlatform-specific intrinsics for the <code>wasm32</code> platform.\nPlatform-specific intrinsics for the <code>wasm64</code> platform.\nPlatform-specific intrinsics for the <code>x86</code> platform.\nPlatform-specific intrinsics for the <code>x86_64</code> platform.\nFull system is the required shareability domain, reads and …\nSee <code>prefetch</code>.\nSee <code>prefetch</code>.\nSee <code>prefetch</code>.\nSee <code>prefetch</code>.\nSee <code>prefetch</code>.\nSee <code>prefetch</code>.\nTransaction executed a TCANCEL instruction\nTransaction aborted due to a debug trap.\nTransaction aborted because a non-permissible operation …\nFallback error type for any other reason\nTransaction failed from interrupt\nTransaction aborted because a conflict occurred\nTransaction aborted due to transactional nesting level was …\nExtraction mask for failure reason\nTransaction retry is possible.\nTransaction aborted due to read or write set limit was …\nIndicates a TRIVIAL version of TM is available\nTransaction successfully started.\nCRC32 single round checksum for bytes (8 bits).\nCRC32-C single round checksum for bytes (8 bits).\nCRC32-C single round checksum for quad words (64 bits).\nCRC32-C single round checksum for half words (16 bits).\nCRC32-C single round checksum for words (32 bits).\nCRC32 single round checksum for quad words (64 bits).\nCRC32 single round checksum for half words (16 bits).\nCRC32 single round checksum for words (32 bits).\nGenerates a DMB (data memory barrier) instruction or …\nGenerates a DSB (data synchronization barrier) instruction …\nGenerates an ISB (instruction synchronization barrier) …\nGenerates an unspecified no-op instruction.\nGenerates a SEV (send a global event) hint instruction.\nGenerates a send a local event hint instruction.\nCancels the current transaction and discards all state …\nCommits the current transaction. For a nested transaction, …\nStarts a new transaction. When the transaction starts …\nTests if executing inside a transaction. If no transaction …\nGenerates a WFE (wait for event) hint instruction, or …\nGenerates a WFI (wait for interrupt) hint instruction, or …\nGenerates a YIELD hint instruction.\nFetch the cache line that contains address <code>p</code> using the …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nARM-specific 64-bit wide vector of two packed <code>f32</code>.\nARM-specific type containing two <code>float32x2_t</code> vectors.\nARM-specific type containing three <code>float32x2_t</code> vectors.\nARM-specific type containing four <code>float32x2_t</code> vectors.\nARM-specific 128-bit wide vector of four packed <code>f32</code>.\nARM-specific type containing two <code>float32x4_t</code> vectors.\nARM-specific type containing three <code>float32x4_t</code> vectors.\nARM-specific type containing four <code>float32x4_t</code> vectors.\nARM-specific 64-bit wide vector of one packed <code>f64</code>.\nARM-specific type containing two <code>float64x1_t</code> vectors.\nARM-specific type containing three <code>float64x1_t</code> vectors.\nARM-specific type containing four <code>float64x1_t</code> vectors.\nARM-specific 128-bit wide vector of two packed <code>f64</code>.\nARM-specific type containing two <code>float64x2_t</code> vectors.\nARM-specific type containing three <code>float64x2_t</code> vectors.\nARM-specific type containing four <code>float64x2_t</code> vectors.\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nARM-specific 64-bit wide vector of four packed <code>i16</code>.\nARM-specific type containing two <code>int16x4_t</code> vectors.\nARM-specific type containing three <code>int16x4_t</code> vectors.\nARM-specific type containing four <code>int16x4_t</code> vectors.\nARM-specific 128-bit wide vector of eight packed <code>i16</code>.\nARM-specific type containing two <code>int16x8_t</code> vectors.\nARM-specific type containing three <code>int16x8_t</code> vectors.\nARM-specific type containing four <code>int16x8_t</code> vectors.\nARM-specific 64-bit wide vector of two packed <code>i32</code>.\nARM-specific type containing two <code>int32x2_t</code> vectors.\nARM-specific type containing three <code>int32x2_t</code> vectors.\nARM-specific type containing four <code>int32x2_t</code> vectors.\nARM-specific 128-bit wide vector of four packed <code>i32</code>.\nARM-specific type containing two <code>int32x4_t</code> vectors.\nARM-specific type containing three <code>int32x4_t</code> vectors.\nARM-specific type containing four <code>int32x4_t</code> vectors.\nARM-specific 64-bit wide vector of one packed <code>i64</code>.\nARM-specific type containing four <code>int64x1_t</code> vectors.\nARM-specific type containing four <code>int64x1_t</code> vectors.\nARM-specific type containing four <code>int64x1_t</code> vectors.\nARM-specific 128-bit wide vector of two packed <code>i64</code>.\nARM-specific type containing four <code>int64x2_t</code> vectors.\nARM-specific type containing four <code>int64x2_t</code> vectors.\nARM-specific type containing four <code>int64x2_t</code> vectors.\nARM-specific 128-bit wide vector of sixteen packed <code>i8</code>.\nARM-specific type containing two <code>int8x16_t</code> vectors.\nARM-specific type containing three <code>int8x16_t</code> vectors.\nARM-specific type containing four <code>int8x16_t</code> vectors.\nARM-specific 64-bit wide vector of eight packed <code>i8</code>.\nARM-specific type containing two <code>int8x8_t</code> vectors.\nARM-specific type containing three <code>int8x8_t</code> vectors.\nARM-specific type containing four <code>int8x8_t</code> vectors.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nARM-specific 64-bit wide vector of four packed <code>p16</code>.\nARM-specific type containing two <code>poly16x4_t</code> vectors.\nARM-specific type containing three <code>poly16x4_t</code> vectors.\nARM-specific type containing four <code>poly16x4_t</code> vectors.\nARM-specific 128-bit wide vector of eight packed <code>p16</code>.\nARM-specific type containing two <code>poly16x8_t</code> vectors.\nARM-specific type containing three <code>poly16x8_t</code> vectors.\nARM-specific type containing four <code>poly16x8_t</code> vectors.\nARM-specific 64-bit wide vector of one packed <code>p64</code>.\nARM-specific type containing four <code>poly64x1_t</code> vectors.\nARM-specific type containing four <code>poly64x1_t</code> vectors.\nARM-specific type containing four <code>poly64x1_t</code> vectors.\nARM-specific 128-bit wide vector of two packed <code>p64</code>.\nARM-specific type containing four <code>poly64x2_t</code> vectors.\nARM-specific type containing four <code>poly64x2_t</code> vectors.\nARM-specific type containing four <code>poly64x2_t</code> vectors.\nARM-specific 128-bit wide vector of sixteen packed <code>p8</code>.\nARM-specific type containing two <code>poly8x16_t</code> vectors.\nARM-specific type containing three <code>poly8x16_t</code> vectors.\nARM-specific type containing four <code>poly8x16_t</code> vectors.\nARM-specific 64-bit wide polynomial vector of eight packed …\nARM-specific type containing two <code>poly8x8_t</code> vectors.\nARM-specific type containing three <code>poly8x8_t</code> vectors.\nARM-specific type containing four <code>poly8x8_t</code> vectors.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nARM-specific 64-bit wide vector of four packed <code>u16</code>.\nARM-specific type containing two <code>uint16x4_t</code> vectors.\nARM-specific type containing three <code>uint16x4_t</code> vectors.\nARM-specific type containing four <code>uint16x4_t</code> vectors.\nARM-specific 128-bit wide vector of eight packed <code>u16</code>.\nARM-specific type containing two <code>uint16x8_t</code> vectors.\nARM-specific type containing three <code>uint16x8_t</code> vectors.\nARM-specific type containing four <code>uint16x8_t</code> vectors.\nARM-specific 64-bit wide vector of two packed <code>u32</code>.\nARM-specific type containing two <code>uint32x2_t</code> vectors.\nARM-specific type containing three <code>uint32x2_t</code> vectors.\nARM-specific type containing four <code>uint32x2_t</code> vectors.\nARM-specific 128-bit wide vector of four packed <code>u32</code>.\nARM-specific type containing two <code>uint32x4_t</code> vectors.\nARM-specific type containing three <code>uint32x4_t</code> vectors.\nARM-specific type containing four <code>uint32x4_t</code> vectors.\nARM-specific 64-bit wide vector of one packed <code>u64</code>.\nARM-specific type containing four <code>uint64x1_t</code> vectors.\nARM-specific type containing four <code>uint64x1_t</code> vectors.\nARM-specific type containing four <code>uint64x1_t</code> vectors.\nARM-specific 128-bit wide vector of two packed <code>u64</code>.\nARM-specific type containing four <code>uint64x2_t</code> vectors.\nARM-specific type containing four <code>uint64x2_t</code> vectors.\nARM-specific type containing four <code>uint64x2_t</code> vectors.\nARM-specific 128-bit wide vector of sixteen packed <code>u8</code>.\nARM-specific type containing two <code>uint8x16_t</code> vectors.\nARM-specific type containing three <code>uint8x16_t</code> vectors.\nARM-specific type containing four <code>uint8x16_t</code> vectors.\nARM-specific 64-bit wide vector of eight packed <code>u8</code>.\nARM-specific type containing two <code>uint8x8_t</code> vectors.\nARM-specific type containing three <code>uint8x8_t</code> vectors.\nARM-specific type containing four <code>uint8x8_t</code> vectors.\n\n\n\n\n\n\nSigned Absolute difference and Accumulate Long\nSigned Absolute difference and Accumulate Long\nSigned Absolute difference and Accumulate Long\nUnsigned Absolute difference and Accumulate Long\nUnsigned Absolute difference and Accumulate Long\nUnsigned Absolute difference and Accumulate Long\nSigned Absolute difference and Accumulate Long\nSigned Absolute difference and Accumulate Long\nSigned Absolute difference and Accumulate Long\nUnsigned Absolute difference and Accumulate Long\nUnsigned Absolute difference and Accumulate Long\nUnsigned Absolute difference and Accumulate Long\n\n\n\n\n\n\nAbsolute difference between the arguments of Floating\nAbsolute difference between the arguments of Floating\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nFloating-point absolute difference\nSigned Absolute difference Long\nSigned Absolute difference Long\nSigned Absolute difference Long\nUnsigned Absolute difference Long\nUnsigned Absolute difference Long\nUnsigned Absolute difference Long\nSigned Absolute difference Long\nSigned Absolute difference Long\nSigned Absolute difference Long\nUnsigned Absolute difference Long\nUnsigned Absolute difference Long\nUnsigned Absolute difference Long\nAbsolute difference between the arguments of Floating\nAbsolute difference between the arguments of Floating\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nFloating-point absolute difference\nFloating-point absolute value\nFloating-point absolute value\nAbsolute value (wrapping).\nAbsolute value (wrapping).\nAbsolute Value (wrapping).\nAbsolute value (wrapping).\nAbsolute Value (wrapping).\nFloating-point absolute value\nFloating-point absolute value\nAbsolute value (wrapping).\nAbsolute value (wrapping).\nAbsolute Value (wrapping).\nAbsolute value (wrapping).\nVector add.\nVector add.\nBitwise exclusive OR\nBitwise exclusive OR\nBitwise exclusive OR\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nAdd returning High Narrow (high half).\nAdd returning High Narrow (high half).\nAdd returning High Narrow (high half).\nAdd returning High Narrow (high half).\nAdd returning High Narrow (high half).\nAdd returning High Narrow (high half).\nAdd returning High Narrow.\nAdd returning High Narrow.\nAdd returning High Narrow.\nAdd returning High Narrow.\nAdd returning High Narrow.\nAdd returning High Narrow.\nSigned Add Long (vector, high half).\nSigned Add Long (vector, high half).\nSigned Add Long (vector, high half).\nUnsigned Add Long (vector, high half).\nUnsigned Add Long (vector, high half).\nUnsigned Add Long (vector, high half).\nSigned Add Long (vector).\nSigned Add Long (vector).\nSigned Add Long (vector).\nUnsigned Add Long (vector).\nUnsigned Add Long (vector).\nUnsigned Add Long (vector).\nSigned Add Long across Vector\nSigned Add Long across Vector\nSigned Add Long across Vector\nUnsigned Add Long across Vector\nUnsigned Add Long across Vector\nUnsigned Add Long across Vector\nSigned Add Long across Vector\nSigned Add Long across Vector\nSigned Add Long across Vector\nUnsigned Add Long across Vector\nUnsigned Add Long across Vector\nUnsigned Add Long across Vector\nVector add.\nVector add.\nBitwise exclusive OR\nBitwise exclusive OR\nBitwise exclusive OR\nBitwise exclusive OR\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nFloating-point add across vector\nAdd across vector\nAdd across vector\nAdd across vector\nAdd across vector\nAdd across vector\nAdd across vector\nFloating-point add across vector\nFloating-point add across vector\nAdd across vector\nAdd across vector\nAdd across vector\nAdd across vector\nAdd across vector\nAdd across vector\nAdd across vector\nAdd across vector\nSigned Add Wide (high half).\nSigned Add Wide (high half).\nSigned Add Wide (high half).\nUnsigned Add Wide (high half).\nUnsigned Add Wide (high half).\nUnsigned Add Wide (high half).\nSigned Add Wide.\nSigned Add Wide.\nSigned Add Wide.\nUnsigned Add Wide.\nUnsigned Add Wide.\nUnsigned Add Wide.\nAES single round decryption.\nAES single round encryption.\nAES inverse mix columns.\nAES mix columns.\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nBit clear and exclusive OR\nBit clear and exclusive OR\nBit clear and exclusive OR\nBit clear and exclusive OR\nBit clear and exclusive OR\nBit clear and exclusive OR\nBit clear and exclusive OR\nBit clear and exclusive OR\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nBitwise Select.\nBitwise Select instructions. This instruction sets each …\nBitwise Select.\nBitwise Select.\nBitwise Select.\nBitwise Select.\nBitwise Select.\nBitwise Select.\nBitwise Select instructions. This instruction sets each …\nBitwise Select.\nBitwise Select.\nBitwise Select.\nBitwise Select.\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nFloating-point complex add\nFloating-point complex add\nFloating-point complex add\nFloating-point complex add\nFloating-point complex add\nFloating-point complex add\nFloating-point absolute compare greater than or equal\nFloating-point absolute compare greater than or equal\nFloating-point absolute compare greater than or equal\nFloating-point absolute compare greater than or equal\nFloating-point absolute compare greater than or equal\nFloating-point absolute compare greater than or equal\nFloating-point absolute compare greater than\nFloating-point absolute compare greater than\nFloating-point absolute compare greater than\nFloating-point absolute compare greater than\nFloating-point absolute compare greater than\nFloating-point absolute compare greater than\nFloating-point absolute compare less than or equal\nFloating-point absolute compare less than or equal\nFloating-point absolute compare less than or equal\nFloating-point absolute compare less than or equal\nFloating-point absolute compare less than or equal\nFloating-point absolute compare less than or equal\nFloating-point absolute compare less than\nFloating-point absolute compare less than\nFloating-point absolute compare less than\nFloating-point absolute compare less than\nFloating-point absolute compare less than\nFloating-point absolute compare less than\nFloating-point compare equal\nFloating-point compare equal\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nFloating-point compare equal\nCompare bitwise equal\nCompare bitwise equal\nFloating-point compare equal\nFloating-point compare equal\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nFloating-point compare equal\nFloating-point compare bitwise equal to zero\nFloating-point compare bitwise equal to zero\nSigned compare bitwise equal to zero\nSigned compare bitwise equal to zero\nSigned compare bitwise equal to zero\nSigned compare bitwise equal to zero\nSigned compare bitwise equal to zero\nSigned compare bitwise equal to zero\nUnsigned compare bitwise equal to zero\nUnsigned compare bitwise equal to zero\nUnsigned compare bitwise equal to zero\nUnsigned compare bitwise equal to zero\nFloating-point compare bitwise equal to zero\nCompare bitwise equal to zero\nCompare bitwise equal to zero\nFloating-point compare bitwise equal to zero\nFloating-point compare bitwise equal to zero\nSigned compare bitwise equal to zero\nSigned compare bitwise equal to zero\nSigned compare bitwise equal to zero\nSigned compare bitwise equal to zero\nSigned compare bitwise equal to zero\nSigned compare bitwise equal to zero\nUnsigned compare bitwise equal to zero\nUnsigned compare bitwise equal to zero\nUnsigned compare bitwise equal to zero\nUnsigned compare bitwise equal to zero\nFloating-point compare bitwise equal to zero\nFloating-point compare greater than or equal\nFloating-point compare greater than or equal\nCompare signed greater than or equal\nCompare signed greater than or equal\nCompare signed greater than or equal\nCompare signed greater than or equal\nCompare unsigned greater than or equal\nCompare unsigned greater than or equal\nCompare unsigned greater than or equal\nCompare unsigned greater than or equal\nFloating-point compare greater than or equal\nCompare greater than or equal\nCompare greater than or equal\nFloating-point compare greater than or equal\nFloating-point compare greater than or equal\nCompare signed greater than or equal\nCompare signed greater than or equal\nCompare signed greater than or equal\nCompare signed greater than or equal\nCompare unsigned greater than or equal\nCompare unsigned greater than or equal\nCompare unsigned greater than or equal\nCompare unsigned greater than or equal\nFloating-point compare greater than or equal\nFloating-point compare greater than or equal to zero\nFloating-point compare greater than or equal to zero\nCompare signed greater than or equal to zero\nCompare signed greater than or equal to zero\nCompare signed greater than or equal to zero\nCompare signed greater than or equal to zero\nFloating-point compare greater than or equal to zero\nCompare signed greater than or equal to zero\nFloating-point compare greater than or equal to zero\nFloating-point compare greater than or equal to zero\nCompare signed greater than or equal to zero\nCompare signed greater than or equal to zero\nCompare signed greater than or equal to zero\nCompare signed greater than or equal to zero\nFloating-point compare greater than or equal to zero\nFloating-point compare greater than\nFloating-point compare greater than\nCompare signed greater than\nCompare signed greater than\nCompare signed greater than\nCompare signed greater than\nCompare unsigned greater than\nCompare unsigned greater than\nCompare unsigned greater than\nCompare unsigned greater than\nFloating-point compare greater than\nCompare greater than\nCompare greater than\nFloating-point compare greater than\nFloating-point compare greater than\nCompare signed greater than\nCompare signed greater than\nCompare signed greater than\nCompare signed greater than\nCompare unsigned greater than\nCompare unsigned greater than\nCompare unsigned greater than\nCompare unsigned greater than\nFloating-point compare greater than\nFloating-point compare greater than zero\nFloating-point compare greater than zero\nCompare signed greater than zero\nCompare signed greater than zero\nCompare signed greater than zero\nCompare signed greater than zero\nFloating-point compare greater than zero\nCompare signed greater than zero\nFloating-point compare greater than zero\nFloating-point compare greater than zero\nCompare signed greater than zero\nCompare signed greater than zero\nCompare signed greater than zero\nCompare signed greater than zero\nFloating-point compare greater than zero\nFloating-point compare less than or equal\nFloating-point compare less than or equal\nCompare signed less than or equal\nCompare signed less than or equal\nCompare signed less than or equal\nCompare signed less than or equal\nCompare unsigned less than or equal\nCompare unsigned less than or equal\nCompare unsigned less than or equal\nCompare unsigned less than or equal\nFloating-point compare less than or equal\nCompare less than or equal\nCompare less than or equal\nFloating-point compare less than or equal\nFloating-point compare less than or equal\nCompare signed less than or equal\nCompare signed less than or equal\nCompare signed less than or equal\nCompare signed less than or equal\nCompare unsigned less than or equal\nCompare unsigned less than or equal\nCompare unsigned less than or equal\nCompare unsigned less than or equal\nFloating-point compare less than or equal\nFloating-point compare less than or equal to zero\nFloating-point compare less than or equal to zero\nCompare signed less than or equal to zero\nCompare signed less than or equal to zero\nCompare signed less than or equal to zero\nCompare signed less than or equal to zero\nFloating-point compare less than or equal to zero\nCompare less than or equal to zero\nFloating-point compare less than or equal to zero\nFloating-point compare less than or equal to zero\nCompare signed less than or equal to zero\nCompare signed less than or equal to zero\nCompare signed less than or equal to zero\nCompare signed less than or equal to zero\nFloating-point compare less than or equal to zero\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nFloating-point compare less than\nFloating-point compare less than\nCompare signed less than\nCompare signed less than\nCompare signed less than\nCompare signed less than\nCompare unsigned less than\nCompare unsigned less than\nCompare unsigned less than\nCompare unsigned less than\nFloating-point compare less than\nCompare less than\nCompare less than\nFloating-point compare less than\nFloating-point compare less than\nCompare signed less than\nCompare signed less than\nCompare signed less than\nCompare signed less than\nCompare unsigned less than\nCompare unsigned less than\nCompare unsigned less than\nCompare unsigned less than\nFloating-point compare less than\nFloating-point compare less than zero\nFloating-point compare less than zero\nCompare signed less than zero\nCompare signed less than zero\nCompare signed less than zero\nCompare signed less than zero\nFloating-point compare less than zero\nCompare less than zero\nFloating-point compare less than zero\nFloating-point compare less than zero\nCompare signed less than zero\nCompare signed less than zero\nCompare signed less than zero\nCompare signed less than zero\nFloating-point compare less than zero\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nFloating-point complex multiply accumulate\nPopulation count per byte.\nPopulation count per byte.\nPopulation count per byte.\nPopulation count per byte.\nPopulation count per byte.\nPopulation count per byte.\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nInsert vector element from another vector element\nDuplicate vector element to vector or scalar\nInsert vector element from another vector element\nDuplicate vector element to vector or scalar\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nDuplicate vector element to vector or scalar\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nDuplicate vector element to vector or scalar\nInsert vector element from another vector element\nInsert vector element from another vector element\nDuplicate vector element to vector or scalar\nInsert vector element from another vector element\nDuplicate vector element to vector or scalar\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nDuplicate vector element to vector or scalar\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nDuplicate vector element to vector or scalar\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nFloating-point convert to lower precision narrow\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFloating-point convert to higher precision long\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFloating-point convert to lower precision narrow\nFloating-point convert to higher precision long\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to signed fixed-point, rounding …\nFloating-point convert to signed fixed-point, rounding …\nFloating-point convert to unsigned fixed-point, rounding …\nFloating-point convert to unsigned fixed-point, rounding …\nFloating-point convert to signed integer, rounding to …\nFloating-point convert to signed integer, rounding to …\nFloating-point convert to unsigned integer, rounding to …\nFloating-point convert to unsigned integer, rounding to …\nFloating-point convert to integer, rounding to nearest …\nFloating-point convert to integer, rounding to nearest …\nFloating-point convert to signed integer, rounding to …\nFloating-point convert to signed integer, rounding to …\nFloating-point convert to unsigned integer, rounding to …\nFloating-point convert to unsigned integer, rounding to …\nFloating-point convert to integer, rounding to nearest …\nFloating-point convert to integer, rounding to nearest …\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to fixed-point, rounding toward zero\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFloating-point convert to signed integer, rounding toward …\nFloating-point convert to signed integer, rounding toward …\nFloating-point convert to unsigned integer, rounding …\nFloating-point convert to unsigned integer, rounding …\nFloating-point convert to signed integer, rounding toward …\nFloating-point convert to unsigned integer, rounding …\nFloating-point convert to signed integer, rounding toward …\nFloating-point convert to signed integer, rounding toward …\nFloating-point convert to unsigned integer, rounding …\nFloating-point convert to unsigned integer, rounding …\nFloating-point convert to signed integer, rounding toward …\nFloating-point convert to unsigned integer, rounding …\nFloating-point convert to signed integer, rounding to …\nFloating-point convert to signed integer, rounding to …\nFloating-point convert to unsigned integer, rounding to …\nFloating-point convert to unsigned integer, rounding to …\nFloating-point convert to signed integer, rounding to …\nFloating-point convert to unsigned integer, rounding to …\nFloating-point convert to signed integer, rounding to …\nFloating-point convert to signed integer, rounding to …\nFloating-point convert to unsigned integer, rounding to …\nFloating-point convert to unsigned integer, rounding to …\nFloating-point convert to signed integer, rounding to …\nFloating-point convert to unsigned integer, rounding to …\nFloating-point convert to signed integer, rounding toward …\nFloating-point convert to signed integer, rounding toward …\nFloating-point convert to unsigned integer, rounding …\nFloating-point convert to unsigned integer, rounding …\nFloating-point convert to signed integer, rounding toward …\nFloating-point convert to unsigned integer, rounding …\nFloating-point convert to signed integer, rounding toward …\nFloating-point convert to signed integer, rounding toward …\nFloating-point convert to unsigned integer, rounding …\nFloating-point convert to unsigned integer, rounding …\nFloating-point convert to signed integer, rounding toward …\nFloating-point convert to unsigned integer, rounding …\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to signed fixed-point, rounding …\nFloating-point convert to signed fixed-point, rounding …\nFloating-point convert to unsigned fixed-point, rounding …\nFloating-point convert to unsigned fixed-point, rounding …\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to fixed-point, rounding toward zero\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFloating-point convert to lower precision narrow, rounding …\nFloating-point convert to lower precision narrow, rounding …\nFloating-point convert to lower precision narrow, rounding …\nDivide\nDivide\nDivide\nDivide\nDot product arithmetic (indexed)\nDot product arithmetic (indexed)\nDot product arithmetic (indexed)\nDot product arithmetic (indexed)\nDot product arithmetic (vector)\nDot product arithmetic (vector)\nDot product arithmetic (indexed)\nDot product arithmetic (indexed)\nDot product arithmetic (indexed)\nDot product arithmetic (indexed)\nDot product arithmetic (vector)\nDot product arithmetic (vector)\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nThree-way exclusive OR\nThree-way exclusive OR\nThree-way exclusive OR\nThree-way exclusive OR\nThree-way exclusive OR\nThree-way exclusive OR\nThree-way exclusive OR\nThree-way exclusive OR\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nFloating-point fused Multiply-Add to accumulator(vector)\nFloating-point fused Multiply-Add to accumulator(vector)\nFloating-point fused multiply-add to accumulator\nFloating-point fused multiply-add to accumulator\nFloating-point fused multiply-add to accumulator\nFloating-point fused multiply-add to accumulator\nFloating-point fused Multiply-Add to accumulator(vector)\nFloating-point fused Multiply-Add to accumulator(vector)\nFloating-point fused multiply-add to accumulator\nFloating-point fused multiply-add to accumulator\nFloating-point fused Multiply-Add to accumulator(vector)\nFloating-point fused Multiply-Add to accumulator(vector)\nFloating-point fused multiply-add to accumulator\nFloating-point fused multiply-add to accumulator\nFloating-point fused multiply-add to accumulator\nFloating-point fused multiply-add to accumulator\nFloating-point fused Multiply-Add to accumulator(vector)\nFloating-point fused Multiply-Add to accumulator(vector)\nFloating-point fused multiply-add to accumulator\nFloating-point fused multiply-add to accumulator\nFloating-point fused multiply-subtract from accumulator\nFloating-point fused multiply-subtract from accumulator\nFloating-point fused multiply-subtract to accumulator\nFloating-point fused multiply-subtract to accumulator\nFloating-point fused multiply-subtract to accumulator\nFloating-point fused multiply-subtract to accumulator\nFloating-point fused Multiply-subtract to …\nFloating-point fused Multiply-subtract to …\nFloating-point fused multiply-subtract to accumulator\nFloating-point fused multiply-subtract to accumulator\nFloating-point fused multiply-subtract from accumulator\nFloating-point fused multiply-subtract from accumulator\nFloating-point fused multiply-subtract to accumulator\nFloating-point fused multiply-subtract to accumulator\nFloating-point fused multiply-subtract to accumulator\nFloating-point fused multiply-subtract to accumulator\nFloating-point fused Multiply-subtract to …\nFloating-point fused Multiply-subtract to …\nFloating-point fused multiply-subtract to accumulator\nFloating-point fused multiply-subtract to accumulator\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nLoad one single-element structure and Replicate to all …\nLoad multiple single-element structures to one, two, …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad one single-element structure and Replicate to all …\nLoad multiple single-element structures to one, two, …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to two registers\nLoad multiple 3-element structures to two registers\nLoad multiple 3-element structures to two registers\nLoad multiple 3-element structures to two registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to two registers\nLoad multiple 3-element structures to two registers\nLoad multiple 3-element structures to two registers\nLoad multiple 3-element structures to two registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad SIMD&amp;FP register (immediate offset)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nFloating-point Maximum Number (vector)\nFloating-point Maximum Number (vector)\nFloating-point Maximum Number (vector)\nFloating-point Maximum Number (vector)\nFloating-point maximum number across vector\nFloating-point maximum number across vector\nFloating-point maximum number across vector\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nHorizontal vector max.\nHorizontal vector max.\nHorizontal vector max.\nHorizontal vector max.\nHorizontal vector max.\nHorizontal vector max.\nHorizontal vector max.\nHorizontal vector max.\nHorizontal vector max.\nHorizontal vector max.\nHorizontal vector max.\nHorizontal vector max.\nHorizontal vector max.\nHorizontal vector max.\nHorizontal vector max.\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nFloating-point Minimum Number (vector)\nFloating-point Minimum Number (vector)\nFloating-point Minimum Number (vector)\nFloating-point Minimum Number (vector)\nFloating-point minimum number across vector\nFloating-point minimum number across vector\nFloating-point minimum number across vector\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nHorizontal vector min.\nHorizontal vector min.\nHorizontal vector min.\nHorizontal vector min.\nHorizontal vector min.\nHorizontal vector min.\nHorizontal vector min.\nHorizontal vector min.\nHorizontal vector min.\nHorizontal vector min.\nHorizontal vector min.\nHorizontal vector min.\nHorizontal vector min.\nHorizontal vector min.\nHorizontal vector min.\nFloating-point multiply-add to accumulator\nFloating-point multiply-add to accumulator\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add long\nMultiply-add long\nMultiply-add long\nMultiply-add long\nMultiply-add long\nMultiply-add long\nMultiply-add long\nMultiply-add long\nMultiply-add long\nMultiply-add long\nMultiply-add long\nMultiply-add long\nSigned multiply-add long\nSigned multiply-add long\nSigned multiply-add long\nUnsigned multiply-add long\nUnsigned multiply-add long\nUnsigned multiply-add long\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nSigned multiply-add long\nSigned multiply-add long\nSigned multiply-add long\nUnsigned multiply-add long\nUnsigned multiply-add long\nUnsigned multiply-add long\nFloating-point multiply-add to accumulator\nFloating-point multiply-add to accumulator\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nFloating-point multiply-subtract from accumulator\nFloating-point multiply-subtract from accumulator\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract long\nMultiply-subtract long\nMultiply-subtract long\nMultiply-subtract long\nMultiply-subtract long\nMultiply-subtract long\nMultiply-subtract long\nMultiply-subtract long\nMultiply-subtract long\nMultiply-subtract long\nMultiply-subtract long\nMultiply-subtract long\nSigned multiply-subtract long\nSigned multiply-subtract long\nSigned multiply-subtract long\nUnsigned multiply-subtract long\nUnsigned multiply-subtract long\nUnsigned multiply-subtract long\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nSigned multiply-subtract long\nSigned multiply-subtract long\nSigned multiply-subtract long\nUnsigned multiply-subtract long\nUnsigned multiply-subtract long\nUnsigned multiply-subtract long\nFloating-point multiply-subtract from accumulator\nFloating-point multiply-subtract from accumulator\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\n8-bit integer matrix multiply-accumulate\n8-bit integer matrix multiply-accumulate\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nVector move\nVector move\nVector move\nVector move\nVector move\nVector move\nVector long move.\nVector long move.\nVector long move.\nVector long move.\nVector long move.\nVector long move.\nExtract narrow\nExtract narrow\nExtract narrow\nExtract narrow\nExtract narrow\nExtract narrow\nVector narrow integer.\nVector narrow integer.\nVector narrow integer.\nVector narrow integer.\nVector narrow integer.\nVector narrow integer.\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nMultiply\nMultiply\nFloating-point multiply\nFloating-point multiply\nMultiply\nMultiply\nMultiply\nMultiply\nFloating-point multiply\nFloating-point multiply\nMultiply\nMultiply\nMultiply\nMultiply\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nPolynomial multiply\nMultiply\nMultiply\nMultiply\nMultiply\nMultiply\nMultiply\nFloating-point multiply\nFloating-point multiply\nMultiply long\nMultiply long\nMultiply long\nMultiply long\nMultiply long\nMultiply long\nMultiply long\nMultiply long\nMultiply long\nMultiply long\nMultiply long\nMultiply long\nPolynomial multiply long\nPolynomial multiply long\nSigned multiply long\nSigned multiply long\nSigned multiply long\nUnsigned multiply long\nUnsigned multiply long\nUnsigned multiply long\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply with scalar\nVector long multiply with scalar\nVector long multiply with scalar\nVector long multiply with scalar\nPolynomial multiply long\nPolynomial multiply long\nSigned multiply long\nSigned multiply long\nSigned multiply long\nUnsigned multiply long\nUnsigned multiply long\nUnsigned multiply long\nMultiply\nMultiply\nFloating-point multiply\nFloating-point multiply\nMultiply\nMultiply\nMultiply\nMultiply\nFloating-point multiply\nFloating-point multiply\nMultiply\nMultiply\nMultiply\nMultiply\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nPolynomial multiply\nMultiply\nMultiply\nMultiply\nMultiply\nMultiply\nMultiply\nFloating-point multiply\nFloating-point multiply\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nFloating-point multiply extended\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nNegate\nNegate\nNegate\nNegate\nNegate\nNegate\nNegate\nNegate\nNegate\nNegate\nNegate\nNegate\nNegate\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nSigned Add and Accumulate Long Pairwise.\nSigned Add and Accumulate Long Pairwise.\nSigned Add and Accumulate Long Pairwise.\nUnsigned Add and Accumulate Long Pairwise.\nUnsigned Add and Accumulate Long Pairwise.\nUnsigned Add and Accumulate Long Pairwise.\nSigned Add and Accumulate Long Pairwise.\nSigned Add and Accumulate Long Pairwise.\nSigned Add and Accumulate Long Pairwise.\nUnsigned Add and Accumulate Long Pairwise.\nUnsigned Add and Accumulate Long Pairwise.\nUnsigned Add and Accumulate Long Pairwise.\nFloating-point add pairwise\nAdd pairwise.\nAdd pairwise.\nAdd pairwise.\nAdd pairwise.\nAdd pairwise.\nAdd pairwise.\nFloating-point add pairwise\nAdd pairwise\nAdd pairwise\nSigned Add Long Pairwise.\nSigned Add Long Pairwise.\nSigned Add Long Pairwise.\nUnsigned Add Long Pairwise.\nUnsigned Add Long Pairwise.\nUnsigned Add Long Pairwise.\nSigned Add Long Pairwise.\nSigned Add Long Pairwise.\nSigned Add Long Pairwise.\nUnsigned Add Long Pairwise.\nUnsigned Add Long Pairwise.\nUnsigned Add Long Pairwise.\nFloating-point add pairwise\nFloating-point add pairwise\nAdd pairwise\nAdd pairwise\nAdd pairwise\nAdd pairwise\nAdd pairwise\nAdd pairwise\nAdd pairwise\nAdd pairwise\nFloating-point add pairwise\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFloating-point Maximum Number Pairwise (vector).\nFloating-point Maximum Number Pairwise (vector).\nFloating-point Maximum Number Pairwise (vector).\nFloating-point maximum number pairwise\nFloating-point maximum number pairwise\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFloating-point maximum pairwise\nFloating-point maximum pairwise\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFloating-point Minimum Number Pairwise (vector).\nFloating-point Minimum Number Pairwise (vector).\nFloating-point Minimum Number Pairwise (vector).\nFloating-point minimum number pairwise\nFloating-point minimum number pairwise\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFloating-point minimum pairwise\nFloating-point minimum pairwise\nSigned saturating Absolute value\nSigned saturating Absolute value\nSigned saturating Absolute value\nSigned saturating Absolute value\nSigned saturating absolute value\nSigned saturating absolute value\nSigned saturating absolute value\nSigned saturating Absolute value\nSigned saturating Absolute value\nSigned saturating Absolute value\nSigned saturating Absolute value\nSigned saturating absolute value\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nVector widening saturating doubling multiply accumulate …\nVector widening saturating doubling multiply accumulate …\nVector widening saturating doubling multiply accumulate …\nVector widening saturating doubling multiply accumulate …\nVector widening saturating doubling multiply accumulate …\nVector widening saturating doubling multiply accumulate …\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nVector widening saturating doubling multiply subtract with …\nVector widening saturating doubling multiply subtract with …\nVector widening saturating doubling multiply subtract with …\nVector widening saturating doubling multiply subtract with …\nVector widening saturating doubling multiply subtract with …\nVector widening saturating doubling multiply subtract with …\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nVector saturating doubling multiply high by scalar\nVector saturating doubling multiply high by scalar\nVector saturating doubling multiply high by scalar\nVector saturating doubling multiply high by scalar\nVector saturating doubling multiply high with scalar\nVector saturating doubling multiply high with scalar\nSigned saturating doubling multiply returning high half\nSigned saturating doubling multiply returning high half\nSigned saturating doubling multiply returning high half\nSigned saturating doubling multiply returning high half\nSigned saturating doubling multiply returning high half\nVector saturating doubling multiply high by scalar\nVector saturating doubling multiply high by scalar\nVector saturating doubling multiply high by scalar\nVector saturating doubling multiply high by scalar\nVector saturating doubling multiply high with scalar\nVector saturating doubling multiply high with scalar\nSigned saturating doubling multiply returning high half\nSigned saturating doubling multiply returning high half\nSigned saturating doubling multiply returning high half\nSigned saturating doubling multiply returning high half\nSigned saturating doubling multiply returning high half\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nVector saturating doubling long multiply by scalar\nVector saturating doubling long multiply by scalar\nVector saturating doubling long multiply by scalar\nVector saturating doubling long multiply by scalar\nVector saturating doubling long multiply with scalar\nVector saturating doubling long multiply with scalar\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating extract narrow\nSigned saturating extract narrow\nSigned saturating extract narrow\nSigned saturating extract narrow\nSigned saturating extract narrow\nSigned saturating extract narrow\nSigned saturating extract narrow\nSigned saturating extract narrow\nSigned saturating extract narrow\nUnsigned saturating extract narrow\nUnsigned saturating extract narrow\nUnsigned saturating extract narrow\nSaturating extract narrow\nSaturating extract narrow\nSaturating extract narrow\nSaturating extract narrow\nSaturating extract narrow\nSaturating extract narrow\nSigned saturating extract unsigned narrow\nSigned saturating extract unsigned narrow\nSigned saturating extract unsigned narrow\nSigned saturating extract unsigned narrow\nSigned saturating extract unsigned narrow\nSigned saturating extract unsigned narrow\nSigned saturating extract unsigned narrow\nSigned saturating extract unsigned narrow\nSigned saturating extract unsigned narrow\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply accumulate …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nSigned saturating rounding doubling multiply subtract …\nVector rounding saturating doubling multiply high by scalar\nVector rounding saturating doubling multiply high by scalar\nVector rounding saturating doubling multiply high by scalar\nVector rounding saturating doubling multiply high by scalar\nVector saturating rounding doubling multiply high with …\nVector saturating rounding doubling multiply high with …\nSigned saturating rounding doubling multiply returning …\nSigned saturating rounding doubling multiply returning …\nSigned saturating rounding doubling multiply returning …\nSigned saturating rounding doubling multiply returning …\nSigned saturating rounding doubling multiply returning …\nVector rounding saturating doubling multiply high by scalar\nVector rounding saturating doubling multiply high by scalar\nVector rounding saturating doubling multiply high by scalar\nVector rounding saturating doubling multiply high by scalar\nVector saturating rounding doubling multiply high with …\nVector saturating rounding doubling multiply high with …\nSigned saturating rounding doubling multiply returning …\nSigned saturating rounding doubling multiply returning …\nSigned saturating rounding doubling multiply returning …\nSigned saturating rounding doubling multiply returning …\nSigned saturating rounding doubling multiply returning …\nSigned saturating rounding shift left\nSigned saturating rounding shift left\nSigned saturating rounding shift left\nSigned saturating rounding shift left\nUnsigned signed saturating rounding shift left\nUnsigned signed saturating rounding shift left\nUnsigned signed saturating rounding shift left\nUnsigned signed saturating rounding shift left\nSigned saturating rounding shift left\nUnsigned signed saturating rounding shift left\nSigned saturating rounding shift left\nUnsigned signed saturating rounding shift left\nSigned saturating rounding shift left\nUnsigned signed saturating rounding shift left\nSigned saturating rounding shift left\nSigned saturating rounding shift left\nSigned saturating rounding shift left\nSigned saturating rounding shift left\nUnsigned signed saturating rounding shift left\nUnsigned signed saturating rounding shift left\nUnsigned signed saturating rounding shift left\nUnsigned signed saturating rounding shift left\nSigned saturating rounding shift left\nUnsigned signed saturating rounding shift left\nSigned saturating rounded shift right narrow\nSigned saturating rounded shift right narrow\nSigned saturating rounded shift right narrow\nUnsigned saturating rounded shift right narrow\nUnsigned saturating rounded shift right narrow\nUnsigned saturating rounded shift right narrow\nSigned saturating rounded shift right narrow\nSigned saturating rounded shift right narrow\nSigned saturating rounded shift right narrow\nUnsigned signed saturating rounded shift right narrow\nUnsigned signed saturating rounded shift right narrow\nUnsigned signed saturating rounded shift right narrow\nSigned saturating rounded shift right narrow\nUnsigned saturating rounded shift right narrow\nSigned saturating rounded shift right narrow\nUnsigned saturating rounded shift right narrow\nSigned saturating rounded shift right narrow\nUnsigned saturating rounded shift right narrow\nSigned saturating rounded shift right unsigned narrow\nSigned saturating rounded shift right unsigned narrow\nSigned saturating rounded shift right unsigned narrow\nSigned saturating rounded shift right unsigned narrow\nSigned saturating rounded shift right unsigned narrow\nSigned saturating rounded shift right unsigned narrow\nSigned saturating rounded shift right unsigned narrow\nSigned saturating rounded shift right unsigned narrow\nSigned saturating rounded shift right unsigned narrow\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift right narrow\nSigned saturating shift right narrow\nSigned saturating shift right narrow\nUnsigned saturating shift right narrow\nUnsigned saturating shift right narrow\nUnsigned saturating shift right narrow\nSigned saturating shift right narrow\nSigned saturating shift right narrow\nSigned saturating shift right narrow\nUnsigned saturating shift right narrow\nUnsigned saturating shift right narrow\nUnsigned saturating shift right narrow\nSigned saturating shift right narrow\nUnsigned saturating shift right narrow\nSigned saturating shift right narrow\nUnsigned saturating shift right narrow\nSigned saturating shift right narrow\nUnsigned saturating shift right narrow\nSigned saturating shift right unsigned narrow\nSigned saturating shift right unsigned narrow\nSigned saturating shift right unsigned narrow\nSigned saturating shift right unsigned narrow\nSigned saturating shift right unsigned narrow\nSigned saturating shift right unsigned narrow\nSigned saturating shift right unsigned narrow\nSigned saturating shift right unsigned narrow\nSigned saturating shift right unsigned narrow\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nRounding Add returning High Narrow (high half).\nRounding Add returning High Narrow (high half).\nRounding Add returning High Narrow (high half).\nRounding Add returning High Narrow (high half).\nRounding Add returning High Narrow (high half).\nRounding Add returning High Narrow (high half).\nRounding Add returning High Narrow.\nRounding Add returning High Narrow.\nRounding Add returning High Narrow.\nRounding Add returning High Narrow.\nRounding Add returning High Narrow.\nRounding Add returning High Narrow.\nRotate and exclusive OR\nReverse bit order\nReverse bit order\nReverse bit order\nReverse bit order\nReverse bit order\nReverse bit order\nReciprocal estimate.\nReciprocal estimate.\nUnsigned reciprocal estimate\nReciprocal estimate.\nReciprocal estimate.\nReciprocal estimate.\nUnsigned reciprocal estimate\nReciprocal estimate.\nFloating-point reciprocal step\nFloating-point reciprocal step\nFloating-point reciprocal step\nFloating-point reciprocal step\nFloating-point reciprocal step\nFloating-point reciprocal step\nFloating-point reciprocal exponent\nFloating-point reciprocal exponent\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nFloating-point round to 32-bit integer, using current …\nFloating-point round to 32-bit integer, using current …\nFloating-point round to 32-bit integer, using current …\nFloating-point round to 32-bit integer, using current …\nFloating-point round to 32-bit integer toward zero\nFloating-point round to 32-bit integer toward zero\nFloating-point round to 32-bit integer toward zero\nFloating-point round to 32-bit integer toward zero\nFloating-point round to 64-bit integer, using current …\nFloating-point round to 64-bit integer, using current …\nFloating-point round to 64-bit integer, using current …\nFloating-point round to 64-bit integer, using current …\nFloating-point round to 64-bit integer toward zero\nFloating-point round to 64-bit integer toward zero\nFloating-point round to 64-bit integer toward zero\nFloating-point round to 64-bit integer toward zero\nFloating-point round to integral, toward zero\nFloating-point round to integral, toward zero\nFloating-point round to integral, to nearest with ties to …\nFloating-point round to integral, to nearest with ties to …\nFloating-point round to integral, to nearest with ties to …\nFloating-point round to integral, to nearest with ties to …\nFloating-point round to integral, using current rounding …\nFloating-point round to integral, using current rounding …\nFloating-point round to integral, using current rounding …\nFloating-point round to integral, using current rounding …\nFloating-point round to integral, toward minus infinity\nFloating-point round to integral, toward minus infinity\nFloating-point round to integral, toward minus infinity\nFloating-point round to integral, toward minus infinity\nFloating-point round to integral, to nearest with ties to …\nFloating-point round to integral, to nearest with ties to …\nFloating-point round to integral, to nearest with ties to …\nFloating-point round to integral, to nearest with ties to …\nFloating-point round to integral, to nearest with ties to …\nFloating-point round to integral, toward plus infinity\nFloating-point round to integral, toward plus infinity\nFloating-point round to integral, toward plus infinity\nFloating-point round to integral, toward plus infinity\nFloating-point round to integral, toward zero\nFloating-point round to integral, toward zero\nFloating-point round to integral exact, using current …\nFloating-point round to integral exact, using current …\nFloating-point round to integral exact, using current …\nFloating-point round to integral exact, using current …\nSigned rounding shift left\nSigned rounding shift left\nSigned rounding shift left\nSigned rounding shift left\nUnsigned rounding shift left\nUnsigned rounding shift left\nUnsigned rounding shift left\nUnsigned rounding shift left\nSigned rounding shift left\nUnsigned rounding shift left\nSigned rounding shift left\nSigned rounding shift left\nSigned rounding shift left\nSigned rounding shift left\nUnsigned rounding shift left\nUnsigned rounding shift left\nUnsigned rounding shift left\nUnsigned rounding shift left\nSigned rounding shift right\nSigned rounding shift right\nSigned rounding shift right\nSigned rounding shift right\nUnsigned rounding shift right\nUnsigned rounding shift right\nUnsigned rounding shift right\nUnsigned rounding shift right\nSigned rounding shift right\nUnsigned rounding shift right\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nSigned rounding shift right\nSigned rounding shift right\nSigned rounding shift right\nSigned rounding shift right\nUnsigned rounding shift right\nUnsigned rounding shift right\nUnsigned rounding shift right\nUnsigned rounding shift right\nReciprocal square-root estimate.\nReciprocal square-root estimate.\nUnsigned reciprocal square root estimate\nReciprocal square-root estimate.\nReciprocal square-root estimate.\nReciprocal square-root estimate.\nUnsigned reciprocal square root estimate\nReciprocal square-root estimate.\nFloating-point reciprocal square root step\nFloating-point reciprocal square root step\nFloating-point reciprocal square root step\nFloating-point reciprocal square root step\nFloating-point reciprocal square root step\nFloating-point reciprocal square root step\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nSigned rounding shift right and accumulate.\nUnsigned rounding shift right and accumulate.\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nSHA1 hash update accelerator, choose.\nSHA1 fixed rotate.\nSHA1 hash update accelerator, majority.\nSHA1 hash update accelerator, parity.\nSHA1 schedule update accelerator, first part.\nSHA1 schedule update accelerator, second part.\nSHA256 hash update accelerator, upper part.\nSHA256 hash update accelerator.\nSHA256 schedule update accelerator, first part.\nSHA256 schedule update accelerator, second part.\nSHA512 hash update part 2\nSHA512 hash update part 1\nSHA512 schedule update 0\nSHA512 schedule update 1\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nSigned Shift left\nSigned Shift left\nSigned Shift left\nSigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nShift left\nShift left\nSigned Shift left\nUnsigned Shift left\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nSigned Shift left\nSigned Shift left\nSigned Shift left\nSigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nSigned shift right\nUnsigned shift right\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift left and insert\nShift left and insert\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nSM3PARTW1\nSM3PARTW2\nSM3SS1\nSM3TT1A\nSM3TT1B\nSM3TT2A\nSM3TT2B\nSM4 key\nSM4 encode\nUnsigned saturating Accumulate of Signed value.\nUnsigned saturating Accumulate of Signed value.\nUnsigned saturating Accumulate of Signed value.\nUnsigned saturating Accumulate of Signed value.\nUnsigned saturating accumulate of signed value\nUnsigned saturating accumulate of signed value\nUnsigned saturating accumulate of signed value\nUnsigned saturating Accumulate of Signed value.\nUnsigned saturating Accumulate of Signed value.\nUnsigned saturating Accumulate of Signed value.\nUnsigned saturating Accumulate of Signed value.\nUnsigned saturating accumulate of signed value\nCalculates the square root of each lane.\nCalculates the square root of each lane.\nCalculates the square root of each lane.\nCalculates the square root of each lane.\nSigned shift right and accumulate\nSigned shift right and accumulate\nSigned shift right and accumulate\nSigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nSigned shift right and accumulate\nUnsigned shift right and accumulate\nSigned shift right and accumulate\nSigned shift right and accumulate\nSigned shift right and accumulate\nSigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift right and insert\nShift right and insert\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\n\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\n\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nArm’s documentation\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\n\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\n\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nArm’s documentation\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore SIMD&amp;FP register (immediate offset)\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSigned Subtract Long\nSigned Subtract Long\nSigned Subtract Long\nUnsigned Subtract Long\nUnsigned Subtract Long\nUnsigned Subtract Long\nSigned Subtract Long\nSigned Subtract Long\nSigned Subtract Long\nUnsigned Subtract Long\nUnsigned Subtract Long\nUnsigned Subtract Long\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSigned Subtract Wide\nSigned Subtract Wide\nSigned Subtract Wide\nUnsigned Subtract Wide\nUnsigned Subtract Wide\nUnsigned Subtract Wide\nSigned Subtract Wide\nSigned Subtract Wide\nSigned Subtract Wide\nUnsigned Subtract Wide\nUnsigned Subtract Wide\nUnsigned Subtract Wide\nDot product index form with signed and unsigned integers\nDot product index form with signed and unsigned integers\nDot product index form with signed and unsigned integers\nDot product index form with signed and unsigned integers\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose vectors\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nCompare bitwise test bits nonzero\nCompare bitwise test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nSigned saturating Accumulate of Unsigned value.\nSigned saturating Accumulate of Unsigned value.\nSigned saturating Accumulate of Unsigned value.\nSigned saturating Accumulate of Unsigned value.\nSigned saturating accumulate of unsigned value\nSigned saturating accumulate of unsigned value\nSigned saturating accumulate of unsigned value\nSigned saturating Accumulate of Unsigned value.\nSigned saturating Accumulate of Unsigned value.\nSigned saturating Accumulate of Unsigned value.\nSigned saturating Accumulate of Unsigned value.\nSigned saturating accumulate of unsigned value\nDot product index form with unsigned and signed integers\nDot product index form with unsigned and signed integers\nDot product vector form with unsigned and signed integers\nDot product index form with unsigned and signed integers\nDot product index form with unsigned and signed integers\nDot product vector form with unsigned and signed integers\nUnsigned and signed 8-bit integer matrix …\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nExclusive OR and rotate\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nFull system is the required shareability domain, reads and …\nCRC32 single round checksum for bytes (8 bits).\nCRC32-C single round checksum for bytes (8 bits).\nCRC32-C single round checksum for half words (16 bits).\nCRC32-C single round checksum for words (32 bits).\nCRC32 single round checksum for half words (16 bits).\nCRC32 single round checksum for words (32 bits).\nGenerates a DBG instruction.\nGenerates a DMB (data memory barrier) instruction or …\nGenerates a DSB (data synchronization barrier) instruction …\nGenerates an ISB (instruction synchronization barrier) …\nGenerates an unspecified no-op instruction.\nSigned saturating addition\nSaturating two 16-bit integer additions\nSaturating four 8-bit integer additions\nReturns the 16-bit signed saturated equivalent of\nInsert a QADD instruction\nReturns the 16-bit signed saturated equivalent of\nSigned saturating subtraction\nSaturating two 16-bit integer subtraction\nSaturating two 8-bit integer subtraction\nReturns the 16-bit signed saturated equivalent of\nReturns the 8-bit signed saturated equivalent of\nReturns the 16-bit signed equivalent of\nSelect bytes from each operand according to APSR GE flags\nGenerates a SEV (send a global event) hint instruction.\nGenerates a send a local event hint instruction.\nSigned halving parallel halfword-wise addition.\nSigned halving parallel byte-wise addition.\nSigned halving parallel halfword-wise subtraction.\nSigned halving parallel byte-wise subtraction.\nInsert a SMLABB instruction\nInsert a SMLABT instruction\nDual 16-bit Signed Multiply with Addition of products and …\nInsert a SMLATB instruction\nInsert a SMLATT instruction\nInsert a SMLAWB instruction\nInsert a SMLAWT instruction\nDual 16-bit Signed Multiply with Subtraction  of products …\nSigned Dual Multiply Add.\nSigned Dual Multiply Add Reversed.\nInsert a SMULBB instruction\nInsert a SMULTB instruction\nInsert a SMULTB instruction\nInsert a SMULTT instruction\nInsert a SMULWB instruction\nInsert a SMULWT instruction\nSigned Dual Multiply Subtract.\nSigned Dual Multiply Subtract Reversed.\nInserts a <code>SSUB8</code> instruction.\nSum of 8-bit absolute differences.\nSum of 8-bit absolute differences and constant.\nInserts a <code>USUB8</code> instruction.\nGenerates a WFE (wait for event) hint instruction, or …\nGenerates a WFI (wait for interrupt) hint instruction, or …\nGenerates a YIELD hint instruction.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReferences:\nARM-specific 64-bit wide vector of two packed <code>f32</code>.\nARM-specific type containing two <code>float32x2_t</code> vectors.\nARM-specific type containing three <code>float32x2_t</code> vectors.\nARM-specific type containing four <code>float32x2_t</code> vectors.\nARM-specific 128-bit wide vector of four packed <code>f32</code>.\nARM-specific type containing two <code>float32x4_t</code> vectors.\nARM-specific type containing three <code>float32x4_t</code> vectors.\nARM-specific type containing four <code>float32x4_t</code> vectors.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nARM-specific 32-bit wide vector of two packed <code>i16</code>.\nARM-specific 64-bit wide vector of four packed <code>i16</code>.\nARM-specific type containing two <code>int16x4_t</code> vectors.\nARM-specific type containing three <code>int16x4_t</code> vectors.\nARM-specific type containing four <code>int16x4_t</code> vectors.\nARM-specific 128-bit wide vector of eight packed <code>i16</code>.\nARM-specific type containing two <code>int16x8_t</code> vectors.\nARM-specific type containing three <code>int16x8_t</code> vectors.\nARM-specific type containing four <code>int16x8_t</code> vectors.\nARM-specific 64-bit wide vector of two packed <code>i32</code>.\nARM-specific type containing two <code>int32x2_t</code> vectors.\nARM-specific type containing three <code>int32x2_t</code> vectors.\nARM-specific type containing four <code>int32x2_t</code> vectors.\nARM-specific 128-bit wide vector of four packed <code>i32</code>.\nARM-specific type containing two <code>int32x4_t</code> vectors.\nARM-specific type containing three <code>int32x4_t</code> vectors.\nARM-specific type containing four <code>int32x4_t</code> vectors.\nARM-specific 64-bit wide vector of one packed <code>i64</code>.\nARM-specific type containing four <code>int64x1_t</code> vectors.\nARM-specific type containing four <code>int64x1_t</code> vectors.\nARM-specific type containing four <code>int64x1_t</code> vectors.\nARM-specific 128-bit wide vector of two packed <code>i64</code>.\nARM-specific type containing four <code>int64x2_t</code> vectors.\nARM-specific type containing four <code>int64x2_t</code> vectors.\nARM-specific type containing four <code>int64x2_t</code> vectors.\nARM-specific 128-bit wide vector of sixteen packed <code>i8</code>.\nARM-specific type containing two <code>int8x16_t</code> vectors.\nARM-specific type containing three <code>int8x16_t</code> vectors.\nARM-specific type containing four <code>int8x16_t</code> vectors.\nARM-specific 32-bit wide vector of four packed <code>i8</code>.\nARM-specific 64-bit wide vector of eight packed <code>i8</code>.\nARM-specific type containing two <code>int8x8_t</code> vectors.\nARM-specific type containing three <code>int8x8_t</code> vectors.\nARM-specific type containing four <code>int8x8_t</code> vectors.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nARM-specific 64-bit wide vector of four packed <code>p16</code>.\nARM-specific type containing two <code>poly16x4_t</code> vectors.\nARM-specific type containing three <code>poly16x4_t</code> vectors.\nARM-specific type containing four <code>poly16x4_t</code> vectors.\nARM-specific 128-bit wide vector of eight packed <code>p16</code>.\nARM-specific type containing two <code>poly16x8_t</code> vectors.\nARM-specific type containing three <code>poly16x8_t</code> vectors.\nARM-specific type containing four <code>poly16x8_t</code> vectors.\nARM-specific 64-bit wide vector of one packed <code>p64</code>.\nARM-specific type containing four <code>poly64x1_t</code> vectors.\nARM-specific type containing four <code>poly64x1_t</code> vectors.\nARM-specific type containing four <code>poly64x1_t</code> vectors.\nARM-specific 128-bit wide vector of two packed <code>p64</code>.\nARM-specific type containing four <code>poly64x2_t</code> vectors.\nARM-specific type containing four <code>poly64x2_t</code> vectors.\nARM-specific type containing four <code>poly64x2_t</code> vectors.\nARM-specific 128-bit wide vector of sixteen packed <code>p8</code>.\nARM-specific type containing two <code>poly8x16_t</code> vectors.\nARM-specific type containing three <code>poly8x16_t</code> vectors.\nARM-specific type containing four <code>poly8x16_t</code> vectors.\nARM-specific 64-bit wide polynomial vector of eight packed …\nARM-specific type containing two <code>poly8x8_t</code> vectors.\nARM-specific type containing three <code>poly8x8_t</code> vectors.\nARM-specific type containing four <code>poly8x8_t</code> vectors.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nARM-specific 32-bit wide vector of two packed <code>u16</code>.\nARM-specific 64-bit wide vector of four packed <code>u16</code>.\nARM-specific type containing two <code>uint16x4_t</code> vectors.\nARM-specific type containing three <code>uint16x4_t</code> vectors.\nARM-specific type containing four <code>uint16x4_t</code> vectors.\nARM-specific 128-bit wide vector of eight packed <code>u16</code>.\nARM-specific type containing two <code>uint16x8_t</code> vectors.\nARM-specific type containing three <code>uint16x8_t</code> vectors.\nARM-specific type containing four <code>uint16x8_t</code> vectors.\nARM-specific 64-bit wide vector of two packed <code>u32</code>.\nARM-specific type containing two <code>uint32x2_t</code> vectors.\nARM-specific type containing three <code>uint32x2_t</code> vectors.\nARM-specific type containing four <code>uint32x2_t</code> vectors.\nARM-specific 128-bit wide vector of four packed <code>u32</code>.\nARM-specific type containing two <code>uint32x4_t</code> vectors.\nARM-specific type containing three <code>uint32x4_t</code> vectors.\nARM-specific type containing four <code>uint32x4_t</code> vectors.\nARM-specific 64-bit wide vector of one packed <code>u64</code>.\nARM-specific type containing four <code>uint64x1_t</code> vectors.\nARM-specific type containing four <code>uint64x1_t</code> vectors.\nARM-specific type containing four <code>uint64x1_t</code> vectors.\nARM-specific 128-bit wide vector of two packed <code>u64</code>.\nARM-specific type containing four <code>uint64x2_t</code> vectors.\nARM-specific type containing four <code>uint64x2_t</code> vectors.\nARM-specific type containing four <code>uint64x2_t</code> vectors.\nARM-specific 128-bit wide vector of sixteen packed <code>u8</code>.\nARM-specific type containing two <code>uint8x16_t</code> vectors.\nARM-specific type containing three <code>uint8x16_t</code> vectors.\nARM-specific type containing four <code>uint8x16_t</code> vectors.\nARM-specific 32-bit wide vector of four packed <code>u8</code>.\nARM-specific 64-bit wide vector of eight packed <code>u8</code>.\nARM-specific type containing two <code>uint8x8_t</code> vectors.\nARM-specific type containing three <code>uint8x8_t</code> vectors.\nARM-specific type containing four <code>uint8x8_t</code> vectors.\n\n\n\n\n\n\nSigned Absolute difference and Accumulate Long\nSigned Absolute difference and Accumulate Long\nSigned Absolute difference and Accumulate Long\nUnsigned Absolute difference and Accumulate Long\nUnsigned Absolute difference and Accumulate Long\nUnsigned Absolute difference and Accumulate Long\n\n\n\n\n\n\nAbsolute difference between the arguments of Floating\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nSigned Absolute difference Long\nSigned Absolute difference Long\nSigned Absolute difference Long\nUnsigned Absolute difference Long\nUnsigned Absolute difference Long\nUnsigned Absolute difference Long\nAbsolute difference between the arguments of Floating\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nAbsolute difference between the arguments\nFloating-point absolute value\nAbsolute value (wrapping).\nAbsolute value (wrapping).\nAbsolute value (wrapping).\nFloating-point absolute value\nAbsolute value (wrapping).\nAbsolute value (wrapping).\nAbsolute value (wrapping).\nVector add.\nBitwise exclusive OR\nBitwise exclusive OR\nBitwise exclusive OR\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nAdd returning High Narrow (high half).\nAdd returning High Narrow (high half).\nAdd returning High Narrow (high half).\nAdd returning High Narrow (high half).\nAdd returning High Narrow (high half).\nAdd returning High Narrow (high half).\nAdd returning High Narrow.\nAdd returning High Narrow.\nAdd returning High Narrow.\nAdd returning High Narrow.\nAdd returning High Narrow.\nAdd returning High Narrow.\nSigned Add Long (vector, high half).\nSigned Add Long (vector, high half).\nSigned Add Long (vector, high half).\nUnsigned Add Long (vector, high half).\nUnsigned Add Long (vector, high half).\nUnsigned Add Long (vector, high half).\nSigned Add Long (vector).\nSigned Add Long (vector).\nSigned Add Long (vector).\nUnsigned Add Long (vector).\nUnsigned Add Long (vector).\nUnsigned Add Long (vector).\nVector add.\nBitwise exclusive OR\nBitwise exclusive OR\nBitwise exclusive OR\nBitwise exclusive OR\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nVector add.\nSigned Add Wide (high half).\nSigned Add Wide (high half).\nSigned Add Wide (high half).\nUnsigned Add Wide (high half).\nUnsigned Add Wide (high half).\nUnsigned Add Wide (high half).\nSigned Add Wide.\nSigned Add Wide.\nSigned Add Wide.\nUnsigned Add Wide.\nUnsigned Add Wide.\nUnsigned Add Wide.\nAES single round decryption.\nAES single round encryption.\nAES inverse mix columns.\nAES mix columns.\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise and\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nVector bitwise bit clear\nBitwise Select.\nBitwise Select.\nBitwise Select.\nBitwise Select.\nBitwise Select.\nBitwise Select.\nBitwise Select instructions. This instruction sets each …\nBitwise Select.\nBitwise Select.\nBitwise Select.\nBitwise Select.\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nBitwise Select. (128-bit)\nFloating-point absolute compare greater than or equal\nFloating-point absolute compare greater than or equal\nFloating-point absolute compare greater than\nFloating-point absolute compare greater than\nFloating-point absolute compare less than or equal\nFloating-point absolute compare less than or equal\nFloating-point absolute compare less than\nFloating-point absolute compare less than\nFloating-point compare equal\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nFloating-point compare equal\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nCompare bitwise Equal (vector)\nFloating-point compare greater than or equal\nCompare signed greater than or equal\nCompare signed greater than or equal\nCompare signed greater than or equal\nCompare unsigned greater than or equal\nCompare unsigned greater than or equal\nCompare unsigned greater than or equal\nFloating-point compare greater than or equal\nCompare signed greater than or equal\nCompare signed greater than or equal\nCompare signed greater than or equal\nCompare unsigned greater than or equal\nCompare unsigned greater than or equal\nCompare unsigned greater than or equal\nFloating-point compare greater than\nCompare signed greater than\nCompare signed greater than\nCompare signed greater than\nCompare unsigned greater than\nCompare unsigned greater than\nCompare unsigned greater than\nFloating-point compare greater than\nCompare signed greater than\nCompare signed greater than\nCompare signed greater than\nCompare unsigned greater than\nCompare unsigned greater than\nCompare unsigned greater than\nFloating-point compare less than or equal\nCompare signed less than or equal\nCompare signed less than or equal\nCompare signed less than or equal\nCompare unsigned less than or equal\nCompare unsigned less than or equal\nCompare unsigned less than or equal\nFloating-point compare less than or equal\nCompare signed less than or equal\nCompare signed less than or equal\nCompare signed less than or equal\nCompare unsigned less than or equal\nCompare unsigned less than or equal\nCompare unsigned less than or equal\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nCount leading sign bits\nFloating-point compare less than\nCompare signed less than\nCompare signed less than\nCompare signed less than\nCompare unsigned less than\nCompare unsigned less than\nCompare unsigned less than\nFloating-point compare less than\nCompare signed less than\nCompare signed less than\nCompare signed less than\nCompare unsigned less than\nCompare unsigned less than\nCompare unsigned less than\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nCount leading zero bits\nPopulation count per byte.\nPopulation count per byte.\nPopulation count per byte.\nPopulation count per byte.\nPopulation count per byte.\nPopulation count per byte.\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nVector combine\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to signed fixed-point, rounding …\nFloating-point convert to unsigned fixed-point, rounding …\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFixed-point convert to floating-point\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to fixed-point, rounding toward zero\nFloating-point convert to signed fixed-point, rounding …\nFloating-point convert to unsigned fixed-point, rounding …\nDot product arithmetic (indexed)\nDot product arithmetic (indexed)\nDot product arithmetic (vector)\nDot product arithmetic (vector)\nDot product arithmetic (indexed)\nDot product arithmetic (indexed)\nDot product arithmetic (vector)\nDot product arithmetic (vector)\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nSet all vector lanes to the same value\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nVector bitwise exclusive or (vector)\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nExtract vector from pair of vectors\nFloating-point fused Multiply-Add to accumulator(vector)\nFloating-point fused Multiply-Add to accumulator(vector)\nFloating-point fused Multiply-Add to accumulator(vector)\nFloating-point fused Multiply-Add to accumulator(vector)\nFloating-point fused multiply-subtract from accumulator\nFloating-point fused Multiply-subtract to …\nFloating-point fused multiply-subtract from accumulator\nFloating-point fused Multiply-subtract to …\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nMove vector element to general-purpose register\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nHalving add\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nSigned halving subtract\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad one single-element structure and Replicate to all …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad one single-element structure to one lane of one …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad multiple single-element structures to one, two, …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad single 2-element structure and replicate to all lanes …\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad multiple 2-element structures to two registers\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to two registers\nLoad multiple 3-element structures to two registers\nLoad multiple 3-element structures to two registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad single 3-element structure and replicate to all lanes …\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to two registers\nLoad multiple 3-element structures to two registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad multiple 3-element structures to three registers\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad single 4-element structure and replicate to all lanes …\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad multiple 4-element structures to four registers\nLoad SIMD&amp;FP register (immediate offset)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nFloating-point Maximum Number (vector)\nFloating-point Maximum Number (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMaximum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nFloating-point Minimum Number (vector)\nFloating-point Minimum Number (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nMinimum (vector)\nFloating-point multiply-add to accumulator\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nVector widening multiply accumulate with scalar\nSigned multiply-add long\nSigned multiply-add long\nSigned multiply-add long\nUnsigned multiply-add long\nUnsigned multiply-add long\nUnsigned multiply-add long\nFloating-point multiply-add to accumulator\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nVector multiply accumulate with scalar\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nMultiply-add to accumulator\nFloating-point multiply-subtract from accumulator\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nVector widening multiply subtract with scalar\nSigned multiply-subtract long\nSigned multiply-subtract long\nSigned multiply-subtract long\nUnsigned multiply-subtract long\nUnsigned multiply-subtract long\nUnsigned multiply-subtract long\nFloating-point multiply-subtract from accumulator\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nVector multiply subtract with scalar\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\nMultiply-subtract from accumulator\n8-bit integer matrix multiply-accumulate\n8-bit integer matrix multiply-accumulate\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nVector long move.\nVector long move.\nVector long move.\nVector long move.\nVector long move.\nVector long move.\nVector narrow integer.\nVector narrow integer.\nVector narrow integer.\nVector narrow integer.\nVector narrow integer.\nVector narrow integer.\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nDuplicate vector element to vector or scalar\nMultiply\nFloating-point multiply\nMultiply\nMultiply\nMultiply\nMultiply\nFloating-point multiply\nMultiply\nMultiply\nMultiply\nMultiply\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nPolynomial multiply\nMultiply\nMultiply\nMultiply\nMultiply\nMultiply\nMultiply\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply by scalar\nVector long multiply with scalar\nVector long multiply with scalar\nVector long multiply with scalar\nVector long multiply with scalar\nPolynomial multiply long\nSigned multiply long\nSigned multiply long\nSigned multiply long\nUnsigned multiply long\nUnsigned multiply long\nUnsigned multiply long\nMultiply\nFloating-point multiply\nMultiply\nMultiply\nMultiply\nMultiply\nFloating-point multiply\nMultiply\nMultiply\nMultiply\nMultiply\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nVector multiply by scalar\nPolynomial multiply\nMultiply\nMultiply\nMultiply\nMultiply\nMultiply\nMultiply\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nVector bitwise not.\nNegate\nNegate\nNegate\nNegate\nNegate\nNegate\nNegate\nNegate\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise inclusive OR NOT\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nVector bitwise or (immediate, inclusive)\nSigned Add and Accumulate Long Pairwise.\nSigned Add and Accumulate Long Pairwise.\nSigned Add and Accumulate Long Pairwise.\nUnsigned Add and Accumulate Long Pairwise.\nUnsigned Add and Accumulate Long Pairwise.\nUnsigned Add and Accumulate Long Pairwise.\nSigned Add and Accumulate Long Pairwise.\nSigned Add and Accumulate Long Pairwise.\nSigned Add and Accumulate Long Pairwise.\nUnsigned Add and Accumulate Long Pairwise.\nUnsigned Add and Accumulate Long Pairwise.\nUnsigned Add and Accumulate Long Pairwise.\nFloating-point add pairwise\nAdd pairwise.\nAdd pairwise.\nAdd pairwise.\nAdd pairwise.\nAdd pairwise.\nAdd pairwise.\nSigned Add Long Pairwise.\nSigned Add Long Pairwise.\nSigned Add Long Pairwise.\nUnsigned Add Long Pairwise.\nUnsigned Add Long Pairwise.\nUnsigned Add Long Pairwise.\nSigned Add Long Pairwise.\nSigned Add Long Pairwise.\nSigned Add Long Pairwise.\nUnsigned Add Long Pairwise.\nUnsigned Add Long Pairwise.\nUnsigned Add Long Pairwise.\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding maximum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nFolding minimum of adjacent pairs\nSigned saturating Absolute value\nSigned saturating Absolute value\nSigned saturating Absolute value\nSigned saturating Absolute value\nSigned saturating Absolute value\nSigned saturating Absolute value\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nSaturating add\nVector widening saturating doubling multiply accumulate …\nVector widening saturating doubling multiply accumulate …\nVector widening saturating doubling multiply accumulate …\nVector widening saturating doubling multiply accumulate …\nSigned saturating doubling multiply-add long\nSigned saturating doubling multiply-add long\nVector widening saturating doubling multiply subtract with …\nVector widening saturating doubling multiply subtract with …\nVector widening saturating doubling multiply subtract with …\nVector widening saturating doubling multiply subtract with …\nSigned saturating doubling multiply-subtract long\nSigned saturating doubling multiply-subtract long\nVector saturating doubling multiply high by scalar\nVector saturating doubling multiply high by scalar\nVector saturating doubling multiply high with scalar\nVector saturating doubling multiply high with scalar\nSigned saturating doubling multiply returning high half\nSigned saturating doubling multiply returning high half\nVector saturating doubling multiply high by scalar\nVector saturating doubling multiply high by scalar\nVector saturating doubling multiply high with scalar\nVector saturating doubling multiply high with scalar\nSigned saturating doubling multiply returning high half\nSigned saturating doubling multiply returning high half\nVector saturating doubling long multiply by scalar\nVector saturating doubling long multiply by scalar\nVector saturating doubling long multiply with scalar\nVector saturating doubling long multiply with scalar\nSigned saturating doubling multiply long\nSigned saturating doubling multiply long\nSigned saturating extract narrow\nSigned saturating extract narrow\nSigned saturating extract narrow\nUnsigned saturating extract narrow\nUnsigned saturating extract narrow\nUnsigned saturating extract narrow\nSigned saturating extract unsigned narrow\nSigned saturating extract unsigned narrow\nSigned saturating extract unsigned narrow\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nSigned saturating negate\nVector rounding saturating doubling multiply high by scalar\nVector rounding saturating doubling multiply high by scalar\nVector rounding saturating doubling multiply high by scalar\nVector rounding saturating doubling multiply high by scalar\nVector saturating rounding doubling multiply high with …\nVector saturating rounding doubling multiply high with …\nSigned saturating rounding doubling multiply returning …\nSigned saturating rounding doubling multiply returning …\nVector rounding saturating doubling multiply high by scalar\nVector rounding saturating doubling multiply high by scalar\nVector rounding saturating doubling multiply high by scalar\nVector rounding saturating doubling multiply high by scalar\nVector saturating rounding doubling multiply high with …\nVector saturating rounding doubling multiply high with …\nSigned saturating rounding doubling multiply returning …\nSigned saturating rounding doubling multiply returning …\nSigned saturating rounding shift left\nSigned saturating rounding shift left\nSigned saturating rounding shift left\nSigned saturating rounding shift left\nUnsigned signed saturating rounding shift left\nUnsigned signed saturating rounding shift left\nUnsigned signed saturating rounding shift left\nUnsigned signed saturating rounding shift left\nSigned saturating rounding shift left\nSigned saturating rounding shift left\nSigned saturating rounding shift left\nSigned saturating rounding shift left\nUnsigned signed saturating rounding shift left\nUnsigned signed saturating rounding shift left\nUnsigned signed saturating rounding shift left\nUnsigned signed saturating rounding shift left\nSigned saturating rounded shift right narrow\nSigned saturating rounded shift right narrow\nSigned saturating rounded shift right narrow\nUnsigned signed saturating rounded shift right narrow\nUnsigned signed saturating rounded shift right narrow\nUnsigned signed saturating rounded shift right narrow\nSigned saturating rounded shift right unsigned narrow\nSigned saturating rounded shift right unsigned narrow\nSigned saturating rounded shift right unsigned narrow\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nSigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nUnsigned saturating shift left\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift left unsigned\nSigned saturating shift right narrow\nSigned saturating shift right narrow\nSigned saturating shift right narrow\nUnsigned saturating shift right narrow\nUnsigned saturating shift right narrow\nUnsigned saturating shift right narrow\nSigned saturating shift right unsigned narrow\nSigned saturating shift right unsigned narrow\nSigned saturating shift right unsigned narrow\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nSaturating subtract\nRounding Add returning High Narrow (high half).\nRounding Add returning High Narrow (high half).\nRounding Add returning High Narrow (high half).\nRounding Add returning High Narrow (high half).\nRounding Add returning High Narrow (high half).\nRounding Add returning High Narrow (high half).\nRounding Add returning High Narrow.\nRounding Add returning High Narrow.\nRounding Add returning High Narrow.\nRounding Add returning High Narrow.\nRounding Add returning High Narrow.\nRounding Add returning High Narrow.\nReciprocal estimate.\nUnsigned reciprocal estimate\nReciprocal estimate.\nUnsigned reciprocal estimate\nFloating-point reciprocal step\nFloating-point reciprocal step\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nVector reinterpret cast operation\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nReversing vector elements (swap endianness)\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nRounding halving add\nFloating-point round to integral, to nearest with ties to …\nFloating-point round to integral, to nearest with ties to …\nSigned rounding shift left\nSigned rounding shift left\nSigned rounding shift left\nSigned rounding shift left\nUnsigned rounding shift left\nUnsigned rounding shift left\nUnsigned rounding shift left\nUnsigned rounding shift left\nSigned rounding shift left\nSigned rounding shift left\nSigned rounding shift left\nSigned rounding shift left\nUnsigned rounding shift left\nUnsigned rounding shift left\nUnsigned rounding shift left\nUnsigned rounding shift left\nSigned rounding shift right\nSigned rounding shift right\nSigned rounding shift right\nSigned rounding shift right\nUnsigned rounding shift right\nUnsigned rounding shift right\nUnsigned rounding shift right\nUnsigned rounding shift right\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nRounding shift right narrow\nSigned rounding shift right\nSigned rounding shift right\nSigned rounding shift right\nSigned rounding shift right\nUnsigned rounding shift right\nUnsigned rounding shift right\nUnsigned rounding shift right\nUnsigned rounding shift right\nReciprocal square-root estimate.\nUnsigned reciprocal square root estimate\nReciprocal square-root estimate.\nUnsigned reciprocal square root estimate\nFloating-point reciprocal square root step\nFloating-point reciprocal square root step\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nSigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nUnsigned rounding shift right and accumulate\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nRounding subtract returning high narrow\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nInsert vector element from another vector element\nSHA1 hash update accelerator, choose.\nSHA1 fixed rotate.\nSHA1 hash update accelerator, majority.\nSHA1 hash update accelerator, parity.\nSHA1 schedule update accelerator, first part.\nSHA1 schedule update accelerator, second part.\nSHA256 hash update accelerator, upper part.\nSHA256 hash update accelerator.\nSHA256 schedule update accelerator, first part.\nSHA256 schedule update accelerator, second part.\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nSigned Shift left\nSigned Shift left\nSigned Shift left\nSigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nSigned shift left long\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nShift left\nSigned Shift left\nSigned Shift left\nSigned Shift left\nSigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nUnsigned Shift left\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right narrow\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift right\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nShift Left and Insert (immediate)\nSigned shift right and accumulate\nSigned shift right and accumulate\nSigned shift right and accumulate\nSigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nSigned shift right and accumulate\nSigned shift right and accumulate\nSigned shift right and accumulate\nSigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nUnsigned shift right and accumulate\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\nShift Right and Insert (immediate)\n\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\n\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 2-element structures from two registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 3-element structures from three registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore multiple 4-element structures from four registers\nStore SIMD&amp;FP register (immediate offset)\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSubtract returning high narrow\nSigned Subtract Long\nSigned Subtract Long\nSigned Subtract Long\nUnsigned Subtract Long\nUnsigned Subtract Long\nUnsigned Subtract Long\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSubtract\nSigned Subtract Wide\nSigned Subtract Wide\nSigned Subtract Wide\nUnsigned Subtract Wide\nUnsigned Subtract Wide\nUnsigned Subtract Wide\nDot product index form with signed and unsigned integers\nDot product index form with signed and unsigned integers\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nTable look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nExtended table look-up\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nTranspose elements\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nSigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nUnsigned compare bitwise Test bits nonzero\nDot product index form with unsigned and signed integers\nDot product vector form with unsigned and signed integers\nDot product index form with unsigned and signed integers\nDot product vector form with unsigned and signed integers\nUnsigned and signed 8-bit integer matrix …\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nUnzip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nZip vectors\nSigned saturating addition\nInsert a QADD instruction\nSigned saturating subtraction\nInsert a SMLABB instruction\nInsert a SMLABT instruction\nInsert a SMLATB instruction\nInsert a SMLATT instruction\nInsert a SMLAWB instruction\nInsert a SMLAWT instruction\nInsert a SMULBB instruction\nInsert a SMULTB instruction\nInsert a SMULTB instruction\nInsert a SMULTT instruction\nInsert a SMULWB instruction\nInsert a SMULWT instruction\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nARM-specific 32-bit wide vector of two packed <code>i16</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n\n\n\n\n\n\nARM-specific 32-bit wide vector of two packed <code>u16</code>.\nGenerates the trap instruction <code>BREAK</code>\nGenerates the trap instruction <code>BREAK</code>\nSyscall to be used whenever the <em>assert expression produces </em>…\nx-th thread-block dimension.\ny-th thread-block dimension.\nz-th thread-block dimension.\nx-th thread-block index.\ny-th thread-block index.\nz-th thread-block index.\nx-th block-grid dimension.\ny-th block-grid dimension.\nz-th block-grid dimension.\nSynchronizes all threads in the block.\nx-th thread index.\ny-th thread index.\nz-th thread index.\nFree previously dynamically allocated memory.\nAllocate memory dynamically from a fixed-size heap in …\nGenerates the trap instruction <code>TRAP</code>\nPrint formatted output from a kernel to a host-side output …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n\n\n\n\nGenerates the trap instruction <code>TRAP</code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVector abs.\nVector abss.\nVector add.\nVector addc.\nVector adds.\nVector All Elements Equal\nVector All Elements Greater or Equal\nVector All Elements Greater Than\nVector All In\nVector All Elements Less Than or Equal\nVector All Elements Less Than\nAll Elements Not a Number\nVector All Elements Not Equal\nAll Elements Not Greater Than or Equal\nAll Elements Not Greater Than\nAll Elements Not Less Than or Equal\nAll Elements Not Less Than\nAll Elements Numeric\nVector and.\nVector andc.\nVector All Elements Equal\nVector Any Element Greater or Equal\nVector Any Element Greater Than\nVector Any Element Less Than or Equal\nVector Any Element Less Than\nAny Elements Not a Number\nVector Any Elements Not Equal\nAny Elements Not Greater Than or Equal\nAny Elements Not Greater Than\nAny Elements Not Less Than or Equal\nAny Elements Not Less Than\nAny Elements Numeric\nAny Element Out of Bounds\nVector avg.\nVector ceil.\nVector cmpb.\nVector cmpeq.\nVector cmpge.\nVector cmpgt.\nVector cmple.\nVector cmplt.\nVector Convert to Floating-Point\nVector Convert to Signed Integer\nVector Convert to Signed Integer\nVector expte.\nVector floor.\nVector Load Indexed.\nVector Load Element Indexed.\nVector Load Indexed Least Recently Used.\nVector Base-2 Logarithm Estimate\nVector Multiply Add\nVector Multiply Add Saturated\nVector max.\nVector Merge High\nVector Merge Low\nMove From Vector Status and Control Register.\nVector min.\nVector Multiply Low and Add Unsigned Half Word\nVector Multiply Round and Add Saturated\nVector Multiply Sum\nVector Multiply Sum Saturated\nVector Multiply Even\nVector Multiply Odd\nVector Negative Multiply Subtract\nVector nor.\nVector or.\nVector Pack\nVector Pack Saturated\nVector Pack Saturated Unsigned\nVector permute.\nVector Splat\nVector Splat to Signed Halfword\nVector Splat to Signed Word\nVector Splat to Signed Byte\nVector Splat to Unsigned Halfword\nVector Splat to Unsigned Word\nVector Splat to Unsigned Byte\nVector splats.\nVector sub.\nVector subs.\nVector Sum Across Partial (1/2) Saturated\nVector Sum Across Partial (1/4) Saturated\nVector Unpack High\nVector Unpack Low\nVSX Unaligned Load\nVector xor.\nVector permute.\nPowerPC-specific 128-bit wide vector mask of sixteen …\nPowerPC-specific 128-bit wide vector mask of four packed …\nPowerPC-specific 128-bit wide vector mask of two <code>i64</code>\nPowerPC-specific 128-bit wide vector mask of eight packed …\nPowerPC-specific 128-bit wide vector of two packed <code>f64</code>\nPowerPC-specific 128-bit wide vector of four packed <code>f32</code>\nPowerPC-specific 128-bit wide vector of sixteen packed <code>i8</code>\nPowerPC-specific 128-bit wide vector of four packed <code>i32</code>\nPowerPC-specific 128-bit wide vector of two packed <code>i64</code>\nPowerPC-specific 128-bit wide vector of eight packed <code>i16</code>\nPowerPC-specific 128-bit wide vector of sixteen packed <code>u8</code>\nPowerPC-specific 128-bit wide vector of four packed <code>u32</code>\nPowerPC-specific 128-bit wide vector of two packed <code>u64</code>\nPowerPC-specific 128-bit wide vector of eight packed <code>u16</code>\nGenerates the trap instruction <code>TRAP</code>\nVector abs.\nVector abss.\nVector add.\nVector addc.\nVector adds.\nVector All Elements Equal\nVector All Elements Greater or Equal\nVector All Elements Greater Than\nVector All In\nVector All Elements Less Than or Equal\nVector All Elements Less Than\nAll Elements Not a Number\nVector All Elements Not Equal\nAll Elements Not Greater Than or Equal\nAll Elements Not Greater Than\nAll Elements Not Less Than or Equal\nAll Elements Not Less Than\nAll Elements Numeric\nVector and.\nVector andc.\nVector All Elements Equal\nVector Any Element Greater or Equal\nVector Any Element Greater Than\nVector Any Element Less Than or Equal\nVector Any Element Less Than\nAny Elements Not a Number\nVector Any Elements Not Equal\nAny Elements Not Greater Than or Equal\nAny Elements Not Greater Than\nAny Elements Not Less Than or Equal\nAny Elements Not Less Than\nAny Elements Numeric\nAny Element Out of Bounds\nVector avg.\nVector ceil.\nVector cmpb.\nVector cmpeq.\nVector cmpge.\nVector cmpgt.\nVector cmple.\nVector cmplt.\nVector Convert to Floating-Point\nVector Convert to Signed Integer\nVector Convert to Signed Integer\nVector expte.\nVector floor.\nVector Load Indexed.\nVector Load Element Indexed.\nVector Load Indexed Least Recently Used.\nVector Base-2 Logarithm Estimate\nVector Multiply Add\nVector Multiply Add Saturated\nVector max.\nVector Merge High\nVector Merge Low\nMove From Vector Status and Control Register.\nVector min.\nVector Multiply Low and Add Unsigned Half Word\nVector Multiply Round and Add Saturated\nVector Multiply Sum\nVector Multiply Sum Saturated\nVector Multiply Even\nVector Multiply Odd\nVector Negative Multiply Subtract\nVector nor.\nVector or.\nVector Pack\nVector Pack Saturated\nVector Pack Saturated Unsigned\nVector permute.\nVector Splat\nVector Splat to Signed Halfword\nVector Splat to Signed Word\nVector Splat to Signed Byte\nVector Splat to Unsigned Halfword\nVector Splat to Unsigned Word\nVector Splat to Unsigned Byte\nVector splats.\nVector sub.\nVector subs.\nVector Sum Across Partial (1/2) Saturated\nVector Sum Across Partial (1/4) Saturated\nVector Unpack High\nVector Unpack Low\nVSX Unaligned Load\nVector xor.\nVector permute.\nPowerPC-specific 128-bit wide vector mask of sixteen …\nPowerPC-specific 128-bit wide vector mask of four packed …\nPowerPC-specific 128-bit wide vector mask of two <code>i64</code>\nPowerPC-specific 128-bit wide vector mask of eight packed …\nPowerPC-specific 128-bit wide vector of two packed <code>f64</code>\nPowerPC-specific 128-bit wide vector of four packed <code>f32</code>\nPowerPC-specific 128-bit wide vector of sixteen packed <code>i8</code>\nPowerPC-specific 128-bit wide vector of four packed <code>i32</code>\nPowerPC-specific 128-bit wide vector of two packed <code>i64</code>\nPowerPC-specific 128-bit wide vector of eight packed <code>i16</code>\nPowerPC-specific 128-bit wide vector of sixteen packed <code>u8</code>\nPowerPC-specific 128-bit wide vector of four packed <code>u32</code>\nPowerPC-specific 128-bit wide vector of two packed <code>u64</code>\nPowerPC-specific 128-bit wide vector of eight packed <code>u16</code>\nAdds packed 16-bit signed numbers, discarding overflow bits\nAdds packed 8-bit signed numbers, discarding overflow bits\nAES final round decryption instruction for RV32.\nAES middle round decryption instruction for RV32.\nAES final round encryption instruction for RV32.\nAES middle round encryption instruction for RV32 with.\nCarry-less multiply (low-part)\nCarry-less multiply (high-part)\nCarry-less multiply (reversed)\nCount the number of redundant sign bits of the packed …\nCount the number of redundant sign bits of the packed …\nCount the number of redundant sign bits of the packed …\nCount the number of leading zero bits of the packed 16-bit …\nCount the number of leading zero bits of the packed 32-bit …\nCount the number of leading zero bits of the packed 8-bit …\nCompare equality for packed 16-bit elements\nCompare equality for packed 8-bit elements\nCross adds and subtracts packed 16-bit signed numbers, …\nCross subtracts and adds packed 16-bit signed numbers, …\nGenerates the <code>FENCE.I</code> instruction\nReads the floating-point control and status register <code>fcsr</code>\nReads the floating-point accrued exception flags register …\nReads the floating-point rounding mode register <code>frm</code>\nSwaps the floating-point control and status register <code>fcsr</code>\nSwaps the floating-point accrued exception flags register …\nSwaps the floating-point rounding mode register <code>frm</code>\nHypervisor memory management fence for guest physical …\nHypervisor memory management fence for all virtual …\nHypervisor memory management fence for guest physical …\nHypervisor memory management fence for given virtual …\nHypervisor memory management fence for given guest virtual …\nHypervisor memory management fence for all guest address …\nHypervisor memory management fence for given guest address …\nHypervisor memory management fence for given guest virtual …\nInvalidate hypervisor translation cache for guest physical …\nInvalidate hypervisor translation cache for all virtual …\nInvalidate hypervisor translation cache for guest physical …\nInvalidate hypervisor translation cache for given virtual …\nInvalidate hypervisor translation cache for given guest …\nInvalidate hypervisor translation cache for all guest …\nInvalidate hypervisor translation cache for given guest …\nInvalidate hypervisor translation cache for given guest …\nLoads virtual machine memory by signed byte integer\nLoads virtual machine memory by unsigned byte integer\nLoads virtual machine memory by signed half integer\nLoads virtual machine memory by unsigned half integer\nLoads virtual machine memory by signed word integer\nAccesses virtual machine instruction by unsigned half …\nAccesses virtual machine instruction by unsigned word …\nStores virtual machine memory by byte integer\nStores virtual machine memory by half integer\nStores virtual machine memory by word integer\nCompute the absolute value of packed 16-bit signed integers\nCompute the absolute value of packed 8-bit signed integers\nAdds packed 16-bit signed numbers, saturating at the …\nAdds packed 8-bit signed numbers, saturating at the …\nAdds signed lower 16-bit content of two registers with Q15 …\nCross adds and subtracts packed 16-bit signed numbers, …\nCross subtracts and adds packed 16-bit signed numbers, …\nLogical left shift packed 16-bit elements, saturating at …\nLogical left shift packed 8-bit elements, saturating at …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nStraight adds and subtracts packed 16-bit signed numbers, …\nStraight subtracts and adds packed 16-bit signed numbers, …\nSubtracts packed 16-bit signed numbers, saturating at the …\nSubtracts packed 8-bit signed numbers, saturating at the …\nSubtracts signed lower 16-bit content of two registers …\nGenerates the <code>NOP</code> instruction\nBitwise OR-Combine, byte granule\nGenerates the <code>PAUSE</code> instruction\nCalculate the sum of absolute difference of unsigned 8-bit …\nCalculate and accumulate the sum of absolute difference of …\nPack two 16-bit data from bottom and top half from 32-bit …\nPack two 16-bit data from top and bottom half from 32-bit …\nHalves the sum of packed 16-bit signed numbers, dropping …\nHalves the sum of packed 8-bit signed numbers, dropping …\nCross halves of adds and subtracts packed 16-bit signed …\nCross halves of subtracts and adds packed 16-bit signed …\nStraight halves of adds and subtracts packed 16-bit signed …\nStraight halves of subtracts and adds packed 16-bit signed …\nHalves the subtraction result of packed 16-bit signed …\nHalves the subtraction result of packed 8-bit signed …\nCompare whether 16-bit packed signed integers are less …\nCompare whether 8-bit packed signed integers are less than …\nCompare whether 16-bit packed signed integers are less …\nCompare whether 8-bit packed signed integers are less than …\nGenerates the <code>SFENCE.INVAL.IR</code> instruction\nSupervisor memory management fence for given virtual …\nSupervisor memory management fence for all address spaces …\nSupervisor memory management fence for given address space\nSupervisor memory management fence for given virtual …\nGenerates the <code>SFENCE.W.INVAL</code> instruction\nImplements the Sigma0 transformation function as used in …\nImplements the Sigma1 transformation function as used in …\nImplements the Sum0 transformation function as used in the …\nImplements the Sum1 transformation function as used in the …\nImplements the high half of the Sigma0 transformation, as …\nImplements the low half of the Sigma0 transformation, as …\nImplements the high half of the Sigma1 transformation, as …\nImplements the low half of the Sigma1 transformation, as …\nImplements the Sum0 transformation, as used in the …\nImplements the Sum1 transformation, as used in the …\nInvalidate supervisor translation cache for given virtual …\nInvalidate supervisor translation cache for all address …\nInvalidate supervisor translation cache for given address …\nInvalidate supervisor translation cache for given virtual …\nLogical left shift packed 16-bit elements, discarding …\nLogical left shift packed 8-bit elements, discarding …\nImplements the P0 transformation function as used in the …\nImplements the P1 transformation function as used in the …\nAccelerates the block encrypt/decrypt operation of the SM4 …\nAccelerates the Key Schedule operation of the SM4 block …\nMultiply signed 8-bit elements and add 16-bit elements on …\nMultiply signed to unsigned 8-bit and add 16-bit elements …\nGet maximum values from 16-bit packed signed integers\nGet maximum values from 8-bit packed signed integers\nGet minimum values from 16-bit packed signed integers\nGet minimum values from 8-bit packed signed integers\nArithmetic right shift packed 16-bit elements without …\nArithmetic right shift packed 16-bit elements with …\nArithmetic right shift packed 8-bit elements without …\nArithmetic right shift packed 8-bit elements with rounding …\nLogical right shift packed 16-bit elements without …\nLogical right shift packed 16-bit elements with rounding up\nLogical right shift packed 8-bit elements without rounding …\nLogical right shift packed 8-bit elements with rounding up\nStraight adds and subtracts packed 16-bit signed numbers, …\nStraight subtracts and adds packed 16-bit signed numbers, …\nSubtracts packed 16-bit signed numbers, discarding …\nSubtracts packed 8-bit signed numbers, discarding overflow …\nUnpack first and zeroth into two 16-bit signed halfwords …\nUnpack second and zeroth into two 16-bit signed halfwords …\nUnpack third and zeroth into two 16-bit signed halfwords …\nUnpack third and first into two 16-bit signed halfwords in …\nUnpack third and second into two 16-bit signed halfwords …\nSwap the 16-bit halfwords within each 32-bit word of a …\nSwap the 8-bit bytes within each 16-bit halfword of a …\nCompare whether 16-bit packed unsigned integers are less …\nCompare whether 8-bit packed unsigned integers are less …\nCompare whether 16-bit packed unsigned integers are less …\nCompare whether 8-bit packed unsigned integers are less …\nAdds packed 16-bit unsigned numbers, saturating at the …\nAdds packed 8-bit unsigned numbers, saturating at the …\nAdds signed lower 16-bit content of two registers with U16 …\nCross adds and subtracts packed 16-bit unsigned numbers, …\nCross subtracts and adds packed 16-bit unsigned numbers, …\nStraight adds and subtracts packed 16-bit unsigned …\nStraight subtracts and adds packed 16-bit unsigned …\nSubtracts packed 16-bit unsigned numbers, saturating at …\nSubtracts packed 8-bit unsigned numbers, saturating at the …\nSubtracts signed lower 16-bit content of two registers …\nMultiply unsigned 8-bit elements and add 16-bit elements …\nGet maximum values from 16-bit packed unsigned integers\nGet maximum values from 8-bit packed unsigned integers\nGet minimum values from 16-bit packed unsigned integers\nGet minimum values from 8-bit packed unsigned integers\nPlace odd and even bits of the source word into …\nHalves the sum of packed 16-bit unsigned numbers, dropping …\nHalves the sum of packed 8-bit unsigned numbers, dropping …\nCross halves of adds and subtracts packed 16-bit unsigned …\nCross halves of subtracts and adds packed 16-bit unsigned …\nStraight halves of adds and subtracts packed 16-bit …\nStraight halves of subtracts and adds packed 16-bit …\nHalves the subtraction result of packed 16-bit unsigned …\nHalves the subtraction result of packed 8-bit unsigned …\nGenerates the <code>WFI</code> instruction\nNibble-wise lookup of indicies into a vector.\nByte-wise lookup of indicies into a vector in registers.\nPlace upper/lower halves of the source register into …\nUnpack first and zeroth into two 16-bit unsigned halfwords …\nUnpack second and zeroth into two 16-bit unsigned …\nUnpack third and zeroth into two 16-bit unsigned halfwords …\nUnpack third and first into two 16-bit unsigned halfwords …\nUnpack third and second into two 16-bit unsigned halfwords …\nAdds packed 16-bit signed numbers, discarding overflow bits\nAdds packed 8-bit signed numbers, discarding overflow bits\nAES final round decryption instruction for RV64.\nAES middle round decryption instruction for RV64.\nAES final round encryption instruction for RV64.\nAES middle round encryption instruction for RV64.\nThis instruction accelerates the inverse MixColumns step …\nThis instruction implements part of the KeySchedule …\nThis instruction implements part of the KeySchedule …\nCarry-less multiply (low-part)\nCarry-less multiply (high-part)\nCarry-less multiply (reversed)\nCount the number of redundant sign bits of the packed …\nCount the number of redundant sign bits of the packed …\nCount the number of redundant sign bits of the packed …\nCount the number of leading zero bits of the packed 16-bit …\nCount the number of leading zero bits of the packed 32-bit …\nCount the number of leading zero bits of the packed 8-bit …\nCompare equality for packed 16-bit elements\nCompare equality for packed 8-bit elements\nCross adds and subtracts packed 16-bit signed numbers, …\nCross subtracts and adds packed 16-bit signed numbers, …\nGenerates the <code>FENCE.I</code> instruction\nReads the floating-point control and status register <code>fcsr</code>\nReads the floating-point accrued exception flags register …\nReads the floating-point rounding mode register <code>frm</code>\nSwaps the floating-point control and status register <code>fcsr</code>\nSwaps the floating-point accrued exception flags register …\nSwaps the floating-point rounding mode register <code>frm</code>\nHypervisor memory management fence for guest physical …\nHypervisor memory management fence for all virtual …\nHypervisor memory management fence for guest physical …\nHypervisor memory management fence for given virtual …\nHypervisor memory management fence for given guest virtual …\nHypervisor memory management fence for all guest address …\nHypervisor memory management fence for given guest address …\nHypervisor memory management fence for given guest virtual …\nInvalidate hypervisor translation cache for guest physical …\nInvalidate hypervisor translation cache for all virtual …\nInvalidate hypervisor translation cache for guest physical …\nInvalidate hypervisor translation cache for given virtual …\nInvalidate hypervisor translation cache for given guest …\nInvalidate hypervisor translation cache for all guest …\nInvalidate hypervisor translation cache for given guest …\nInvalidate hypervisor translation cache for given guest …\nLoads virtual machine memory by signed byte integer\nLoads virtual machine memory by unsigned byte integer\nLoads virtual machine memory by double integer\nLoads virtual machine memory by signed half integer\nLoads virtual machine memory by unsigned half integer\nLoads virtual machine memory by signed word integer\nLoads virtual machine memory by unsigned word integer\nAccesses virtual machine instruction by unsigned half …\nAccesses virtual machine instruction by unsigned word …\nStores virtual machine memory by byte integer\nStores virtual machine memory by double integer\nStores virtual machine memory by half integer\nStores virtual machine memory by word integer\nCompute the absolute value of packed 16-bit signed integers\nCompute the absolute value of packed 8-bit signed integers\nAdds packed 16-bit signed numbers, saturating at the …\nAdds packed 8-bit signed numbers, saturating at the …\nAdds signed lower 16-bit content of two registers with Q15 …\nCross adds and subtracts packed 16-bit signed numbers, …\nCross subtracts and adds packed 16-bit signed numbers, …\nLogical left shift packed 16-bit elements, saturating at …\nLogical left shift packed 8-bit elements, saturating at …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nStraight adds and subtracts packed 16-bit signed numbers, …\nStraight subtracts and adds packed 16-bit signed numbers, …\nSubtracts packed 16-bit signed numbers, saturating at the …\nSubtracts packed 8-bit signed numbers, saturating at the …\nSubtracts signed lower 16-bit content of two registers …\nGenerates the <code>NOP</code> instruction\nBitwise OR-Combine, byte granule\nGenerates the <code>PAUSE</code> instruction\nCalculate the sum of absolute difference of unsigned 8-bit …\nCalculate and accumulate the sum of absolute difference of …\nPack two 16-bit data from bottom and top half from 32-bit …\nPack two 16-bit data from top and bottom half from 32-bit …\nHalves the sum of packed 16-bit signed numbers, dropping …\nHalves the sum of packed 8-bit signed numbers, dropping …\nCross halves of adds and subtracts packed 16-bit signed …\nCross halves of subtracts and adds packed 16-bit signed …\nStraight halves of adds and subtracts packed 16-bit signed …\nStraight halves of subtracts and adds packed 16-bit signed …\nHalves the subtraction result of packed 16-bit signed …\nHalves the subtraction result of packed 8-bit signed …\nCompare whether 16-bit packed signed integers are less …\nCompare whether 8-bit packed signed integers are less than …\nCompare whether 16-bit packed signed integers are less …\nCompare whether 8-bit packed signed integers are less than …\nGenerates the <code>SFENCE.INVAL.IR</code> instruction\nSupervisor memory management fence for given virtual …\nSupervisor memory management fence for all address spaces …\nSupervisor memory management fence for given address space\nSupervisor memory management fence for given virtual …\nGenerates the <code>SFENCE.W.INVAL</code> instruction\nImplements the Sigma0 transformation function as used in …\nImplements the Sigma1 transformation function as used in …\nImplements the Sum0 transformation function as used in the …\nImplements the Sum1 transformation function as used in the …\nImplements the Sigma0 transformation function as used in …\nImplements the Sigma1 transformation function as used in …\nImplements the Sum0 transformation function as used in the …\nImplements the Sum1 transformation function as used in the …\nInvalidate supervisor translation cache for given virtual …\nInvalidate supervisor translation cache for all address …\nInvalidate supervisor translation cache for given address …\nInvalidate supervisor translation cache for given virtual …\nLogical left shift packed 16-bit elements, discarding …\nLogical left shift packed 8-bit elements, discarding …\nImplements the P0 transformation function as used in the …\nImplements the P1 transformation function as used in the …\nAccelerates the block encrypt/decrypt operation of the SM4 …\nAccelerates the Key Schedule operation of the SM4 block …\nMultiply signed 8-bit elements and add 16-bit elements on …\nMultiply signed to unsigned 8-bit and add 16-bit elements …\nGet maximum values from 16-bit packed signed integers\nGet maximum values from 8-bit packed signed integers\nGet minimum values from 16-bit packed signed integers\nGet minimum values from 8-bit packed signed integers\nArithmetic right shift packed 16-bit elements without …\nArithmetic right shift packed 16-bit elements with …\nArithmetic right shift packed 8-bit elements without …\nArithmetic right shift packed 8-bit elements with rounding …\nLogical right shift packed 16-bit elements without …\nLogical right shift packed 16-bit elements with rounding up\nLogical right shift packed 8-bit elements without rounding …\nLogical right shift packed 8-bit elements with rounding up\nStraight adds and subtracts packed 16-bit signed numbers, …\nStraight subtracts and adds packed 16-bit signed numbers, …\nSubtracts packed 16-bit signed numbers, discarding …\nSubtracts packed 8-bit signed numbers, discarding overflow …\nUnpack first and zeroth into two 16-bit signed halfwords …\nUnpack second and zeroth into two 16-bit signed halfwords …\nUnpack third and zeroth into two 16-bit signed halfwords …\nUnpack third and first into two 16-bit signed halfwords in …\nUnpack third and second into two 16-bit signed halfwords …\nSwap the 16-bit halfwords within each 32-bit word of a …\nSwap the 8-bit bytes within each 16-bit halfword of a …\nCompare whether 16-bit packed unsigned integers are less …\nCompare whether 8-bit packed unsigned integers are less …\nCompare whether 16-bit packed unsigned integers are less …\nCompare whether 8-bit packed unsigned integers are less …\nAdds packed 16-bit unsigned numbers, saturating at the …\nAdds packed 8-bit unsigned numbers, saturating at the …\nAdds signed lower 16-bit content of two registers with U16 …\nCross adds and subtracts packed 16-bit unsigned numbers, …\nCross subtracts and adds packed 16-bit unsigned numbers, …\nStraight adds and subtracts packed 16-bit unsigned …\nStraight subtracts and adds packed 16-bit unsigned …\nSubtracts packed 16-bit unsigned numbers, saturating at …\nSubtracts packed 8-bit unsigned numbers, saturating at the …\nSubtracts signed lower 16-bit content of two registers …\nMultiply unsigned 8-bit elements and add 16-bit elements …\nGet maximum values from 16-bit packed unsigned integers\nGet maximum values from 8-bit packed unsigned integers\nGet minimum values from 16-bit packed unsigned integers\nGet minimum values from 8-bit packed unsigned integers\nHalves the sum of packed 16-bit unsigned numbers, dropping …\nHalves the sum of packed 8-bit unsigned numbers, dropping …\nCross halves of adds and subtracts packed 16-bit unsigned …\nCross halves of subtracts and adds packed 16-bit unsigned …\nStraight halves of adds and subtracts packed 16-bit …\nStraight halves of subtracts and adds packed 16-bit …\nHalves the subtraction result of packed 16-bit unsigned …\nHalves the subtraction result of packed 8-bit unsigned …\nGenerates the <code>WFI</code> instruction\nNibble-wise lookup of indicies into a vector.\nByte-wise lookup of indicies into a vector in registers.\nUnpack first and zeroth into two 16-bit unsigned halfwords …\nUnpack second and zeroth into two 16-bit unsigned …\nUnpack third and zeroth into two 16-bit unsigned halfwords …\nUnpack third and first into two 16-bit unsigned halfwords …\nUnpack third and second into two 16-bit unsigned halfwords …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise addition of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value not …\nConverts a 128-bit vector interpreted as four 32-bit …\nConverts a 128-bit vector interpreted as four 32-bit …\nConversion of the two double-precision floating point …\nLane-wise division of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiplication of two 128-bit vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as four …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f32x4_max</code> which is either <code>f32x4_max</code> or\nA relaxed version of <code>f32x4_min</code> which is either <code>f32x4_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtraction of two 128-bit vectors interpreted …\nLane-wise rounding to the nearest integral value with the …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise add of two 128-bit vectors interpreted as two …\nLane-wise rounding to the nearest integral value not …\nLane-wise conversion from integer to floating point.\nLane-wise conversion from integer to floating point.\nLane-wise divide of two 128-bit vectors interpreted as two …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise maximum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiply of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as two …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nConversion of the two lower single-precision floating …\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f64x2_max</code> which is either <code>f64x2_max</code> or\nA relaxed version of <code>f64x2_min</code> which is either <code>f64x2_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtract of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value with the …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and sign extend each one to a …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as eight 16-bit …\nLane-wise saturating rounding multiplication in Q15 format.\nA relaxed dot-product instruction.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i16x8_relaxed_q15mulr</code> where if both …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nLane-wise multiply signed 16-bit integers in the two input …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and sign extend each one to a …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as four 32-bit …\nSimilar to <code>i16x8_relaxed_dot_i8x16_i7x16</code> except that the …\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>i32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad two 32-bit integers and sign extend each one to a …\nLoad two 32-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as two 64-bit signed …\nA relaxed version of <code>v128_bitselect</code> where this either …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as sixteen 8-bit …\nCount the number of bits set to one within each lane.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i8x16_swizzle(a, s)</code> which selects …\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nCorresponding intrinsic to wasm’s <code>memory.atomic.notify</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait32</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait64</code> …\nCorresponding intrinsic to wasm’s <code>memory.grow</code> instruction\nCorresponding intrinsic to wasm’s <code>memory.size</code> instruction\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nA relaxed version of <code>u32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>u32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLoad two 32-bit integers and zero extend each one to a …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nCount the number of bits set to one within each lane.\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nGenerates the <code>unreachable</code> instruction, which causes an …\nWASM-specific 128-bit wide SIMD vector type.\nPerforms a bitwise and of the two input 128-bit vectors, …\nBitwise AND of bits of <code>a</code> and the logical inverse of bits …\nReturns <code>true</code> if any bit in <code>a</code> is set, or <code>false</code> otherwise.\nUse the bitmask in <code>c</code> to select bits from <code>v1</code> when 1 and <code>v2</code> …\nLoads a <code>v128</code> vector from the given heap address.\nLoads a 16-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoads a 32-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 32-bit element into the low bits of the vector and …\nLoads a 64-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 64-bit element into the low bits of the vector and …\nLoads an 8-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nFlips each bit of the 128-bit input vector.\nPerforms a bitwise or of the two input 128-bit vectors, …\nStores a <code>v128</code> vector to the given heap address.\nStores the 16-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 32-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 64-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 8-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nPerforms a bitwise xor of the two input 128-bit vectors, …\n\n\n\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise addition of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value not …\nConverts a 128-bit vector interpreted as four 32-bit …\nConverts a 128-bit vector interpreted as four 32-bit …\nConversion of the two double-precision floating point …\nLane-wise division of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiplication of two 128-bit vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as four …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f32x4_max</code> which is either <code>f32x4_max</code> or\nA relaxed version of <code>f32x4_min</code> which is either <code>f32x4_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtraction of two 128-bit vectors interpreted …\nLane-wise rounding to the nearest integral value with the …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise add of two 128-bit vectors interpreted as two …\nLane-wise rounding to the nearest integral value not …\nLane-wise conversion from integer to floating point.\nLane-wise conversion from integer to floating point.\nLane-wise divide of two 128-bit vectors interpreted as two …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise maximum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiply of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as two …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nConversion of the two lower single-precision floating …\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f64x2_max</code> which is either <code>f64x2_max</code> or\nA relaxed version of <code>f64x2_min</code> which is either <code>f64x2_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtract of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value with the …\n\nReturns the argument unchanged.\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and sign extend each one to a …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as eight 16-bit …\nLane-wise saturating rounding multiplication in Q15 format.\nA relaxed dot-product instruction.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i16x8_relaxed_q15mulr</code> where if both …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nLane-wise multiply signed 16-bit integers in the two input …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and sign extend each one to a …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as four 32-bit …\nSimilar to <code>i16x8_relaxed_dot_i8x16_i7x16</code> except that the …\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>i32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad two 32-bit integers and sign extend each one to a …\nLoad two 32-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as two 64-bit signed …\nA relaxed version of <code>v128_bitselect</code> where this either …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as sixteen 8-bit …\nCount the number of bits set to one within each lane.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i8x16_swizzle(a, s)</code> which selects …\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nCalls <code>U::from(self)</code>.\nCorresponding intrinsic to wasm’s <code>memory.atomic.notify</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait32</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait64</code> …\nCorresponding intrinsic to wasm’s <code>memory.grow</code> instruction\nCorresponding intrinsic to wasm’s <code>memory.size</code> instruction\n\n\n\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nA relaxed version of <code>u32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>u32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLoad two 32-bit integers and zero extend each one to a …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nCount the number of bits set to one within each lane.\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nGenerates the <code>unreachable</code> instruction, which causes an …\nWASM-specific 128-bit wide SIMD vector type.\nPerforms a bitwise and of the two input 128-bit vectors, …\nBitwise AND of bits of <code>a</code> and the logical inverse of bits …\nReturns <code>true</code> if any bit in <code>a</code> is set, or <code>false</code> otherwise.\nUse the bitmask in <code>c</code> to select bits from <code>v1</code> when 1 and <code>v2</code> …\nLoads a <code>v128</code> vector from the given heap address.\nLoads a 16-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoads a 32-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 32-bit element into the low bits of the vector and …\nLoads a 64-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 64-bit element into the low bits of the vector and …\nLoads an 8-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nFlips each bit of the 128-bit input vector.\nPerforms a bitwise or of the two input 128-bit vectors, …\nStores a <code>v128</code> vector to the given heap address.\nStores the 16-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 32-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 64-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 8-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nPerforms a bitwise xor of the two input 128-bit vectors, …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise addition of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value not …\nConverts a 128-bit vector interpreted as four 32-bit …\nConverts a 128-bit vector interpreted as four 32-bit …\nConversion of the two double-precision floating point …\nLane-wise division of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiplication of two 128-bit vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as four …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f32x4_max</code> which is either <code>f32x4_max</code> or\nA relaxed version of <code>f32x4_min</code> which is either <code>f32x4_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtraction of two 128-bit vectors interpreted …\nLane-wise rounding to the nearest integral value with the …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise add of two 128-bit vectors interpreted as two …\nLane-wise rounding to the nearest integral value not …\nLane-wise conversion from integer to floating point.\nLane-wise conversion from integer to floating point.\nLane-wise divide of two 128-bit vectors interpreted as two …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise maximum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiply of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as two …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nConversion of the two lower single-precision floating …\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f64x2_max</code> which is either <code>f64x2_max</code> or\nA relaxed version of <code>f64x2_min</code> which is either <code>f64x2_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtract of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value with the …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and sign extend each one to a …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as eight 16-bit …\nLane-wise saturating rounding multiplication in Q15 format.\nA relaxed dot-product instruction.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i16x8_relaxed_q15mulr</code> where if both …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nLane-wise multiply signed 16-bit integers in the two input …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and sign extend each one to a …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as four 32-bit …\nSimilar to <code>i16x8_relaxed_dot_i8x16_i7x16</code> except that the …\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>i32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad two 32-bit integers and sign extend each one to a …\nLoad two 32-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as two 64-bit signed …\nA relaxed version of <code>v128_bitselect</code> where this either …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as sixteen 8-bit …\nCount the number of bits set to one within each lane.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i8x16_swizzle(a, s)</code> which selects …\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nCorresponding intrinsic to wasm’s <code>memory.atomic.notify</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait32</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait64</code> …\nCorresponding intrinsic to wasm’s <code>memory.grow</code> instruction\nCorresponding intrinsic to wasm’s <code>memory.size</code> instruction\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nA relaxed version of <code>u32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>u32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLoad two 32-bit integers and zero extend each one to a …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nCount the number of bits set to one within each lane.\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nGenerates the <code>unreachable</code> instruction, which causes an …\nWASM-specific 128-bit wide SIMD vector type.\nPerforms a bitwise and of the two input 128-bit vectors, …\nBitwise AND of bits of <code>a</code> and the logical inverse of bits …\nReturns <code>true</code> if any bit in <code>a</code> is set, or <code>false</code> otherwise.\nUse the bitmask in <code>c</code> to select bits from <code>v1</code> when 1 and <code>v2</code> …\nLoads a <code>v128</code> vector from the given heap address.\nLoads a 16-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoads a 32-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 32-bit element into the low bits of the vector and …\nLoads a 64-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 64-bit element into the low bits of the vector and …\nLoads an 8-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nFlips each bit of the 128-bit input vector.\nPerforms a bitwise or of the two input 128-bit vectors, …\nStores a <code>v128</code> vector to the given heap address.\nStores the 16-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 32-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 64-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 8-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nPerforms a bitwise xor of the two input 128-bit vectors, …\nResult of the <code>cpuid</code> instruction.\nEqual (ordered, non-signaling)\nEqual (ordered, signaling)\nEqual (unordered, non-signaling)\nEqual (unordered, signaling)\nFalse (ordered, non-signaling)\nFalse (ordered, signaling)\nGreater-than-or-equal (ordered, non-signaling)\nGreater-than-or-equal (ordered, signaling)\nGreater-than (ordered, non-signaling)\nGreater-than (ordered, signaling)\nLess-than-or-equal (ordered, non-signaling)\nLess-than-or-equal (ordered, signaling)\nLess-than (ordered, non-signaling)\nLess-than (ordered, signaling)\nNot-equal (ordered, non-signaling)\nNot-equal (ordered, signaling)\nNot-equal (unordered, non-signaling)\nNot-equal (unordered, signaling)\nNot-greater-than-or-equal (unordered, non-signaling)\nNot-greater-than-or-equal (unordered, signaling)\nNot-greater-than (unordered, non-signaling)\nNot-greater-than (unordered, signaling)\nNot-less-than-or-equal (unordered, non-signaling)\nNot-less-than-or-equal (unordered, signaling)\nNot-less-than (unordered, non-signaling)\nNot-less-than (unordered, signaling)\nOrdered (non-signaling)\nOrdered (signaling)\nTrue (unordered, non-signaling)\nTrue (unordered, signaling)\nUnordered (non-signaling)\nUnordered (signaling)\nThe <code>_MM_CMPINT_ENUM</code> type used to specify comparison …\nEqual\nFalse\nLess-than-or-equal\nLess-than\nNot-equal\nNot less-than-or-equal\nNot less-than\nTrue\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_EXCEPTION_STATE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_FLUSH_ZERO_MODE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nround up and do not suppress exceptions\nuse MXCSR.RC; see <code>vendor::_MM_SET_ROUNDING_MODE</code>\nround down and do not suppress exceptions\nuse MXCSR.RC and suppress exceptions; see …\nround to nearest and do not suppress exceptions\nsuppress exceptions\ndo not suppress exceptions\nuse MXCSR.RC and do not suppress exceptions; see …\nround to nearest\nround down\nround up\ntruncate\ntruncate and do not suppress exceptions\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nThe <code>MM_MANTISSA_NORM_ENUM</code> type used to specify mantissa …\nThe <code>MM_MANTISSA_SIGN_ENUM</code> type used to specify mantissa …\ninterval [1, 2)\ninterval [0.5, 1)\ninterval [0.5, 2)\ninterval [0.75, 1.5)\nDEST = NaN if sign(SRC) = 1\nsign = sign(SRC)\nsign = 0\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_EXCEPTION_MASK</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe <code>MM_PERM_ENUM</code> type used to specify shuffle operations …\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_ROUNDING_MODE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nA utility function for creating masks to use with Intel …\nTranspose the 4x4 matrix formed by 4 rows of __m128 in …\n<strong>Mask only</strong>: return the bit mask\nFor each character in <code>a</code>, find if it is in <code>b</code> <em>(Default)</em>\nThe strings defined by <code>a</code> and <code>b</code> are equal\nSearch for the defined substring in the target\nFor each character in <code>a</code>, determine if …\n<strong>Index only</strong>: return the least significant bit <em>(Default)</em>\nNegates results only before the end of the string\nDo not negate results before the end of the string\n<strong>Index only</strong>: return the most significant bit\nNegates results\nDo not negate results <em>(Default)</em>\nString contains signed 8-bit characters\nString contains unsigned 16-bit characters\nString contains unsigned 8-bit characters <em>(Default)</em>\n<strong>Mask only</strong>: return the byte mask\nString contains unsigned 16-bit characters\nTransaction abort due to the transaction using too much …\nTransaction abort due to a memory conflict with another …\nTransaction abort due to a debug trap.\nTransaction explicitly aborted with xabort. The parameter …\nTransaction abort in a inner nested transaction.\nTransaction retry is possible.\nTransaction successfully started.\n<code>XFEATURE_ENABLED_MASK</code> for <code>XCR</code>\nSee <code>__cpuid_count</code>.\nReturns the result of the <code>cpuid</code> instruction for a given …\nReturns the highest-supported <code>leaf</code> (<code>EAX</code>) and sub-leaf (<code>ECX</code>…\n128-bit wide set of four <code>f32</code> types, x86-specific\n128-bit wide set of eight <code>u16</code> types, x86-specific\n128-bit wide set of two <code>f64</code> types, x86-specific\n128-bit wide integer vector type, x86-specific\n256-bit wide set of eight <code>f32</code> types, x86-specific\n256-bit wide set of 16 <code>u16</code> types, x86-specific\n256-bit wide set of four <code>f64</code> types, x86-specific\n256-bit wide integer vector type, x86-specific\n512-bit wide set of sixteen <code>f32</code> types, x86-specific\n512-bit wide set of 32 <code>u16</code> types, x86-specific\n512-bit wide set of eight <code>f64</code> types, x86-specific\n512-bit wide integer vector type, x86-specific\nThe <code>__mmask16</code> type used in AVX-512 intrinsics, a 16-bit …\nThe <code>__mmask32</code> type used in AVX-512 intrinsics, a 32-bit …\nThe <code>__mmask64</code> type used in AVX-512 intrinsics, a 64-bit …\nThe <code>__mmask8</code> type used in AVX-512 intrinsics, a 8-bit …\nReads the current value of the processor’s time-stamp …\nAdds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nAdds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nBitwise logical <code>AND</code> of inverted <code>a</code> with <code>b</code>.\nExtracts bits of <code>a</code> specified by <code>control</code> into the least …\nExtracts bits in range [<code>start</code>, <code>start</code> + <code>length</code>) from <code>a</code> into …\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>.\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nClears all bits below the least significant zero bit of <code>x</code>.\nClears all bits below the least significant zero bit of <code>x</code>.\nSets all bits of <code>x</code> to 1 except for the least significant …\nSets all bits of <code>x</code> to 1 except for the least significant …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code>.\nSets the least significant zero bit of <code>x</code>.\nSets all bits of <code>x</code> below the least significant one.\nSets all bits of <code>x</code> below the least significant one.\nExtracts lowest set isolated bit.\nClears least significant bit and sets all other bits.\nClears least significant bit and sets all other bits.\nGets mask up to lowest set bit.\nResets the lowest set bit of <code>x</code>.\nReturns an integer with the reversed byte order of x\nZeroes higher bits of <code>a</code> &gt;= <code>index</code>.\nRestores the <code>XMM</code>, <code>MMX</code>, <code>MXCSR</code>, and <code>x87</code> FPU registers from …\nSaves the <code>x87</code> FPU, <code>MMX</code> technology, <code>XMM</code>, and <code>MXCSR</code> …\nAdd 32-bit masks in a and b, and store the result in k.\nAdd 64-bit masks in a and b, and store the result in k.\nCompute the bitwise AND of 16-bit masks a and b, and store …\nCompute the bitwise AND of 32-bit masks a and b, and store …\nCompute the bitwise AND of 64-bit masks a and b, and store …\nCompute the bitwise NOT of 16-bit masks a and then AND …\nCompute the bitwise NOT of 32-bit masks a and then AND …\nCompute the bitwise NOT of 64-bit masks a and then AND …\nCompute the bitwise NOT of 16-bit mask a, and store the …\nCompute the bitwise NOT of 32-bit mask a, and store the …\nCompute the bitwise NOT of 64-bit mask a, and store the …\nCompute the bitwise OR of 16-bit masks a and b, and store …\nCompute the bitwise OR of 32-bit masks a and b, and store …\nCompute the bitwise OR of 64-bit masks a and b, and store …\nCompute the bitwise XNOR of 16-bit masks a and b, and …\nCompute the bitwise XNOR of 32-bit masks a and b, and …\nCompute the bitwise XNOR of 64-bit masks a and b, and …\nCompute the bitwise XOR of 16-bit masks a and b, and store …\nCompute the bitwise XOR of 32-bit masks a and b, and store …\nCompute the bitwise XOR of 64-bit masks a and b, and store …\nLoad 32-bit mask from memory into k.\nLoad 64-bit mask from memory into k.\nCounts the leading most significant zero bits.\nComputes the absolute values of packed 16-bit integers in <code>a</code>…\nComputes the absolute values of packed 32-bit integers in <code>a</code>…\nCompute the absolute value of packed signed 64-bit …\nComputes the absolute values of packed 8-bit integers in <code>a</code>.\nAdds packed 16-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 32-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 64-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 8-bit integers in <code>a</code> and <code>b</code>.\nAdds packed double-precision (64-bit) floating-point …\nAdds packed single-precision (32-bit) floating-point …\nAdds packed 16-bit integers in <code>a</code> and <code>b</code> using saturation.\nAdds packed 8-bit integers in <code>a</code> and <code>b</code> using saturation.\nAdds packed unsigned 16-bit integers in <code>a</code> and <code>b</code> using …\nAdds packed unsigned 8-bit integers in <code>a</code> and <code>b</code> using …\nAlternatively adds and subtracts packed double-precision …\nAlternatively adds and subtracts packed single-precision …\nPerforms one round of an AES decryption flow on each …\nPerforms the last round of an AES decryption flow on each …\nPerforms one round of an AES encryption flow on each …\nPerforms the last round of an AES encryption flow on each …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenates pairs of 16-byte blocks in <code>a</code> and <code>b</code> into a …\nComputes the bitwise AND of a packed double-precision …\nComputes the bitwise AND of packed single-precision …\nComputes the bitwise AND of 256 bits (representing integer …\nComputes the bitwise NOT of packed double-precision …\nComputes the bitwise NOT of packed single-precision …\nComputes the bitwise NOT of 256 bits (representing integer …\nAverages packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.\nAverages packed unsigned 8-bit integers in <code>a</code> and <code>b</code>.\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlends packed 16-bit integers from <code>a</code> and <code>b</code> using control …\nBlends packed 32-bit integers from <code>a</code> and <code>b</code> using control …\nBlends packed double-precision (64-bit) floating-point …\nBlends packed single-precision (32-bit) floating-point …\nBlends packed 8-bit integers from <code>a</code> and <code>b</code> using <code>mask</code>.\nBlends packed double-precision (64-bit) floating-point …\nBlends packed single-precision (32-bit) floating-point …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcasts 128 bits from memory (composed of 2 packed …\nBroadcasts 128 bits from memory (composed of 4 packed …\nBroadcasts a double-precision (64-bit) floating-point …\nBroadcasts a single-precision (32-bit) floating-point …\nBroadcasts the low packed 8-bit integer from <code>a</code> to all …\nBroadcasts the low packed 32-bit integer from <code>a</code> to all …\nBroadcast the low 8-bits from input mask k to all 64-bit …\nBroadcast the low 16-bits from input mask k to all 32-bit …\nBroadcasts the low packed 64-bit integer from <code>a</code> to all …\nBroadcasts the low double-precision (64-bit) …\nBroadcasts 128 bits of integer data from a to all 128-bit …\nBroadcasts the low single-precision (32-bit) …\nBroadcasts the low packed 16-bit integer from a to all …\nShifts 128-bit lanes in <code>a</code> left by <code>imm8</code> bytes while …\nShifts 128-bit lanes in <code>a</code> right by <code>imm8</code> bytes while …\nCasts vector of type __m128d to type __m256d; the upper …\nCasts vector of type __m256d to type __m128d.\nCast vector of type __m256d to type __m256.\nCasts vector of type __m256d to type __m256i.\nCasts vector of type __m128 to type __m256; the upper 128 …\nCasts vector of type __m256 to type __m128.\nCast vector of type __m256 to type __m256d.\nCasts vector of type __m256 to type __m256i.\nCasts vector of type __m128i to type __m256i; the upper …\nCasts vector of type __m256i to type __m256d.\nCasts vector of type __m256i to type __m256.\nCasts vector of type __m256i to type __m128i.\nRounds packed double-precision (64-bit) floating point …\nRounds packed single-precision (32-bit) floating point …\nPerforms a carry-less multiplication of two 64-bit …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompares packed double-precision (64-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompares packed single-precision (32-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed 32-bit integers in a and b for equality, …\nCompares packed 64-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed 64-bit integers in a and b for equality, …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 32-bit integers in a and b for …\nCompares packed 64-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 64-bit integers in a and b for …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for greater-than.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nSign-extend 16-bit integers to 32-bit integers.\nSign-extend 16-bit integers to 64-bit integers.\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign-extend 32-bit integers to 64-bit integers.\nConvert packed 32-bit integers in a to packed 8-bit …\nConverts packed 32-bit integers in <code>a</code> to packed …\nConverts packed 32-bit integers in <code>a</code> to packed …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign-extend 8-bit integers to 16-bit integers.\nSign-extend 8-bit integers to 32-bit integers.\nSign-extend 8-bit integers to 64-bit integers.\nZeroes extend packed unsigned 16-bit integers in <code>a</code> to …\nZero-extend the lower four unsigned 16-bit integers in <code>a</code> …\nZero-extend unsigned 32-bit integers in <code>a</code> to 64-bit …\nConvert packed unsigned 32-bit integers in a to packed …\nZero-extend unsigned 8-bit integers in <code>a</code> to 16-bit …\nZero-extend the lower eight unsigned 8-bit integers in <code>a</code> …\nZero-extend the lower four unsigned 8-bit integers in <code>a</code> to …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConverts packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConverts packed double-precision (64-bit) floating-point …\nConverts the 8 x 16-bit half-precision float values in the …\nConverts packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConverts packed single-precision (32-bit) floating-point …\nConverts the 8 x 32-bit float values in the 256-bit vector …\nReturns the first element of the input vector of …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nReturns the first element of the input vector of <code>[8 x i32]</code>.\nReturns the first element of the input vector of …\nConverts packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConverts packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nComputes the division of each of the 4 packed 64-bit …\nComputes the division of each of the 8 packed 32-bit …\nConditionally multiplies the packed single-precision …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nExtracts a 16-bit integer from <code>a</code>, selected with <code>INDEX</code>. …\nExtracts a 32-bit integer from <code>a</code>, selected with <code>INDEX</code>.\nExtracts an 8-bit integer from <code>a</code>, selected with <code>INDEX</code>. …\nExtracts 128 bits (composed of 2 packed double-precision …\nExtracts 128 bits (composed of 4 packed single-precision …\nExtracts 128 bits (composed of integer data) from <code>a</code>, …\nExtract 128 bits (composed of 4 packed single-precision …\nExtracts 128 bits (of integer data) from <code>a</code> selected with …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nRounds packed double-precision (64-bit) floating point …\nRounds packed single-precision (32-bit) floating point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nHorizontally adds adjacent pairs of 16-bit integers in <code>a</code> …\nHorizontally adds adjacent pairs of 32-bit integers in <code>a</code> …\nHorizontal addition of adjacent pairs in the two packed …\nHorizontal addition of adjacent pairs in the two packed …\nHorizontally adds adjacent pairs of 16-bit integers in <code>a</code> …\nHorizontally subtract adjacent pairs of 16-bit integers in …\nHorizontally subtract adjacent pairs of 32-bit integers in …\nHorizontal subtraction of adjacent pairs in the two packed …\nHorizontal subtraction of adjacent pairs in the two packed …\nHorizontally subtract adjacent pairs of 16-bit integers in …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nScatter 64-bit integers from a into memory using 32-bit …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nCopies <code>a</code> to result, and inserts the 16-bit integer <code>i</code> into …\nCopies <code>a</code> to result, and inserts the 32-bit integer <code>i</code> into …\nCopies <code>a</code> to result, and inserts the 8-bit integer <code>i</code> into …\nCopies <code>a</code> to result, then inserts 128 bits (composed of 2 …\nCopies <code>a</code> to result, then inserts 128 bits (composed of 4 …\nCopies <code>a</code> to result, then inserts 128 bits from <code>b</code> into …\nCopy a to dst, then insert 128 bits (composed of 4 packed …\nCopies <code>a</code> to <code>dst</code>, then insert 128 bits (of integer data) …\nCopy a to dst, then insert 128 bits (composed of 4 packed …\nLoads 256-bits of integer data from unaligned memory into …\nLoad 256-bits (composed of 8 packed 32-bit integers) from …\nLoad 256-bits (composed of 4 packed 64-bit integers) from …\nLoads 256-bits (composed of 4 packed double-precision …\nLoads 256-bits (composed of 8 packed single-precision …\nLoads 256-bits of integer data from memory into result. …\nLoads two 128-bit values (composed of 4 packed …\nLoads two 128-bit values (composed of 2 packed …\nLoads two 128-bit values (composed of integer data) from …\nLoad 256-bits (composed of 16 packed 16-bit integers) from …\nLoad 256-bits (composed of 8 packed 32-bit integers) from …\nLoad 256-bits (composed of 4 packed 64-bit integers) from …\nLoad 256-bits (composed of 32 packed 8-bit integers) from …\nLoads 256-bits (composed of 4 packed double-precision …\nLoads 256-bits (composed of 8 packed single-precision …\nLoads 256-bits of integer data from memory into result. …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiplies packed signed 16-bit integers in <code>a</code> and <code>b</code>, …\nVertically multiplies each unsigned 8-bit integer from <code>a</code> …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nCompute the absolute value of packed signed 16-bit …\nCompute the absolute value of packed signed 32-bit …\nCompute the absolute value of packed signed 64-bit …\nCompute the absolute value of packed signed 8-bit integers …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate pairs of 16-byte blocks in a and b into a …\nPerforms element-by-element bitwise AND between packed …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlend packed 16-bit integers from a and b using control …\nBlend packed 32-bit integers from a and b using control …\nBlend packed 64-bit integers from a and b using control …\nBlend packed 8-bit integers from a and b using control …\nBlend packed double-precision (64-bit) floating-point …\nBlend packed single-precision (32-bit) floating-point …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low double-precision (64-bit) floating-point …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for equality, …\nCompare packed 64-bit integers in a and b for equality, …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 32-bit integers in a to packed 16-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 4 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in the low 8 …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 8 …\nZero extend packed unsigned 8-bit integers in the low 4 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active single-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nExtract 128 bits (composed of 4 packed single-precision …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using …\nMove packed 32-bit integers from a to dst using writemask …\nMove packed 64-bit integers from a to dst using writemask …\nMove packed 8-bit integers from a into dst using writemask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast 16-bit integer a to all elements of dst using …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle 8-bit integers in a within 128-bit lanes using the …\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nStore packed 16-bit integers from a into memory using …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed 8-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nLoads packed 32-bit integers from memory pointed by …\nLoads packed 64-bit integers from memory pointed by …\nLoads packed double-precision (64-bit) floating-point …\nLoads packed single-precision (32-bit) floating-point …\nStores packed 32-bit integers from <code>a</code> into memory pointed …\nStores packed 64-bit integers from <code>a</code> into memory pointed …\nStores packed double-precision (64-bit) floating-point …\nStores packed single-precision (32-bit) floating-point …\nCompute the absolute value of packed signed 16-bit …\nCompute the absolute value of packed signed 32-bit …\nCompute the absolute value of packed signed 64-bit …\nCompute the absolute value of packed signed 8-bit integers …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate pairs of 16-byte blocks in a and b into a …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low double-precision (64-bit) floating-point …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 4 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in the low 8 …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 8 …\nZero extend packed unsigned 8-bit integers in the low 4 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active single-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nExtract 128 bits (composed of 4 packed single-precision …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using zeromask …\nMove packed 32-bit integers from a into dst using zeromask …\nMove packed 64-bit integers from a into dst using zeromask …\nMove packed 8-bit integers from a into dst using zeromask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle packed 8-bit integers in a according to shuffle …\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompare packed signed 64-bit integers in a and b, and …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code>, and returns the …\nCompares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed double-precision (64-bit) floating-point …\nCompares packed single-precision (32-bit) floating-point …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompare packed signed 64-bit integers in a and b, and …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code>, and returns the …\nCompares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed double-precision (64-bit) floating-point …\nCompares packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nCreates mask from the most significant bit of each 8-bit …\nSets each bit of the returned mask based on the most …\nSets each bit of the returned mask based on the most …\nSet each bit of mask register k based on the most …\nSet each bit of mask register k based on the most …\nSet each packed 16-bit integer in dst to all ones or all …\nSet each packed 8-bit integer in dst to all ones or all …\nComputes the sum of absolute differences (SADs) of …\nMultiplies the low 32-bit integers from each packed 64-bit …\nMultiplies the low unsigned 32-bit integers from each …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies the packed 16-bit integers in <code>a</code> and <code>b</code>, producing\nMultiplies the packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, …\nMultiplies packed 16-bit integers in <code>a</code> and <code>b</code>, producing …\nMultiplies the packed 16-bit integers in <code>a</code> and <code>b</code>, producing\nMultiplies the packed 32-bit integers in <code>a</code> and <code>b</code>, producing\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nComputes the bitwise OR packed double-precision (64-bit) …\nComputes the bitwise OR packed single-precision (32-bit) …\nComputes the bitwise OR of 256 bits (representing integer …\nConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed …\nShuffles 256 bits (composed of 4 packed double-precision …\nShuffles 256 bits (composed of 8 packed single-precision …\nShuffles 128-bits (composed of integer data) selected by …\nShuffles 128-bits of integer data selected by <code>imm8</code> from <code>a</code> …\nPermutes 64-bit integers from <code>a</code> using control mask <code>imm8</code>.\nShuffles 64-bit floating-point elements in <code>a</code> across lanes …\nShuffles double-precision (64-bit) floating-point elements …\nShuffles single-precision (32-bit) floating-point elements …\nPermutes packed 32-bit integers from <code>a</code> according to the …\nShuffles eight 32-bit floating-point elements in <code>a</code> across …\nShuffles double-precision (64-bit) floating-point elements …\nShuffles single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nComputes the approximate reciprocal of packed …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRounds packed double-precision (64-bit) floating point …\nRounds packed single-precision (32-bit) floating point …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nComputes the approximate reciprocal square root of packed …\nComputes the absolute differences of packed unsigned 8-bit …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcasts 16-bit integer <code>a</code> to all elements of returned …\nBroadcasts 32-bit integer <code>a</code> to all elements of returned …\nBroadcasts 64-bit integer <code>a</code> to all elements of returned …\nBroadcasts 8-bit integer <code>a</code> to all elements of returned …\nBroadcasts double-precision (64-bit) floating-point value <code>a</code>…\nBroadcasts single-precision (32-bit) floating-point value <code>a</code>…\nSets packed 16-bit integers in returned vector with the …\nSets packed 32-bit integers in returned vector with the …\nSets packed 64-bit integers in returned vector with the …\nSets packed 8-bit integers in returned vector with the …\nSets packed __m256 returned vector with the supplied …\nSets packed __m256d returned vector with the supplied …\nSets packed __m256i returned vector with the supplied …\nSets packed double-precision (64-bit) floating-point …\nSets packed single-precision (32-bit) floating-point …\nSets packed 16-bit integers in returned vector with the …\nSets packed 32-bit integers in returned vector with the …\nSets packed 64-bit integers in returned vector with the …\nSets packed 8-bit integers in returned vector with the …\nSets packed __m256 returned vector with the supplied …\nSets packed __m256d returned vector with the supplied …\nSets packed __m256i returned vector with the supplied …\nSets packed double-precision (64-bit) floating-point …\nSets packed single-precision (32-bit) floating-point …\nReturns vector of type __m256d with all elements set to …\nReturns vector of type __m256 with all elements set to …\nReturns vector of type __m256i with all elements set to …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffles 32-bit integers in 128-bit lanes of <code>a</code> using the …\nShuffles bytes from <code>a</code> according to the content of <code>b</code>.\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffles double-precision (64-bit) floating-point elements …\nShuffles single-precision (32-bit) floating-point elements …\nShuffles 16-bit integers in the high 64 bits of 128-bit …\nShuffles 16-bit integers in the low 64 bits of 128-bit …\nNegates packed 16-bit integers in <code>a</code> when the corresponding …\nNegates packed 32-bit integers in <code>a</code> when the corresponding …\nNegates packed 8-bit integers in <code>a</code> when the corresponding …\nShifts packed 16-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 64-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 16-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts packed 64-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts 128-bit lanes in <code>a</code> left by <code>imm8</code> bytes while …\nShift packed 16-bit integers in a left by the amount …\nShifts packed 32-bit integers in <code>a</code> left by the amount …\nShifts packed 64-bit integers in <code>a</code> left by the amount …\nReturns the square root of packed double-precision …\nReturns the square root of packed single-precision …\nShifts packed 16-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>count</code> while …\nShift packed 64-bit integers in a right by count while …\nShifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShifts packed 32-bit integers in <code>a</code> right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShifts packed 16-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 64-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 64-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts 128-bit lanes in <code>a</code> right by <code>imm8</code> bytes while …\nShift packed 16-bit integers in a right by the amount …\nShifts packed 32-bit integers in <code>a</code> right by the amount …\nShifts packed 64-bit integers in <code>a</code> right by the amount …\nStore 256-bits (composed of 8 packed 32-bit integers) from …\nStore 256-bits (composed of 4 packed 64-bit integers) from …\nStores 256-bits (composed of 4 packed double-precision …\nStores 256-bits (composed of 8 packed single-precision …\nStores 256-bits of integer data from <code>a</code> into memory. …\nStores the high and low 128-bit halves (each composed of 4 …\nStores the high and low 128-bit halves (each composed of 2 …\nStores the high and low 128-bit halves (each composed of …\nStore 256-bits (composed of 16 packed 16-bit integers) …\nStore 256-bits (composed of 8 packed 32-bit integers) from …\nStore 256-bits (composed of 4 packed 64-bit integers) from …\nStore 256-bits (composed of 32 packed 8-bit integers) from …\nStores 256-bits (composed of 4 packed double-precision …\nStores 256-bits (composed of 8 packed single-precision …\nStores 256-bits of integer data from <code>a</code> into memory. …\nMoves double-precision values from a 256-bit vector of …\nMoves single-precision floating point values from a …\nMoves integer data from a 256-bit integer vector to a …\nSubtract packed 16-bit integers in <code>b</code> from packed 16-bit …\nSubtract packed 32-bit integers in <code>b</code> from packed 32-bit …\nSubtract packed 64-bit integers in <code>b</code> from packed 64-bit …\nSubtract packed 8-bit integers in <code>b</code> from packed 8-bit …\nSubtracts packed double-precision (64-bit) floating-point …\nSubtracts packed single-precision (32-bit) floating-point …\nSubtract packed 16-bit integers in <code>b</code> from packed 16-bit …\nSubtract packed 8-bit integers in <code>b</code> from packed 8-bit …\nSubtract packed unsigned 16-bit integers in <code>b</code> from packed …\nSubtract packed unsigned 8-bit integers in <code>b</code> from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing integer …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing integer …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing integer …\nReturns vector of type <code>__m256d</code> with indeterminate elements.\nReturns vector of type <code>__m256</code> with indeterminate elements. …\nReturns vector of type __m256i with with indeterminate …\nUnpacks and interleave 16-bit integers from the high half …\nUnpacks and interleave 32-bit integers from the high half …\nUnpacks and interleave 64-bit integers from the high half …\nUnpacks and interleave 8-bit integers from the high half …\nUnpacks and interleave double-precision (64-bit) …\nUnpacks and interleave single-precision (32-bit) …\nUnpacks and interleave 16-bit integers from the low half …\nUnpacks and interleave 32-bit integers from the low half …\nUnpacks and interleave 64-bit integers from the low half …\nUnpacks and interleave 8-bit integers from the low half of …\nUnpacks and interleave double-precision (64-bit) …\nUnpacks and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nComputes the bitwise XOR of packed double-precision …\nComputes the bitwise XOR of packed single-precision …\nComputes the bitwise XOR of 256 bits (representing integer …\nZeroes the contents of all XMM or YMM registers.\nZeroes the upper 128 bits of all YMM registers; the lower …\nConstructs a 256-bit floating-point vector of <code>[4 x double]</code> …\nConstructs a 256-bit floating-point vector of <code>[8 x float]</code> …\nConstructs a 256-bit integer vector from a 128-bit integer …\nCompute the absolute value of packed signed 16-bit …\nComputes the absolute values of packed 32-bit integers in <code>a</code>…\nCompute the absolute value of packed signed 64-bit …\nCompute the absolute value of packed signed 8-bit integers …\nFinds the absolute value of each packed double-precision …\nFinds the absolute value of each packed single-precision …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nPerforms one round of an AES decryption flow on each …\nPerforms the last round of an AES decryption flow on each …\nPerforms one round of an AES encryption flow on each …\nPerforms the last round of an AES encryption flow on each …\nConcatenate a and b into a 128-byte immediate result, …\nConcatenate a and b into a 128-byte immediate result, …\nConcatenate pairs of 16-byte blocks in a and b into a …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of 512 bits (composed of packed …\nCompute the bitwise AND of 512 bits (representing integer …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of 512 bits (composed of packed …\nCompute the bitwise NOT of 512 bits (representing integer …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed double-precision (64-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcast the 4 packed 64-bit integers from a to all …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low 8-bits from input mask k to all 64-bit …\nBroadcast the low 16-bits from input mask k to all 32-bit …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low double-precision (64-bit) floating-point …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nShift 128-bit lanes in a left by imm8 bytes while shifting …\nShift 128-bit lanes in a right by imm8 bytes while …\nCast vector of type __m128d to type __m512d; the upper 384 …\nCast vector of type __m256d to type __m512d; the upper 256 …\nCast vector of type __m512d to type __m128d. This …\nCast vector of type __m512d to type __m256d. This …\nCast vector of type __m512d to type __m512. This intrinsic …\nCast vector of type __m512d to type __m512i. This …\nCast vector of type __m128 to type __m512; the upper 384 …\nCast vector of type __m256 to type __m512; the upper 256 …\nCast vector of type __m512 to type __m128. This intrinsic …\nCast vector of type __m512 to type __m256. This intrinsic …\nCast vector of type __m512 to type __m512d. This intrinsic …\nCast vector of type __m512 to type __m512i. This intrinsic …\nCast vector of type __m128i to type __m512i; the upper 384 …\nCast vector of type __m256i to type __m512i; the upper 256 …\nCast vector of type __m512i to type __m512d. This …\nCast vector of type __m512i to type __m512. This intrinsic …\nCast vector of type __m512i to type __m128i. This …\nCast vector of type __m512i to type __m256i. This …\nPerforms a carry-less multiplication of two 64-bit …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for equality, …\nCompare packed 64-bit integers in a and b for equality, …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nPerforms element-by-element conversion of the lower half …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 8 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nPerforms element-by-element conversion of the lower half …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 8 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nPerforms an element-by-element conversion of packed …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nPerforms element-by-element conversion of the lower half …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nCopy the lower 32-bit integer in a to dst.\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nExtract 128 bits (composed of 4 packed single-precision …\nExtract 256 bits (composed of 4 packed double-precision …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nExtract 256 bits (composed of 4 packed 64-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nGather 32-bit integers from memory using 32-bit indices. …\nGather 64-bit integers from memory using 32-bit indices. …\nGather double-precision (64-bit) floating-point elements …\nGather single-precision (32-bit) floating-point elements …\nScatter 32-bit integers from a into memory using 32-bit …\nScatter 64-bit integers from a into memory using 32-bit …\nScatter double-precision (64-bit) floating-point elements …\nScatter single-precision (32-bit) floating-point elements …\nGather 32-bit integers from memory using 64-bit indices. …\nGather 64-bit integers from memory using 64-bit indices. …\nGather double-precision (64-bit) floating-point elements …\nGather single-precision (32-bit) floating-point elements …\nScatter 32-bit integers from a into memory using 64-bit …\nScatter 64-bit integers from a into memory using 64-bit …\nScatter double-precision (64-bit) floating-point elements …\nScatter single-precision (32-bit) floating-point elements …\nCopy a to dst, then insert 128 bits (composed of 4 packed …\nCopy a to dst, then insert 256 bits (composed of 4 packed …\nCopy a to dst, then insert 128 bits (composed of 4 packed …\nCopy a to dst, then insert 256 bits (composed of 4 packed …\nConverts integer mask into bitmask, storing the result in …\nCompute the bitwise AND of 16-bit masks a and b, and store …\nCompute the bitwise NOT of 16-bit masks a and then AND …\nCopy 16-bit mask a to k.\nCompute the bitwise NOT of 16-bit mask a, and store the …\nCompute the bitwise OR of 16-bit masks a and b, and store …\nPerforms bitwise OR between k1 and k2, storing the result …\nUnpack and interleave 8 bits from masks a and b, and store …\nCompute the bitwise XNOR of 16-bit masks a and b, and …\nCompute the bitwise XOR of 16-bit masks a and b, and store …\nLoad 512-bits (composed of 16 packed 32-bit integers) from …\nLoad 512-bits (composed of 8 packed 64-bit integers) from …\nLoad 512-bits (composed of 8 packed double-precision …\nLoad 512-bits (composed of 16 packed single-precision …\nLoad 512-bits of integer data from memory into dst. …\nLoad 512-bits (composed of 32 packed 16-bit integers) from …\nLoad 512-bits (composed of 16 packed 32-bit integers) from …\nLoad 512-bits (composed of 8 packed 64-bit integers) from …\nLoad 512-bits (composed of 64 packed 8-bit integers) from …\nLoads 512-bits (composed of 8 packed double-precision …\nLoads 512-bits (composed of 16 packed single-precision …\nLoad 512-bits of integer data from memory into dst. …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiply packed signed 16-bit integers in a and b, …\nVertically multiply each unsigned 8-bit integer from a …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nConverts bit mask k1 into an integer value, storing the …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nCompute the absolute value of packed signed 16-bit …\nComputes the absolute value of packed 32-bit integers in <code>a</code>…\nCompute the absolute value of packed signed 64-bit …\nCompute the absolute value of packed signed 8-bit integers …\nFinds the absolute value of each packed double-precision …\nFinds the absolute value of each packed single-precision …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 128-byte immediate result, …\nConcatenate a and b into a 128-byte immediate result, …\nConcatenate pairs of 16-byte blocks in a and b into a …\nPerforms element-by-element bitwise AND between packed …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlend packed 16-bit integers from a and b using control …\nBlend packed 32-bit integers from a and b using control …\nBlend packed 64-bit integers from a and b using control …\nBlend packed 8-bit integers from a and b using control …\nBlend packed double-precision (64-bit) floating-point …\nBlend packed single-precision (32-bit) floating-point …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed double-precision (64-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcast the 4 packed 64-bit integers from a to all …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low double-precision (64-bit) floating-point …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for equality, …\nCompare packed 64-bit integers in a and b for equality, …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 32-bit integers in a to packed 16-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nPerforms element-by-element conversion of the lower half …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 8 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nPerforms element-by-element conversion of the lower half …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 8 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nPerforms an element-by-element conversion of packed …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nPerforms element-by-element conversion of the lower half …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active single-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nExtract 128 bits (composed of 4 packed single-precision …\nExtract 256 bits (composed of 4 packed double-precision …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nExtract 256 bits (composed of 4 packed 64-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nGather 32-bit integers from memory using 32-bit indices. …\nGather 64-bit integers from memory using 32-bit indices. …\nGather double-precision (64-bit) floating-point elements …\nGather single-precision (32-bit) floating-point elements …\nScatter 32-bit integers from a into memory using 32-bit …\nScatter 64-bit integers from a into memory using 32-bit …\nScatter double-precision (64-bit) floating-point elements …\nScatter single-precision (32-bit) floating-point elements …\nGather 32-bit integers from memory using 64-bit indices. …\nGather 64-bit integers from memory using 64-bit indices. …\nGather double-precision (64-bit) floating-point elements …\nGather single-precision (32-bit) floating-point elements …\nScatter 32-bit integers from a into memory using 64-bit …\nScatter 64-bit integers from a into memory using 64-bit …\nScatter double-precision (64-bit) floating-point elements …\nScatter single-precision (32-bit) floating-point elements …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nCopy a to tmp, then insert 256 bits (composed of 4 packed …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nCopy a to tmp, then insert 256 bits (composed of 4 packed …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using …\nMove packed 32-bit integers from a to dst using writemask …\nMove packed 64-bit integers from a to dst using writemask …\nMove packed 8-bit integers from a into dst using writemask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nMultiplies elements in packed 64-bit integer vectors a and …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 32-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nReduce the packed 32-bit integers in a by addition using …\nReduce the packed 64-bit integers in a by addition using …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by bitwise AND …\nReduce the packed 64-bit integers in a by addition using …\nReduce the packed signed 32-bit integers in a by maximum …\nReduce the packed signed 64-bit integers in a by maximum …\nReduce the packed unsigned 32-bit integers in a by maximum …\nReduce the packed unsigned 64-bit integers in a by maximum …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed signed 32-bit integers in a by maximum …\nReduce the packed signed 64-bit integers in a by maximum …\nReduce the packed unsigned 32-bit integers in a by maximum …\nReduce the packed signed 64-bit integers in a by maximum …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by multiplication …\nReduce the packed 64-bit integers in a by multiplication …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by bitwise OR using …\nReduce the packed 64-bit integers in a by bitwise OR using …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast 16-bit integer a to all elements of dst using …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle 8-bit integers in a within 128-bit lanes using the …\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nStore packed 16-bit integers from a into memory using …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed 8-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nCompute the absolute value of packed signed 16-bit …\nComputes the absolute value of packed 32-bit integers in <code>a</code>…\nCompute the absolute value of packed signed 64-bit …\nCompute the absolute value of packed signed 8-bit integers …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 128-byte immediate result, …\nConcatenate a and b into a 128-byte immediate result, …\nConcatenate pairs of 16-byte blocks in a and b into a …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed double-precision (64-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcast the 4 packed 64-bit integers from a to all …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low double-precision (64-bit) floating-point …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 8 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 8 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active single-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nExtract 128 bits (composed of 4 packed single-precision …\nExtract 256 bits (composed of 4 packed double-precision …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nExtract 256 bits (composed of 4 packed 64-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nCopy a to tmp, then insert 256 bits (composed of 4 packed …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nCopy a to tmp, then insert 256 bits (composed of 4 packed …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using zeromask …\nMove packed 32-bit integers from a into dst using zeromask …\nMove packed 64-bit integers from a into dst using zeromask …\nMove packed 8-bit integers from a into dst using zeromask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle packed 8-bit integers in a according to shuffle …\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nSet each bit of mask register k based on the most …\nSet each bit of mask register k based on the most …\nSet each packed 16-bit integer in dst to all ones or all …\nSet each packed 8-bit integer in dst to all ones or all …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nMultiplies elements in packed 64-bit integer vectors a and …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nCompute the bitwise OR of 512 bits (representing integer …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 32-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nReduce the packed 32-bit integers in a by addition. …\nReduce the packed 64-bit integers in a by addition. …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by bitwise AND. …\nReduce the packed 64-bit integers in a by bitwise AND. …\nReduce the packed signed 32-bit integers in a by maximum. …\nReduce the packed signed 64-bit integers in a by maximum. …\nReduce the packed unsigned 32-bit integers in a by …\nReduce the packed unsigned 64-bit integers in a by …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed signed 32-bit integers in a by minimum. …\nReduce the packed signed 64-bit integers in a by minimum. …\nReduce the packed unsigned 32-bit integers in a by …\nReduce the packed unsigned 64-bit integers in a by …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by multiplication. …\nReduce the packed 64-bit integers in a by multiplication. …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by bitwise OR. …\nReduce the packed 64-bit integers in a by bitwise OR. …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nCompute the absolute differences of packed unsigned 8-bit …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nBroadcast 32-bit integer <code>a</code> to all elements of <code>dst</code>.\nBroadcast 64-bit integer <code>a</code> to all elements of <code>dst</code>.\nBroadcast 8-bit integer a to all elements of dst.\nBroadcast 64-bit float <code>a</code> to all elements of <code>dst</code>.\nBroadcast 32-bit float <code>a</code> to all elements of <code>dst</code>.\nSet packed 32-bit integers in dst with the repeated 4 …\nSet packed 64-bit integers in dst with the repeated 4 …\nSet packed double-precision (64-bit) floating-point …\nSet packed single-precision (32-bit) floating-point …\nSet packed 16-bit integers in dst with the supplied values.\nSets packed 32-bit integers in <code>dst</code> with the supplied …\nSet packed 64-bit integers in dst with the supplied values.\nSet packed 8-bit integers in dst with the supplied values.\nSet packed double-precision (64-bit) floating-point …\nSets packed 32-bit integers in <code>dst</code> with the supplied …\nSet packed 32-bit integers in dst with the repeated 4 …\nSet packed 64-bit integers in dst with the repeated 4 …\nSet packed double-precision (64-bit) floating-point …\nSet packed single-precision (32-bit) floating-point …\nSets packed 32-bit integers in <code>dst</code> with the supplied …\nSet packed 64-bit integers in dst with the supplied values …\nSet packed double-precision (64-bit) floating-point …\nSets packed 32-bit integers in <code>dst</code> with the supplied …\nReturn vector of type __m512 with all elements set to zero.\nReturn vector of type __m512i with all elements set to …\nReturns vector of type <code>__m512d</code> with all elements set to …\nReturns vector of type <code>__m512d</code> with all elements set to …\nReturns vector of type <code>__m512i</code> with all elements set to …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle packed 8-bit integers in a according to shuffle …\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nStore 512-bits (composed of 16 packed 32-bit integers) …\nStore 512-bits (composed of 8 packed 64-bit integers) from …\nStore 512-bits (composed of 8 packed double-precision …\nStore 512-bits of integer data from a into memory. …\nStore 512-bits of integer data from a into memory. …\nStore 512-bits (composed of 32 packed 16-bit integers) …\nStore 512-bits (composed of 16 packed 32-bit integers) …\nStore 512-bits (composed of 8 packed 64-bit integers) from …\nStore 512-bits (composed of 64 packed 8-bit integers) from …\nStores 512-bits (composed of 8 packed double-precision …\nStores 512-bits (composed of 16 packed single-precision …\nStore 512-bits of integer data from a into memory. …\nStore 512-bits (composed of 8 packed double-precision …\nStore 512-bits (composed of 16 packed single-precision …\nStore 512-bits of integer data from a into memory using a …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nReturn vector of type __m512 with indeterminate elements. …\nReturn vector of type __m512i with indeterminate elements. …\nReturns vector of type <code>__m512d</code> with indeterminate elements.\nReturns vector of type <code>__m512</code> with indeterminate elements. …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nCompute the bitwise XOR of 512 bits (representing integer …\nCast vector of type __m128d to type __m512d; the upper 384 …\nCast vector of type __m256d to type __m512d; the upper 256 …\nCast vector of type __m128 to type __m512; the upper 384 …\nCast vector of type __m256 to type __m512; the upper 256 …\nCast vector of type __m128i to type __m512i; the upper 384 …\nCast vector of type __m256i to type __m512i; the upper 256 …\nComputes the absolute value of each of the packed 16-bit …\nComputes the absolute value of each of the packed 32-bit …\nComputes the absolute value of packed 8-bit signed …\nAdds packed 16-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 32-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 64-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 8-bit integers in <code>a</code> and <code>b</code>.\nAdds packed double-precision (64-bit) floating-point …\nAdds __m128 vectors.\nAdd the lower double-precision (64-bit) floating-point …\nAdd the lower single-precision (32-bit) floating-point …\nReturns a new vector with the low element of <code>a</code> replaced by …\nAdds the first component of <code>a</code> and <code>b</code>, the other components …\nAdds packed 16-bit integers in <code>a</code> and <code>b</code> using saturation.\nAdds packed 8-bit integers in <code>a</code> and <code>b</code> using saturation.\nAdds packed unsigned 16-bit integers in <code>a</code> and <code>b</code> using …\nAdds packed unsigned 8-bit integers in <code>a</code> and <code>b</code> using …\nAlternatively add and subtract packed double-precision …\nAlternatively add and subtract packed single-precision …\nPerforms one round of an AES decryption flow on data …\nPerforms the last round of an AES decryption flow on data …\nPerforms one round of an AES encryption flow on data …\nPerforms the last round of an AES encryption flow on data …\nPerforms the <code>InvMixColumns</code> transformation on <code>a</code>.\nAssist in expanding the AES cipher key.\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate 16-byte blocks in <code>a</code> and <code>b</code> into a 32-byte …\nComputes the bitwise AND of packed double-precision …\nBitwise AND of packed single-precision (32-bit) …\nComputes the bitwise AND of 128 bits (representing integer …\nComputes the bitwise NOT of <code>a</code> and then AND with <code>b</code>.\nBitwise AND-NOT of packed single-precision (32-bit) …\nComputes the bitwise NOT of 128 bits (representing integer …\nAverages packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.\nAverages packed unsigned 8-bit integers in <code>a</code> and <code>b</code>.\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlend packed 16-bit integers from <code>a</code> and <code>b</code> using the mask …\nBlends packed 32-bit integers from <code>a</code> and <code>b</code> using control …\nBlend packed double-precision (64-bit) floating-point …\nBlend packed single-precision (32-bit) floating-point …\nBlend packed 8-bit integers from <code>a</code> and <code>b</code> using <code>mask</code>\nBlend packed double-precision (64-bit) floating-point …\nBlend packed single-precision (32-bit) floating-point …\nBroadcasts a single-precision (32-bit) floating-point …\nBroadcasts the low packed 8-bit integer from <code>a</code> to all …\nBroadcasts the low packed 32-bit integer from <code>a</code> to all …\nBroadcast the low 8-bits from input mask k to all 64-bit …\nBroadcast the low 16-bits from input mask k to all 32-bit …\nBroadcasts the low packed 64-bit integer from <code>a</code> to all …\nBroadcasts the low double-precision (64-bit) …\nBroadcasts the low single-precision (32-bit) …\nBroadcasts the low packed 16-bit integer from a to all …\nShifts <code>a</code> left by <code>IMM8</code> bytes while shifting in zeros.\nShifts <code>a</code> right by <code>IMM8</code> bytes while shifting in zeros.\nCasts a 128-bit floating-point vector of <code>[2 x double]</code> into …\nCasts a 128-bit floating-point vector of <code>[2 x double]</code> into …\nCasts a 128-bit floating-point vector of <code>[4 x float]</code> into …\nCasts a 128-bit floating-point vector of <code>[4 x float]</code> into …\nCasts a 128-bit integer vector into a 128-bit …\nCasts a 128-bit integer vector into a 128-bit …\nRound the packed double-precision (64-bit) floating-point …\nRound the packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nInvalidates and flushes the cache line that contains <code>p</code> …\nPerforms a carry-less multiplication of two 64-bit …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompares packed double-precision (64-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompares packed single-precision (32-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompares the lower double-precision (64-bit) …\nCompare the lower double-precision (64-bit) floating-point …\nCompares the lower single-precision (32-bit) …\nCompare the lower single-precision (32-bit) floating-point …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed 32-bit integers in a and b for equality, …\nCompares packed 64-bit integers in <code>a</code> and <code>b</code> for equality\nCompare packed 64-bit integers in a and b for equality, …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for equality.\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for equality. The …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for greater than or …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 32-bit integers in a and b for …\nCompares packed 64-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 64-bit integers in a and b for …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for greater-than.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for greater than. …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for less than or …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for less-than.\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for less-than.\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for less-than.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for less-than.\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for less than. The …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for not-equal.\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for inequality. The …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for not-less-than. …\nCompares corresponding elements in <code>a</code> and <code>b</code> to see if …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nChecks if the lowest <code>f32</code> of both inputs are ordered. The …\nCompares corresponding elements in <code>a</code> and <code>b</code> to see if …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nChecks if the lowest <code>f32</code> of both inputs are unordered. The …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompares the lower element of <code>a</code> and <code>b</code> for equality.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for …\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for greater-than.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for …\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for less-than.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for not-equal.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nStarting with the initial value in <code>crc</code>, return the …\nStarting with the initial value in <code>crc</code>, return the …\nStarting with the initial value in <code>crc</code>, return the …\nConvert the signed 32-bit integer b to a single-precision …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the signed 32-bit integer b to a single-precision …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the unsigned 32-bit integer b to a …\nAlias for <code>_mm_cvtsi32_ss</code>.\nAlias for <code>_mm_cvtss_si32</code>.\nSign extend packed 16-bit integers in <code>a</code> to packed 32-bit …\nSign extend packed 16-bit integers in <code>a</code> to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in <code>a</code> to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConverts the lower two packed 32-bit integers in <code>a</code> to …\nConverts packed 32-bit integers in <code>a</code> to packed …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in <code>a</code> to packed 16-bit …\nSign extend packed 8-bit integers in <code>a</code> to packed 32-bit …\nSign extend packed 8-bit integers in the low 8 bytes of <code>a</code> …\nZeroes extend packed unsigned 16-bit integers in <code>a</code> to …\nZeroes extend packed unsigned 16-bit integers in <code>a</code> to …\nZeroes extend packed unsigned 32-bit integers in <code>a</code> to …\nConvert packed unsigned 32-bit integers in a to packed …\nZeroes extend packed unsigned 8-bit integers in <code>a</code> to …\nZeroes extend packed unsigned 8-bit integers in <code>a</code> to …\nZeroes extend packed unsigned 8-bit integers in <code>a</code> to …\nConvert the signed 32-bit integer b to a double-precision …\nConvert the signed 32-bit integer b to a single-precision …\nConvert packed single-precision (32-bit) floating-point …\nConverts packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConverts packed double-precision (64-bit) floating-point …\nConverts the 4 x 16-bit half-precision float values in the …\nConverts packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConverts packed single-precision (32-bit) floating-point …\nConverts the 4 x 32-bit float values in the 128-bit vector …\nReturns the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConverts the lower double-precision (64-bit) …\nConverts the lower double-precision (64-bit) …\nConvert the lower double-precision (64-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nReturns the lowest element of <code>a</code>.\nReturns <code>a</code> with its lower element replaced by <code>b</code> after …\nReturns a vector whose lowest element is <code>a</code> and all higher …\nConverts a 32 bit integer to a 32 bit float. The result …\nExtracts the lowest 32 bit float from the input vector.\nConvert the lower single-precision (32-bit) floating-point …\nConverts the lower single-precision (32-bit) …\nConverts the lowest 32 bit float in the input vector to a …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nAlias for <code>_mm_cvttss_si32</code>.\nConverts packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConverts packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConverts the lower double-precision (64-bit) …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConverts the lowest 32 bit float in the input vector to a …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the unsigned 32-bit integer b to a …\nConvert the unsigned 32-bit integer b to a …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivides __m128 vectors.\nDivide the lower double-precision (64-bit) floating-point …\nDivide the lower single-precision (32-bit) floating-point …\nReturns a new vector with the low element of <code>a</code> replaced by …\nDivides the first component of <code>b</code> by <code>a</code>, the other …\nReturns the dot product of two __m128d vectors.\nReturns the dot product of two __m128 vectors.\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nReturns the <code>imm8</code> element of <code>a</code>.\nExtracts an 32-bit integer from <code>a</code> selected with <code>IMM8</code>\nExtracts an 8-bit integer from <code>a</code>, selected with <code>IMM8</code>. …\nExtracts a single-precision (32-bit) floating-point …\nExtracts the bit range specified by <code>y</code> from the lower 64 …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nRound the packed double-precision (64-bit) floating-point …\nRound the packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiplies the lower double-precision (64-bit) …\nMultiplies the lower single-precision (32-bit) …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiplies the lower double-precision (64-bit) …\nMultiplies the lower single-precision (32-bit) …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiplies the lower double-precision (64-bit) …\nMultiplies the lower single-precision (32-bit) …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiplies the lower double-precision (64-bit) …\nMultiplies the lower single-precision (32-bit) …\nGets the unsigned 32-bit value of the MXCSR control and …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nHorizontally adds the adjacent pairs of values contained …\nHorizontally adds the adjacent pairs of values contained …\nHorizontally adds adjacent pairs of double-precision …\nHorizontally adds adjacent pairs of single-precision …\nHorizontally adds the adjacent pairs of values contained …\nHorizontally subtract the adjacent pairs of values …\nHorizontally subtract the adjacent pairs of values …\nHorizontally subtract adjacent pairs of double-precision …\nHorizontally adds adjacent pairs of single-precision …\nHorizontally subtract the adjacent pairs of values …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns a new vector where the <code>imm8</code> element of <code>a</code> is …\nReturns a copy of <code>a</code> with the 32-bit integer from <code>i</code> …\nReturns a copy of <code>a</code> with the 8-bit integer from <code>i</code> inserted …\nSelect a single value in <code>a</code> to store at some position in <code>b</code>, …\nInserts the <code>[length:0]</code> bits of <code>y</code> into <code>x</code> at <code>index</code>.\nLoads 128-bits of integer data from unaligned memory. This …\nPerforms a serializing operation on all load-from-memory …\nLoads a double-precision (64-bit) floating-point element …\nConstruct a <code>__m128</code> by duplicating the value read from <code>p</code> …\nLoad 128-bits (composed of 4 packed 32-bit integers) from …\nLoad 128-bits (composed of 2 packed 64-bit integers) from …\nLoads 128-bits (composed of 2 packed double-precision …\nLoads a double-precision (64-bit) floating-point element …\nLoads four <code>f32</code> values from <em>aligned</em> memory into a <code>__m128</code>. …\nAlias for <code>_mm_load1_ps</code>\nLoads a 64-bit double-precision value to the low element …\nLoads 128-bits of integer data from memory into a new …\nConstruct a <code>__m128</code> with the lowest element read from <code>p</code> and …\nLoads a double-precision (64-bit) floating-point element …\nLoads a double-precision value into the high-order bits of …\nLoads 64-bit integer from memory into first element of …\nLoads a double-precision value into the low-order bits of …\nLoads 2 double-precision (64-bit) floating-point elements …\nLoads four <code>f32</code> values from aligned memory into a <code>__m128</code> in …\nLoad 128-bits (composed of 8 packed 16-bit integers) from …\nLoad 128-bits (composed of 4 packed 32-bit integers) from …\nLoad 128-bits (composed of 2 packed 64-bit integers) from …\nLoad 128-bits (composed of 16 packed 8-bit integers) from …\nLoads 128-bits (composed of 2 packed double-precision …\nLoads four <code>f32</code> values from memory into a <code>__m128</code>. There are …\nLoads 128-bits of integer data from memory into a new …\nLoads unaligned 64-bits of integer data from memory into …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiplies and then horizontally add signed 16 bit …\nMultiplies corresponding pairs of packed 8-bit unsigned …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nCompute the absolute value of packed signed 16-bit …\nCompute the absolute value of packed signed 32-bit …\nCompute the absolute value of packed signed 8-bit integers …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd the lower double-precision (64-bit) floating-point …\nAdd the lower single-precision (32-bit) floating-point …\nAdd the lower double-precision (64-bit) floating-point …\nAdd the lower single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate pairs of 16-byte blocks in a and b into a …\nPerforms element-by-element bitwise AND between packed …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlend packed 16-bit integers from a and b using control …\nBlend packed 32-bit integers from a and b using control …\nBlend packed 64-bit integers from a and b using control …\nBlend packed 8-bit integers from a and b using control …\nBlend packed double-precision (64-bit) floating-point …\nBlend packed single-precision (32-bit) floating-point …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for equality, …\nCompare packed 64-bit integers in a and b for equality, …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 32-bit integers in a to packed 16-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 2 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in the low 4 …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 4 …\nZero extend packed unsigned 8-bit integers in the low 2 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert the lower single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nDivide the lower double-precision (64-bit) floating-point …\nDivide the lower single-precision (32-bit) floating-point …\nDivide the lower double-precision (64-bit) floating-point …\nDivide the lower single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active single-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using …\nMove packed 32-bit integers from a to dst using writemask …\nMove packed 64-bit integers from a to dst using writemask …\nMove packed 8-bit integers from a into dst using writemask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nMove the lower double-precision (64-bit) floating-point …\nMove the lower single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of the lower …\nCompute the approximate reciprocal of the lower …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of the …\nCompute the approximate reciprocal square root of the …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast 16-bit integer a to all elements of dst using …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle 8-bit integers in a within 128-bit lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nCompute the square root of the lower double-precision …\nCompute the square root of the lower single-precision …\nCompute the square root of the lower double-precision …\nCompute the square root of the lower single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nStore packed 16-bit integers from a into memory using …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed 8-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract the lower double-precision (64-bit) …\nSubtract the lower single-precision (32-bit) …\nSubtract the lower double-precision (64-bit) …\nSubtract the lower single-precision (32-bit) …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nLoads packed 32-bit integers from memory pointed by …\nLoads packed 64-bit integers from memory pointed by …\nLoads packed double-precision (64-bit) floating-point …\nLoads packed single-precision (32-bit) floating-point …\nConditionally store 8-bit integer elements from <code>a</code> into …\nStores packed 32-bit integers from <code>a</code> into memory pointed …\nStores packed 64-bit integers from <code>a</code> into memory pointed …\nStores packed double-precision (64-bit) floating-point …\nStores packed single-precision (32-bit) floating-point …\nCompute the absolute value of packed signed 16-bit …\nCompute the absolute value of packed signed 32-bit …\nCompute the absolute value of packed signed 8-bit integers …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd the lower double-precision (64-bit) floating-point …\nAdd the lower single-precision (32-bit) floating-point …\nAdd the lower double-precision (64-bit) floating-point …\nAdd the lower single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate pairs of 16-byte blocks in a and b into a …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 2 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in the low 4 …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in th elow 4 …\nZero extend packed unsigned 8-bit integers in the low 2 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert the lower single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nDivide the lower double-precision (64-bit) floating-point …\nDivide the lower single-precision (32-bit) floating-point …\nDivide the lower double-precision (64-bit) floating-point …\nDivide the lower single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active single-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using zeromask …\nMove packed 32-bit integers from a into dst using zeromask …\nMove packed 64-bit integers from a into dst using zeromask …\nMove packed 8-bit integers from a into dst using zeromask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nMove the lower double-precision (64-bit) floating-point …\nMove the lower single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of the lower …\nCompute the approximate reciprocal of the lower …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of the …\nCompute the approximate reciprocal square root of the …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle packed 8-bit integers in a according to shuffle …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nCompute the square root of the lower double-precision …\nCompute the square root of the lower single-precision …\nCompute the square root of the lower double-precision …\nCompute the square root of the lower single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract the lower double-precision (64-bit) …\nSubtract the lower single-precision (32-bit) …\nSubtract the lower double-precision (64-bit) …\nSubtract the lower single-precision (32-bit) …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompare packed signed 64-bit integers in a and b, and …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> and returns …\nCompares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and …\nReturns a new vector with the maximum values from …\nCompares packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the first single-precision (32-bit) …\nPerforms a serializing operation on all load-from-memory …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> and returns …\nCompares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and …\nReturns a new vector with the minimum values from …\nCompares packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the first single-precision (32-bit) …\nFinds the minimum unsigned 16-bit element in the 128-bit __…\nReturns a vector where the low element is extracted from <code>a</code> …\nConstructs a 128-bit floating-point vector of <code>[2 x double]</code>…\nReturns a <code>__m128</code> with the first component from <code>b</code> and the …\nDuplicate the low double-precision (64-bit) floating-point …\nDuplicate odd-indexed single-precision (32-bit) …\nCombine higher half of <code>a</code> and <code>b</code>. The higher half of <code>b</code> …\nDuplicate even-indexed single-precision (32-bit) …\nCombine lower half of <code>a</code> and <code>b</code>. The lower half of <code>b</code> …\nReturns a mask of the most significant bit of each element …\nReturns a mask of the most significant bit of each element …\nReturns a mask of the most significant bit of each element …\nSet each bit of mask register k based on the most …\nSet each bit of mask register k based on the most …\nSet each packed 16-bit integer in dst to all ones or all …\nSet each packed 8-bit integer in dst to all ones or all …\nSubtracts 8-bit unsigned integer values and computes the …\nMultiplies the low 32-bit integers from each packed 64-bit …\nMultiplies the low unsigned 32-bit integers from each …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies __m128 vectors.\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nReturns a new vector with the low element of <code>a</code> replaced by …\nMultiplies the first component of <code>a</code> and <code>b</code>, the other …\nMultiplies the packed 16-bit integers in <code>a</code> and <code>b</code>.\nMultiplies the packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.\nMultiplies packed 16-bit signed integer values, truncate …\nMultiplies the packed 16-bit integers in <code>a</code> and <code>b</code>.\nMultiplies the packed 32-bit integers in <code>a</code> and <code>b</code>, …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nComputes the bitwise OR of <code>a</code> and <code>b</code>.\nBitwise OR of packed single-precision (32-bit) …\nComputes the bitwise OR of 128 bits (representing integer …\nConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed …\nProvides a hint to the processor that the code sequence is …\nShuffles double-precision (64-bit) floating-point elements …\nShuffles single-precision (32-bit) floating-point elements …\nShuffles double-precision (64-bit) floating-point elements …\nShuffles single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nFetch the cache line that contains address <code>p</code> using the …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of the lower …\nCompute the approximate reciprocal of the lower …\nReturns the approximate reciprocal of packed …\nReturns the approximate reciprocal of the first …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound the packed double-precision (64-bit) floating-point …\nRound the packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of the …\nCompute the approximate reciprocal square root of the …\nReturns the approximate reciprocal square root of packed …\nReturns the approximate reciprocal square root of the …\nSum the absolute differences of packed unsigned 8-bit …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcasts 16-bit integer <code>a</code> to all elements.\nBroadcasts 32-bit integer <code>a</code> to all elements.\nBroadcasts 64-bit integer <code>a</code> to all elements.\nBroadcasts 8-bit integer <code>a</code> to all elements.\nBroadcasts double-precision (64-bit) floating-point value …\nConstruct a <code>__m128</code> with all element set to <code>a</code>.\nSets packed 16-bit integers with the supplied values.\nSets packed 32-bit integers with the supplied values.\nSets packed 64-bit integers with the supplied values, from …\nSets packed 8-bit integers with the supplied values.\nSets packed double-precision (64-bit) floating-point …\nBroadcasts double-precision (64-bit) floating-point value …\nConstruct a <code>__m128</code> from four floating point values highest …\nAlias for <code>_mm_set1_ps</code>\nCopies double-precision (64-bit) floating-point element <code>a</code> …\nConstruct a <code>__m128</code> with the lowest element set to <code>a</code> and …\nSets the MXCSR register with the 32-bit unsigned integer …\nSets packed 16-bit integers with the supplied values in …\nSets packed 32-bit integers with the supplied values in …\nSets packed 8-bit integers with the supplied values in …\nSets packed double-precision (64-bit) floating-point …\nConstruct a <code>__m128</code> from four floating point values lowest …\nReturns packed double-precision (64-bit) floating-point …\nConstruct a <code>__m128</code> with all elements initialized to zero.\nReturns a vector with all elements set to zero.\nPerforms a serializing operation on all store-to-memory …\nPerforms an intermediate calculation for the next four …\nPerforms the final calculation for the next four SHA1 …\nCalculate SHA1 state variable E after four rounds of …\nPerforms four rounds of SHA1 operation using an initial …\nPerforms an intermediate calculation for the next four …\nPerforms the final calculation for the next four SHA256 …\nPerforms 2 rounds of SHA256 operation using an initial …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffles 32-bit integers in <code>a</code> using the control in <code>IMM8</code>.\nShuffles bytes from <code>a</code> according to the content of <code>b</code>.\nConstructs a 128-bit floating-point vector of <code>[2 x double]</code> …\nShuffles packed single-precision (32-bit) floating-point …\nShuffles 16-bit integers in the high 64 bits of <code>a</code> using …\nShuffles 16-bit integers in the low 64 bits of <code>a</code> using the …\nNegates packed 16-bit integers in <code>a</code> when the corresponding …\nNegates packed 32-bit integers in <code>a</code> when the corresponding …\nNegates packed 8-bit integers in <code>a</code> when the corresponding …\nShifts packed 16-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 64-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 16-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts packed 64-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts <code>a</code> left by <code>IMM8</code> bytes while shifting in zeros.\nShift packed 16-bit integers in a left by the amount …\nShifts packed 32-bit integers in <code>a</code> left by the amount …\nShifts packed 64-bit integers in <code>a</code> left by the amount …\nReturns a new vector with the square root of each of the …\nReturns the square root of packed single-precision …\nCompute the square root of the lower double-precision …\nCompute the square root of the lower single-precision …\nReturns a new vector with the low element of <code>a</code> replaced by …\nReturns the square root of the first single-precision …\nShifts packed 16-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>count</code> while …\nShift packed 64-bit integers in a right by count while …\nShifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShifts packed 32-bit integers in <code>a</code> right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShifts packed 16-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 64-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 64-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts <code>a</code> right by <code>IMM8</code> bytes while shifting in zeros.\nShift packed 16-bit integers in a right by the amount …\nShifts packed 32-bit integers in <code>a</code> right by the amount …\nShifts packed 64-bit integers in <code>a</code> right by the amount …\nStores the lower double-precision (64-bit) floating-point …\nStores the lowest 32 bit float of <code>a</code> repeated four times …\nStore 128-bits (composed of 4 packed 32-bit integers) from …\nStore 128-bits (composed of 2 packed 64-bit integers) from …\nStores 128-bits (composed of 2 packed double-precision …\nStores the lower double-precision (64-bit) floating-point …\nStores four 32-bit floats into <em>aligned</em> memory.\nAlias for <code>_mm_store1_ps</code>\nStores the lower 64 bits of a 128-bit vector of …\nStores 128-bits of integer data from <code>a</code> into memory.\nStores the lowest 32 bit float of <code>a</code> into memory.\nStores the upper 64 bits of a 128-bit vector of …\nStores the lower 64-bit integer <code>a</code> to a memory location.\nStores the lower 64 bits of a 128-bit vector of …\nStores 2 double-precision (64-bit) floating-point elements …\nStores four 32-bit floats into <em>aligned</em> memory in reverse …\nStore 128-bits (composed of 8 packed 16-bit integers) from …\nStore 128-bits (composed of 4 packed 32-bit integers) from …\nStore 128-bits (composed of 2 packed 64-bit integers) from …\nStore 128-bits (composed of 16 packed 8-bit integers) from …\nStores 128-bits (composed of 2 packed double-precision …\nStores four 32-bit floats into memory. There are no …\nStores 128-bits of integer data from <code>a</code> into memory.\nStores a 128-bit floating point vector of <code>[2 x double]</code> to …\nStores <code>a</code> into the memory at <code>mem_addr</code> using a non-temporal …\nNon-temporal store of <code>a.0</code> into <code>p</code>.\nStores a 128-bit integer vector to a 128-bit aligned …\nStores a 32-bit integer value in the specified memory …\nNon-temporal store of <code>a.0</code> into <code>p</code>.\nSubtracts packed 16-bit integers in <code>b</code> from packed 16-bit …\nSubtract packed 32-bit integers in <code>b</code> from packed 32-bit …\nSubtract packed 64-bit integers in <code>b</code> from packed 64-bit …\nSubtracts packed 8-bit integers in <code>b</code> from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtracts __m128 vectors.\nSubtract the lower double-precision (64-bit) …\nSubtract the lower single-precision (32-bit) …\nReturns a new vector with the low element of <code>a</code> replaced by …\nSubtracts the first component of <code>b</code> from <code>a</code>, the other …\nSubtract packed 16-bit integers in <code>b</code> from packed 16-bit …\nSubtract packed 8-bit integers in <code>b</code> from packed 8-bit …\nSubtract packed unsigned 16-bit integers in <code>b</code> from packed …\nSubtract packed unsigned 8-bit integers in <code>b</code> from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nTests whether the specified bits in <code>a</code> 128-bit integer …\nTests whether the specified bits in a 128-bit integer …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nTests whether the specified bits in a 128-bit integer …\nComputes the bitwise AND of 128 bits (representing …\nComputes the bitwise AND of 128 bits (representing …\nTests whether the specified bits in a 128-bit integer …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nComputes the bitwise AND of 128 bits (representing …\nComputes the bitwise AND of 128 bits (representing …\nTests whether the specified bits in a 128-bit integer …\nComputes the bitwise AND of 128 bits (representing …\nComputes the bitwise AND of 128 bits (representing …\nTests whether the specified bits in a 128-bit integer …\nCounts the number of trailing least significant zero bits.\nCompares the lower element of <code>a</code> and <code>b</code> for equality.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for …\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for greater-than.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for …\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for less-than.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for not-equal.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nReturns vector of type __m128d with indeterminate elements.\nReturns vector of type __m128 with indeterminate elements. …\nReturns vector of type __m128i with indeterminate elements.\nUnpacks and interleave 16-bit integers from the high half …\nUnpacks and interleave 32-bit integers from the high half …\nUnpacks and interleave 64-bit integers from the high half …\nUnpacks and interleave 8-bit integers from the high half …\nThe resulting <code>__m128d</code> element is composed by the low-order …\nUnpacks and interleave single-precision (32-bit) …\nUnpacks and interleave 16-bit integers from the low half …\nUnpacks and interleave 32-bit integers from the low half …\nUnpacks and interleave 64-bit integers from the low half …\nUnpacks and interleave 8-bit integers from the low half of …\nThe resulting <code>__m128d</code> element is composed by the …\nUnpacks and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nComputes the bitwise XOR of <code>a</code> and <code>b</code>.\nBitwise exclusive OR of packed single-precision (32-bit) …\nComputes the bitwise XOR of 128 bits (representing integer …\nUnsigned multiply without affecting flags.\nScatter contiguous low order bits of <code>a</code> to the result at …\nGathers the bits of <code>x</code> specified by the <code>mask</code> into the …\nCounts the bits that are set.\nRead a hardware generated 16-bit random value and store …\nRead a hardware generated 32-bit random value and store …\nRead a 16-bit NIST SP800-90B and SP800-90C compliant …\nRead a 32-bit NIST SP800-90B and SP800-90C compliant …\nReads the current value of the processor’s time-stamp …\nStore 32-bit mask from a into memory.\nStore 64-bit mask from a into memory.\nAdds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nClears all bits below the least significant zero of <code>x</code> and …\nClears all bits below the least significant zero of <code>x</code> and …\nCounts the number of trailing least significant zero bits.\nSets all bits below the least significant one of <code>x</code> and …\nSets all bits below the least significant one of <code>x</code> and …\nForces a restricted transactional memory (RTM) region to …\nRetrieves the parameter passed to <code>_xabort</code> when <code>_xbegin</code>’s …\nSpecifies the start of a restricted transactional memory …\nSpecifies the end of a restricted transactional memory …\nReads the contents of the extended control register <code>XCR</code> …\nPerforms a full or partial restore of the enabled …\nPerforms a full or partial restore of the enabled …\nPerforms a full or partial save of the enabled processor …\nPerforms a full or partial save of the enabled processor …\nPerforms a full or partial save of the enabled processor …\nPerforms a full or partial save of the enabled processor …\nCopies 64-bits from <code>val</code> to the extended control register (…\nQueries whether the processor is executing in a …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEAX register.\nEBX register.\nECX register.\nEDX register.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\n\n\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\n\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\n\nReturns the argument unchanged.\n\n\nReturns the argument unchanged.\n\n\n\n\n\n\nReturns the argument unchanged.\n\n\n\n\nReturns the argument unchanged.\n\nReturns the argument unchanged.\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDoes the host support the <code>cpuid</code> instruction?\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nResult of the <code>cpuid</code> instruction.\nEqual (ordered, non-signaling)\nEqual (ordered, signaling)\nEqual (unordered, non-signaling)\nEqual (unordered, signaling)\nFalse (ordered, non-signaling)\nFalse (ordered, signaling)\nGreater-than-or-equal (ordered, non-signaling)\nGreater-than-or-equal (ordered, signaling)\nGreater-than (ordered, non-signaling)\nGreater-than (ordered, signaling)\nLess-than-or-equal (ordered, non-signaling)\nLess-than-or-equal (ordered, signaling)\nLess-than (ordered, non-signaling)\nLess-than (ordered, signaling)\nNot-equal (ordered, non-signaling)\nNot-equal (ordered, signaling)\nNot-equal (unordered, non-signaling)\nNot-equal (unordered, signaling)\nNot-greater-than-or-equal (unordered, non-signaling)\nNot-greater-than-or-equal (unordered, signaling)\nNot-greater-than (unordered, non-signaling)\nNot-greater-than (unordered, signaling)\nNot-less-than-or-equal (unordered, non-signaling)\nNot-less-than-or-equal (unordered, signaling)\nNot-less-than (unordered, non-signaling)\nNot-less-than (unordered, signaling)\nOrdered (non-signaling)\nOrdered (signaling)\nTrue (unordered, non-signaling)\nTrue (unordered, signaling)\nUnordered (non-signaling)\nUnordered (signaling)\nThe <code>_MM_CMPINT_ENUM</code> type used to specify comparison …\nEqual\nFalse\nLess-than-or-equal\nLess-than\nNot-equal\nNot less-than-or-equal\nNot less-than\nTrue\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_EXCEPTION_STATE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_FLUSH_ZERO_MODE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nround up and do not suppress exceptions\nuse MXCSR.RC; see <code>vendor::_MM_SET_ROUNDING_MODE</code>\nround down and do not suppress exceptions\nuse MXCSR.RC and suppress exceptions; see …\nround to nearest and do not suppress exceptions\nsuppress exceptions\ndo not suppress exceptions\nuse MXCSR.RC and do not suppress exceptions; see …\nround to nearest\nround down\nround up\ntruncate\ntruncate and do not suppress exceptions\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nThe <code>MM_MANTISSA_NORM_ENUM</code> type used to specify mantissa …\nThe <code>MM_MANTISSA_SIGN_ENUM</code> type used to specify mantissa …\ninterval [1, 2)\ninterval [0.5, 1)\ninterval [0.5, 2)\ninterval [0.75, 1.5)\nDEST = NaN if sign(SRC) = 1\nsign = sign(SRC)\nsign = 0\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_EXCEPTION_MASK</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe <code>MM_PERM_ENUM</code> type used to specify shuffle operations …\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_ROUNDING_MODE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nA utility function for creating masks to use with Intel …\nTranspose the 4x4 matrix formed by 4 rows of __m128 in …\n<strong>Mask only</strong>: return the bit mask\nFor each character in <code>a</code>, find if it is in <code>b</code> <em>(Default)</em>\nThe strings defined by <code>a</code> and <code>b</code> are equal\nSearch for the defined substring in the target\nFor each character in <code>a</code>, determine if …\n<strong>Index only</strong>: return the least significant bit <em>(Default)</em>\nNegates results only before the end of the string\nDo not negate results before the end of the string\n<strong>Index only</strong>: return the most significant bit\nNegates results\nDo not negate results <em>(Default)</em>\nString contains signed 8-bit characters\nString contains unsigned 16-bit characters\nString contains unsigned 8-bit characters <em>(Default)</em>\n<strong>Mask only</strong>: return the byte mask\nString contains unsigned 16-bit characters\nTransaction abort due to the transaction using too much …\nTransaction abort due to a memory conflict with another …\nTransaction abort due to a debug trap.\nTransaction explicitly aborted with xabort. The parameter …\nTransaction abort in a inner nested transaction.\nTransaction retry is possible.\nTransaction successfully started.\n<code>XFEATURE_ENABLED_MASK</code> for <code>XCR</code>\nSee <code>__cpuid_count</code>.\nReturns the result of the <code>cpuid</code> instruction for a given …\nReturns the highest-supported <code>leaf</code> (<code>EAX</code>) and sub-leaf (<code>ECX</code>…\n128-bit wide set of four <code>f32</code> types, x86-specific\n128-bit wide set of eight <code>u16</code> types, x86-specific\n128-bit wide set of two <code>f64</code> types, x86-specific\n128-bit wide integer vector type, x86-specific\n256-bit wide set of eight <code>f32</code> types, x86-specific\n256-bit wide set of 16 <code>u16</code> types, x86-specific\n256-bit wide set of four <code>f64</code> types, x86-specific\n256-bit wide integer vector type, x86-specific\n512-bit wide set of sixteen <code>f32</code> types, x86-specific\n512-bit wide set of 32 <code>u16</code> types, x86-specific\n512-bit wide set of eight <code>f64</code> types, x86-specific\n512-bit wide integer vector type, x86-specific\nThe <code>__mmask16</code> type used in AVX-512 intrinsics, a 16-bit …\nThe <code>__mmask32</code> type used in AVX-512 intrinsics, a 32-bit …\nThe <code>__mmask64</code> type used in AVX-512 intrinsics, a 64-bit …\nThe <code>__mmask8</code> type used in AVX-512 intrinsics, a 8-bit …\nReads the current value of the processor’s time-stamp …\nAdds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nAdds unsigned 64-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nAdds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nAdds unsigned 64-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nBitwise logical <code>AND</code> of inverted <code>a</code> with <code>b</code>.\nBitwise logical <code>AND</code> of inverted <code>a</code> with <code>b</code>.\nExtracts bits of <code>a</code> specified by <code>control</code> into the least …\nExtracts bits of <code>a</code> specified by <code>control</code> into the least …\nExtracts bits in range [<code>start</code>, <code>start</code> + <code>length</code>) from <code>a</code> into …\nExtracts bits in range [<code>start</code>, <code>start</code> + <code>length</code>) from <code>a</code> into …\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>.\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>.\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nClears all bits below the least significant zero bit of <code>x</code>.\nClears all bits below the least significant zero bit of <code>x</code>.\nSets all bits of <code>x</code> to 1 except for the least significant …\nSets all bits of <code>x</code> to 1 except for the least significant …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code>.\nSets the least significant zero bit of <code>x</code>.\nSets all bits of <code>x</code> below the least significant one.\nSets all bits of <code>x</code> below the least significant one.\nExtracts lowest set isolated bit.\nExtracts lowest set isolated bit.\nClears least significant bit and sets all other bits.\nClears least significant bit and sets all other bits.\nGets mask up to lowest set bit.\nGets mask up to lowest set bit.\nResets the lowest set bit of <code>x</code>.\nResets the lowest set bit of <code>x</code>.\nReturns an integer with the reversed byte order of x\nReturns an integer with the reversed byte order of x\nZeroes higher bits of <code>a</code> &gt;= <code>index</code>.\nZeroes higher bits of <code>a</code> &gt;= <code>index</code>.\nRestores the <code>XMM</code>, <code>MMX</code>, <code>MXCSR</code>, and <code>x87</code> FPU registers from …\nRestores the <code>XMM</code>, <code>MMX</code>, <code>MXCSR</code>, and <code>x87</code> FPU registers from …\nSaves the <code>x87</code> FPU, <code>MMX</code> technology, <code>XMM</code>, and <code>MXCSR</code> …\nSaves the <code>x87</code> FPU, <code>MMX</code> technology, <code>XMM</code>, and <code>MXCSR</code> …\nAdd 32-bit masks in a and b, and store the result in k.\nAdd 64-bit masks in a and b, and store the result in k.\nCompute the bitwise AND of 16-bit masks a and b, and store …\nCompute the bitwise AND of 32-bit masks a and b, and store …\nCompute the bitwise AND of 64-bit masks a and b, and store …\nCompute the bitwise NOT of 16-bit masks a and then AND …\nCompute the bitwise NOT of 32-bit masks a and then AND …\nCompute the bitwise NOT of 64-bit masks a and then AND …\nCompute the bitwise NOT of 16-bit mask a, and store the …\nCompute the bitwise NOT of 32-bit mask a, and store the …\nCompute the bitwise NOT of 64-bit mask a, and store the …\nCompute the bitwise OR of 16-bit masks a and b, and store …\nCompute the bitwise OR of 32-bit masks a and b, and store …\nCompute the bitwise OR of 64-bit masks a and b, and store …\nCompute the bitwise XNOR of 16-bit masks a and b, and …\nCompute the bitwise XNOR of 32-bit masks a and b, and …\nCompute the bitwise XNOR of 64-bit masks a and b, and …\nCompute the bitwise XOR of 16-bit masks a and b, and store …\nCompute the bitwise XOR of 32-bit masks a and b, and store …\nCompute the bitwise XOR of 64-bit masks a and b, and store …\nLoad 32-bit mask from memory into k.\nLoad 64-bit mask from memory into k.\nCounts the leading most significant zero bits.\nCounts the leading most significant zero bits.\nComputes the absolute values of packed 16-bit integers in <code>a</code>…\nComputes the absolute values of packed 32-bit integers in <code>a</code>…\nCompute the absolute value of packed signed 64-bit …\nComputes the absolute values of packed 8-bit integers in <code>a</code>.\nAdds packed 16-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 32-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 64-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 8-bit integers in <code>a</code> and <code>b</code>.\nAdds packed double-precision (64-bit) floating-point …\nAdds packed single-precision (32-bit) floating-point …\nAdds packed 16-bit integers in <code>a</code> and <code>b</code> using saturation.\nAdds packed 8-bit integers in <code>a</code> and <code>b</code> using saturation.\nAdds packed unsigned 16-bit integers in <code>a</code> and <code>b</code> using …\nAdds packed unsigned 8-bit integers in <code>a</code> and <code>b</code> using …\nAlternatively adds and subtracts packed double-precision …\nAlternatively adds and subtracts packed single-precision …\nPerforms one round of an AES decryption flow on each …\nPerforms the last round of an AES decryption flow on each …\nPerforms one round of an AES encryption flow on each …\nPerforms the last round of an AES encryption flow on each …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenates pairs of 16-byte blocks in <code>a</code> and <code>b</code> into a …\nComputes the bitwise AND of a packed double-precision …\nComputes the bitwise AND of packed single-precision …\nComputes the bitwise AND of 256 bits (representing integer …\nComputes the bitwise NOT of packed double-precision …\nComputes the bitwise NOT of packed single-precision …\nComputes the bitwise NOT of 256 bits (representing integer …\nAverages packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.\nAverages packed unsigned 8-bit integers in <code>a</code> and <code>b</code>.\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlends packed 16-bit integers from <code>a</code> and <code>b</code> using control …\nBlends packed 32-bit integers from <code>a</code> and <code>b</code> using control …\nBlends packed double-precision (64-bit) floating-point …\nBlends packed single-precision (32-bit) floating-point …\nBlends packed 8-bit integers from <code>a</code> and <code>b</code> using <code>mask</code>.\nBlends packed double-precision (64-bit) floating-point …\nBlends packed single-precision (32-bit) floating-point …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcasts 128 bits from memory (composed of 2 packed …\nBroadcasts 128 bits from memory (composed of 4 packed …\nBroadcasts a double-precision (64-bit) floating-point …\nBroadcasts a single-precision (32-bit) floating-point …\nBroadcasts the low packed 8-bit integer from <code>a</code> to all …\nBroadcasts the low packed 32-bit integer from <code>a</code> to all …\nBroadcast the low 8-bits from input mask k to all 64-bit …\nBroadcast the low 16-bits from input mask k to all 32-bit …\nBroadcasts the low packed 64-bit integer from <code>a</code> to all …\nBroadcasts the low double-precision (64-bit) …\nBroadcasts 128 bits of integer data from a to all 128-bit …\nBroadcasts the low single-precision (32-bit) …\nBroadcasts the low packed 16-bit integer from a to all …\nShifts 128-bit lanes in <code>a</code> left by <code>imm8</code> bytes while …\nShifts 128-bit lanes in <code>a</code> right by <code>imm8</code> bytes while …\nCasts vector of type __m128d to type __m256d; the upper …\nCasts vector of type __m256d to type __m128d.\nCast vector of type __m256d to type __m256.\nCasts vector of type __m256d to type __m256i.\nCasts vector of type __m128 to type __m256; the upper 128 …\nCasts vector of type __m256 to type __m128.\nCast vector of type __m256 to type __m256d.\nCasts vector of type __m256 to type __m256i.\nCasts vector of type __m128i to type __m256i; the upper …\nCasts vector of type __m256i to type __m256d.\nCasts vector of type __m256i to type __m256.\nCasts vector of type __m256i to type __m128i.\nRounds packed double-precision (64-bit) floating point …\nRounds packed single-precision (32-bit) floating point …\nPerforms a carry-less multiplication of two 64-bit …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompares packed double-precision (64-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompares packed single-precision (32-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed 32-bit integers in a and b for equality, …\nCompares packed 64-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed 64-bit integers in a and b for equality, …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 32-bit integers in a and b for …\nCompares packed 64-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 64-bit integers in a and b for …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for greater-than.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nSign-extend 16-bit integers to 32-bit integers.\nSign-extend 16-bit integers to 64-bit integers.\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign-extend 32-bit integers to 64-bit integers.\nConvert packed 32-bit integers in a to packed 8-bit …\nConverts packed 32-bit integers in <code>a</code> to packed …\nConverts packed 32-bit integers in <code>a</code> to packed …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign-extend 8-bit integers to 16-bit integers.\nSign-extend 8-bit integers to 32-bit integers.\nSign-extend 8-bit integers to 64-bit integers.\nZeroes extend packed unsigned 16-bit integers in <code>a</code> to …\nZero-extend the lower four unsigned 16-bit integers in <code>a</code> …\nZero-extend unsigned 32-bit integers in <code>a</code> to 64-bit …\nConvert packed unsigned 32-bit integers in a to packed …\nZero-extend unsigned 8-bit integers in <code>a</code> to 16-bit …\nZero-extend the lower eight unsigned 8-bit integers in <code>a</code> …\nZero-extend the lower four unsigned 8-bit integers in <code>a</code> to …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConverts packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConverts packed double-precision (64-bit) floating-point …\nConverts the 8 x 16-bit half-precision float values in the …\nConverts packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConverts packed single-precision (32-bit) floating-point …\nConverts the 8 x 32-bit float values in the 256-bit vector …\nReturns the first element of the input vector of …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nReturns the first element of the input vector of <code>[8 x i32]</code>.\nReturns the first element of the input vector of …\nConverts packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConverts packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nComputes the division of each of the 4 packed 64-bit …\nComputes the division of each of the 8 packed 32-bit …\nConditionally multiplies the packed single-precision …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nExtracts a 16-bit integer from <code>a</code>, selected with <code>INDEX</code>. …\nExtracts a 32-bit integer from <code>a</code>, selected with <code>INDEX</code>.\nExtracts a 64-bit integer from <code>a</code>, selected with <code>INDEX</code>.\nExtracts an 8-bit integer from <code>a</code>, selected with <code>INDEX</code>. …\nExtracts 128 bits (composed of 2 packed double-precision …\nExtracts 128 bits (composed of 4 packed single-precision …\nExtracts 128 bits (composed of integer data) from <code>a</code>, …\nExtract 128 bits (composed of 4 packed single-precision …\nExtracts 128 bits (of integer data) from <code>a</code> selected with …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nRounds packed double-precision (64-bit) floating point …\nRounds packed single-precision (32-bit) floating point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nHorizontally adds adjacent pairs of 16-bit integers in <code>a</code> …\nHorizontally adds adjacent pairs of 32-bit integers in <code>a</code> …\nHorizontal addition of adjacent pairs in the two packed …\nHorizontal addition of adjacent pairs in the two packed …\nHorizontally adds adjacent pairs of 16-bit integers in <code>a</code> …\nHorizontally subtract adjacent pairs of 16-bit integers in …\nHorizontally subtract adjacent pairs of 32-bit integers in …\nHorizontal subtraction of adjacent pairs in the two packed …\nHorizontal subtraction of adjacent pairs in the two packed …\nHorizontally subtract adjacent pairs of 16-bit integers in …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nScatter 64-bit integers from a into memory using 32-bit …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nCopies <code>a</code> to result, and inserts the 16-bit integer <code>i</code> into …\nCopies <code>a</code> to result, and inserts the 32-bit integer <code>i</code> into …\nCopies <code>a</code> to result, and insert the 64-bit integer <code>i</code> into …\nCopies <code>a</code> to result, and inserts the 8-bit integer <code>i</code> into …\nCopies <code>a</code> to result, then inserts 128 bits (composed of 2 …\nCopies <code>a</code> to result, then inserts 128 bits (composed of 4 …\nCopies <code>a</code> to result, then inserts 128 bits from <code>b</code> into …\nCopy a to dst, then insert 128 bits (composed of 4 packed …\nCopies <code>a</code> to <code>dst</code>, then insert 128 bits (of integer data) …\nCopy a to dst, then insert 128 bits (composed of 4 packed …\nLoads 256-bits of integer data from unaligned memory into …\nLoad 256-bits (composed of 8 packed 32-bit integers) from …\nLoad 256-bits (composed of 4 packed 64-bit integers) from …\nLoads 256-bits (composed of 4 packed double-precision …\nLoads 256-bits (composed of 8 packed single-precision …\nLoads 256-bits of integer data from memory into result. …\nLoads two 128-bit values (composed of 4 packed …\nLoads two 128-bit values (composed of 2 packed …\nLoads two 128-bit values (composed of integer data) from …\nLoad 256-bits (composed of 16 packed 16-bit integers) from …\nLoad 256-bits (composed of 8 packed 32-bit integers) from …\nLoad 256-bits (composed of 4 packed 64-bit integers) from …\nLoad 256-bits (composed of 32 packed 8-bit integers) from …\nLoads 256-bits (composed of 4 packed double-precision …\nLoads 256-bits (composed of 8 packed single-precision …\nLoads 256-bits of integer data from memory into result. …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiplies packed signed 16-bit integers in <code>a</code> and <code>b</code>, …\nVertically multiplies each unsigned 8-bit integer from <code>a</code> …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nCompute the absolute value of packed signed 16-bit …\nCompute the absolute value of packed signed 32-bit …\nCompute the absolute value of packed signed 64-bit …\nCompute the absolute value of packed signed 8-bit integers …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate pairs of 16-byte blocks in a and b into a …\nPerforms element-by-element bitwise AND between packed …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlend packed 16-bit integers from a and b using control …\nBlend packed 32-bit integers from a and b using control …\nBlend packed 64-bit integers from a and b using control …\nBlend packed 8-bit integers from a and b using control …\nBlend packed double-precision (64-bit) floating-point …\nBlend packed single-precision (32-bit) floating-point …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low double-precision (64-bit) floating-point …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for equality, …\nCompare packed 64-bit integers in a and b for equality, …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 32-bit integers in a to packed 16-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 4 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in the low 8 …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 8 …\nZero extend packed unsigned 8-bit integers in the low 4 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active single-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nExtract 128 bits (composed of 4 packed single-precision …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using …\nMove packed 32-bit integers from a to dst using writemask …\nMove packed 64-bit integers from a to dst using writemask …\nMove packed 8-bit integers from a into dst using writemask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast 16-bit integer a to all elements of dst using …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle 8-bit integers in a within 128-bit lanes using the …\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nStore packed 16-bit integers from a into memory using …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed 8-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nLoads packed 32-bit integers from memory pointed by …\nLoads packed 64-bit integers from memory pointed by …\nLoads packed double-precision (64-bit) floating-point …\nLoads packed single-precision (32-bit) floating-point …\nStores packed 32-bit integers from <code>a</code> into memory pointed …\nStores packed 64-bit integers from <code>a</code> into memory pointed …\nStores packed double-precision (64-bit) floating-point …\nStores packed single-precision (32-bit) floating-point …\nCompute the absolute value of packed signed 16-bit …\nCompute the absolute value of packed signed 32-bit …\nCompute the absolute value of packed signed 64-bit …\nCompute the absolute value of packed signed 8-bit integers …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate pairs of 16-byte blocks in a and b into a …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low double-precision (64-bit) floating-point …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 4 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in the low 8 …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 8 …\nZero extend packed unsigned 8-bit integers in the low 4 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active single-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nExtract 128 bits (composed of 4 packed single-precision …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using zeromask …\nMove packed 32-bit integers from a into dst using zeromask …\nMove packed 64-bit integers from a into dst using zeromask …\nMove packed 8-bit integers from a into dst using zeromask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle packed 8-bit integers in a according to shuffle …\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompare packed signed 64-bit integers in a and b, and …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code>, and returns the …\nCompares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed double-precision (64-bit) floating-point …\nCompares packed single-precision (32-bit) floating-point …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompare packed signed 64-bit integers in a and b, and …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code>, and returns the …\nCompares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed double-precision (64-bit) floating-point …\nCompares packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nCreates mask from the most significant bit of each 8-bit …\nSets each bit of the returned mask based on the most …\nSets each bit of the returned mask based on the most …\nSet each bit of mask register k based on the most …\nSet each bit of mask register k based on the most …\nSet each packed 16-bit integer in dst to all ones or all …\nSet each packed 8-bit integer in dst to all ones or all …\nComputes the sum of absolute differences (SADs) of …\nMultiplies the low 32-bit integers from each packed 64-bit …\nMultiplies the low unsigned 32-bit integers from each …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies the packed 16-bit integers in <code>a</code> and <code>b</code>, producing\nMultiplies the packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, …\nMultiplies packed 16-bit integers in <code>a</code> and <code>b</code>, producing …\nMultiplies the packed 16-bit integers in <code>a</code> and <code>b</code>, producing\nMultiplies the packed 32-bit integers in <code>a</code> and <code>b</code>, producing\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nComputes the bitwise OR packed double-precision (64-bit) …\nComputes the bitwise OR packed single-precision (32-bit) …\nComputes the bitwise OR of 256 bits (representing integer …\nConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed …\nShuffles 256 bits (composed of 4 packed double-precision …\nShuffles 256 bits (composed of 8 packed single-precision …\nShuffles 128-bits (composed of integer data) selected by …\nShuffles 128-bits of integer data selected by <code>imm8</code> from <code>a</code> …\nPermutes 64-bit integers from <code>a</code> using control mask <code>imm8</code>.\nShuffles 64-bit floating-point elements in <code>a</code> across lanes …\nShuffles double-precision (64-bit) floating-point elements …\nShuffles single-precision (32-bit) floating-point elements …\nPermutes packed 32-bit integers from <code>a</code> according to the …\nShuffles eight 32-bit floating-point elements in <code>a</code> across …\nShuffles double-precision (64-bit) floating-point elements …\nShuffles single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nComputes the approximate reciprocal of packed …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRounds packed double-precision (64-bit) floating point …\nRounds packed single-precision (32-bit) floating point …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nComputes the approximate reciprocal square root of packed …\nComputes the absolute differences of packed unsigned 8-bit …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcasts 16-bit integer <code>a</code> to all elements of returned …\nBroadcasts 32-bit integer <code>a</code> to all elements of returned …\nBroadcasts 64-bit integer <code>a</code> to all elements of returned …\nBroadcasts 8-bit integer <code>a</code> to all elements of returned …\nBroadcasts double-precision (64-bit) floating-point value <code>a</code>…\nBroadcasts single-precision (32-bit) floating-point value <code>a</code>…\nSets packed 16-bit integers in returned vector with the …\nSets packed 32-bit integers in returned vector with the …\nSets packed 64-bit integers in returned vector with the …\nSets packed 8-bit integers in returned vector with the …\nSets packed __m256 returned vector with the supplied …\nSets packed __m256d returned vector with the supplied …\nSets packed __m256i returned vector with the supplied …\nSets packed double-precision (64-bit) floating-point …\nSets packed single-precision (32-bit) floating-point …\nSets packed 16-bit integers in returned vector with the …\nSets packed 32-bit integers in returned vector with the …\nSets packed 64-bit integers in returned vector with the …\nSets packed 8-bit integers in returned vector with the …\nSets packed __m256 returned vector with the supplied …\nSets packed __m256d returned vector with the supplied …\nSets packed __m256i returned vector with the supplied …\nSets packed double-precision (64-bit) floating-point …\nSets packed single-precision (32-bit) floating-point …\nReturns vector of type __m256d with all elements set to …\nReturns vector of type __m256 with all elements set to …\nReturns vector of type __m256i with all elements set to …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffles 32-bit integers in 128-bit lanes of <code>a</code> using the …\nShuffles bytes from <code>a</code> according to the content of <code>b</code>.\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffles double-precision (64-bit) floating-point elements …\nShuffles single-precision (32-bit) floating-point elements …\nShuffles 16-bit integers in the high 64 bits of 128-bit …\nShuffles 16-bit integers in the low 64 bits of 128-bit …\nNegates packed 16-bit integers in <code>a</code> when the corresponding …\nNegates packed 32-bit integers in <code>a</code> when the corresponding …\nNegates packed 8-bit integers in <code>a</code> when the corresponding …\nShifts packed 16-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 64-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 16-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts packed 64-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts 128-bit lanes in <code>a</code> left by <code>imm8</code> bytes while …\nShift packed 16-bit integers in a left by the amount …\nShifts packed 32-bit integers in <code>a</code> left by the amount …\nShifts packed 64-bit integers in <code>a</code> left by the amount …\nReturns the square root of packed double-precision …\nReturns the square root of packed single-precision …\nShifts packed 16-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>count</code> while …\nShift packed 64-bit integers in a right by count while …\nShifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShifts packed 32-bit integers in <code>a</code> right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShifts packed 16-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 64-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 64-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts 128-bit lanes in <code>a</code> right by <code>imm8</code> bytes while …\nShift packed 16-bit integers in a right by the amount …\nShifts packed 32-bit integers in <code>a</code> right by the amount …\nShifts packed 64-bit integers in <code>a</code> right by the amount …\nStore 256-bits (composed of 8 packed 32-bit integers) from …\nStore 256-bits (composed of 4 packed 64-bit integers) from …\nStores 256-bits (composed of 4 packed double-precision …\nStores 256-bits (composed of 8 packed single-precision …\nStores 256-bits of integer data from <code>a</code> into memory. …\nStores the high and low 128-bit halves (each composed of 4 …\nStores the high and low 128-bit halves (each composed of 2 …\nStores the high and low 128-bit halves (each composed of …\nStore 256-bits (composed of 16 packed 16-bit integers) …\nStore 256-bits (composed of 8 packed 32-bit integers) from …\nStore 256-bits (composed of 4 packed 64-bit integers) from …\nStore 256-bits (composed of 32 packed 8-bit integers) from …\nStores 256-bits (composed of 4 packed double-precision …\nStores 256-bits (composed of 8 packed single-precision …\nStores 256-bits of integer data from <code>a</code> into memory. …\nMoves double-precision values from a 256-bit vector of …\nMoves single-precision floating point values from a …\nMoves integer data from a 256-bit integer vector to a …\nSubtract packed 16-bit integers in <code>b</code> from packed 16-bit …\nSubtract packed 32-bit integers in <code>b</code> from packed 32-bit …\nSubtract packed 64-bit integers in <code>b</code> from packed 64-bit …\nSubtract packed 8-bit integers in <code>b</code> from packed 8-bit …\nSubtracts packed double-precision (64-bit) floating-point …\nSubtracts packed single-precision (32-bit) floating-point …\nSubtract packed 16-bit integers in <code>b</code> from packed 16-bit …\nSubtract packed 8-bit integers in <code>b</code> from packed 8-bit …\nSubtract packed unsigned 16-bit integers in <code>b</code> from packed …\nSubtract packed unsigned 8-bit integers in <code>b</code> from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing integer …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing integer …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing integer …\nReturns vector of type <code>__m256d</code> with indeterminate elements.\nReturns vector of type <code>__m256</code> with indeterminate elements. …\nReturns vector of type __m256i with with indeterminate …\nUnpacks and interleave 16-bit integers from the high half …\nUnpacks and interleave 32-bit integers from the high half …\nUnpacks and interleave 64-bit integers from the high half …\nUnpacks and interleave 8-bit integers from the high half …\nUnpacks and interleave double-precision (64-bit) …\nUnpacks and interleave single-precision (32-bit) …\nUnpacks and interleave 16-bit integers from the low half …\nUnpacks and interleave 32-bit integers from the low half …\nUnpacks and interleave 64-bit integers from the low half …\nUnpacks and interleave 8-bit integers from the low half of …\nUnpacks and interleave double-precision (64-bit) …\nUnpacks and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nComputes the bitwise XOR of packed double-precision …\nComputes the bitwise XOR of packed single-precision …\nComputes the bitwise XOR of 256 bits (representing integer …\nZeroes the contents of all XMM or YMM registers.\nZeroes the upper 128 bits of all YMM registers; the lower …\nConstructs a 256-bit floating-point vector of <code>[4 x double]</code> …\nConstructs a 256-bit floating-point vector of <code>[8 x float]</code> …\nConstructs a 256-bit integer vector from a 128-bit integer …\nCompute the absolute value of packed signed 16-bit …\nComputes the absolute values of packed 32-bit integers in <code>a</code>…\nCompute the absolute value of packed signed 64-bit …\nCompute the absolute value of packed signed 8-bit integers …\nFinds the absolute value of each packed double-precision …\nFinds the absolute value of each packed single-precision …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nPerforms one round of an AES decryption flow on each …\nPerforms the last round of an AES decryption flow on each …\nPerforms one round of an AES encryption flow on each …\nPerforms the last round of an AES encryption flow on each …\nConcatenate a and b into a 128-byte immediate result, …\nConcatenate a and b into a 128-byte immediate result, …\nConcatenate pairs of 16-byte blocks in a and b into a …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of 512 bits (composed of packed …\nCompute the bitwise AND of 512 bits (representing integer …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of 512 bits (composed of packed …\nCompute the bitwise NOT of 512 bits (representing integer …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed double-precision (64-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcast the 4 packed 64-bit integers from a to all …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low 8-bits from input mask k to all 64-bit …\nBroadcast the low 16-bits from input mask k to all 32-bit …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low double-precision (64-bit) floating-point …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nShift 128-bit lanes in a left by imm8 bytes while shifting …\nShift 128-bit lanes in a right by imm8 bytes while …\nCast vector of type __m128d to type __m512d; the upper 384 …\nCast vector of type __m256d to type __m512d; the upper 256 …\nCast vector of type __m512d to type __m128d. This …\nCast vector of type __m512d to type __m256d. This …\nCast vector of type __m512d to type __m512. This intrinsic …\nCast vector of type __m512d to type __m512i. This …\nCast vector of type __m128 to type __m512; the upper 384 …\nCast vector of type __m256 to type __m512; the upper 256 …\nCast vector of type __m512 to type __m128. This intrinsic …\nCast vector of type __m512 to type __m256. This intrinsic …\nCast vector of type __m512 to type __m512d. This intrinsic …\nCast vector of type __m512 to type __m512i. This intrinsic …\nCast vector of type __m128i to type __m512i; the upper 384 …\nCast vector of type __m256i to type __m512i; the upper 256 …\nCast vector of type __m512i to type __m512d. This …\nCast vector of type __m512i to type __m512. This intrinsic …\nCast vector of type __m512i to type __m128i. This …\nCast vector of type __m512i to type __m256i. This …\nPerforms a carry-less multiplication of two 64-bit …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for equality, …\nCompare packed 64-bit integers in a and b for equality, …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nPerforms element-by-element conversion of the lower half …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 8 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nPerforms element-by-element conversion of the lower half …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 8 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nPerforms an element-by-element conversion of packed …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nPerforms element-by-element conversion of the lower half …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nCopy the lower 32-bit integer in a to dst.\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nExtract 128 bits (composed of 4 packed single-precision …\nExtract 256 bits (composed of 4 packed double-precision …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nExtract 256 bits (composed of 4 packed 64-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nGather 32-bit integers from memory using 32-bit indices. …\nGather 64-bit integers from memory using 32-bit indices. …\nGather double-precision (64-bit) floating-point elements …\nGather single-precision (32-bit) floating-point elements …\nScatter 32-bit integers from a into memory using 32-bit …\nScatter 64-bit integers from a into memory using 32-bit …\nScatter double-precision (64-bit) floating-point elements …\nScatter single-precision (32-bit) floating-point elements …\nGather 32-bit integers from memory using 64-bit indices. …\nGather 64-bit integers from memory using 64-bit indices. …\nGather double-precision (64-bit) floating-point elements …\nGather single-precision (32-bit) floating-point elements …\nScatter 32-bit integers from a into memory using 64-bit …\nScatter 64-bit integers from a into memory using 64-bit …\nScatter double-precision (64-bit) floating-point elements …\nScatter single-precision (32-bit) floating-point elements …\nCopy a to dst, then insert 128 bits (composed of 4 packed …\nCopy a to dst, then insert 256 bits (composed of 4 packed …\nCopy a to dst, then insert 128 bits (composed of 4 packed …\nCopy a to dst, then insert 256 bits (composed of 4 packed …\nConverts integer mask into bitmask, storing the result in …\nCompute the bitwise AND of 16-bit masks a and b, and store …\nCompute the bitwise NOT of 16-bit masks a and then AND …\nCopy 16-bit mask a to k.\nCompute the bitwise NOT of 16-bit mask a, and store the …\nCompute the bitwise OR of 16-bit masks a and b, and store …\nPerforms bitwise OR between k1 and k2, storing the result …\nUnpack and interleave 8 bits from masks a and b, and store …\nCompute the bitwise XNOR of 16-bit masks a and b, and …\nCompute the bitwise XOR of 16-bit masks a and b, and store …\nLoad 512-bits (composed of 16 packed 32-bit integers) from …\nLoad 512-bits (composed of 8 packed 64-bit integers) from …\nLoad 512-bits (composed of 8 packed double-precision …\nLoad 512-bits (composed of 16 packed single-precision …\nLoad 512-bits of integer data from memory into dst. …\nLoad 512-bits (composed of 32 packed 16-bit integers) from …\nLoad 512-bits (composed of 16 packed 32-bit integers) from …\nLoad 512-bits (composed of 8 packed 64-bit integers) from …\nLoad 512-bits (composed of 64 packed 8-bit integers) from …\nLoads 512-bits (composed of 8 packed double-precision …\nLoads 512-bits (composed of 16 packed single-precision …\nLoad 512-bits of integer data from memory into dst. …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiply packed signed 16-bit integers in a and b, …\nVertically multiply each unsigned 8-bit integer from a …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nConverts bit mask k1 into an integer value, storing the …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nCompute the absolute value of packed signed 16-bit …\nComputes the absolute value of packed 32-bit integers in <code>a</code>…\nCompute the absolute value of packed signed 64-bit …\nCompute the absolute value of packed signed 8-bit integers …\nFinds the absolute value of each packed double-precision …\nFinds the absolute value of each packed single-precision …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 128-byte immediate result, …\nConcatenate a and b into a 128-byte immediate result, …\nConcatenate pairs of 16-byte blocks in a and b into a …\nPerforms element-by-element bitwise AND between packed …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlend packed 16-bit integers from a and b using control …\nBlend packed 32-bit integers from a and b using control …\nBlend packed 64-bit integers from a and b using control …\nBlend packed 8-bit integers from a and b using control …\nBlend packed double-precision (64-bit) floating-point …\nBlend packed single-precision (32-bit) floating-point …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed double-precision (64-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcast the 4 packed 64-bit integers from a to all …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low double-precision (64-bit) floating-point …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for equality, …\nCompare packed 64-bit integers in a and b for equality, …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 32-bit integers in a to packed 16-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nPerforms element-by-element conversion of the lower half …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 8 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nPerforms element-by-element conversion of the lower half …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 8 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nPerforms an element-by-element conversion of packed …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nPerforms element-by-element conversion of the lower half …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active single-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nExtract 128 bits (composed of 4 packed single-precision …\nExtract 256 bits (composed of 4 packed double-precision …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nExtract 256 bits (composed of 4 packed 64-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nGather 32-bit integers from memory using 32-bit indices. …\nGather 64-bit integers from memory using 32-bit indices. …\nGather double-precision (64-bit) floating-point elements …\nGather single-precision (32-bit) floating-point elements …\nScatter 32-bit integers from a into memory using 32-bit …\nScatter 64-bit integers from a into memory using 32-bit …\nScatter double-precision (64-bit) floating-point elements …\nScatter single-precision (32-bit) floating-point elements …\nGather 32-bit integers from memory using 64-bit indices. …\nGather 64-bit integers from memory using 64-bit indices. …\nGather double-precision (64-bit) floating-point elements …\nGather single-precision (32-bit) floating-point elements …\nScatter 32-bit integers from a into memory using 64-bit …\nScatter 64-bit integers from a into memory using 64-bit …\nScatter double-precision (64-bit) floating-point elements …\nScatter single-precision (32-bit) floating-point elements …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nCopy a to tmp, then insert 256 bits (composed of 4 packed …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nCopy a to tmp, then insert 256 bits (composed of 4 packed …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using …\nMove packed 32-bit integers from a to dst using writemask …\nMove packed 64-bit integers from a to dst using writemask …\nMove packed 8-bit integers from a into dst using writemask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nMultiplies elements in packed 64-bit integer vectors a and …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 32-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nReduce the packed 32-bit integers in a by addition using …\nReduce the packed 64-bit integers in a by addition using …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by bitwise AND …\nReduce the packed 64-bit integers in a by addition using …\nReduce the packed signed 32-bit integers in a by maximum …\nReduce the packed signed 64-bit integers in a by maximum …\nReduce the packed unsigned 32-bit integers in a by maximum …\nReduce the packed unsigned 64-bit integers in a by maximum …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed signed 32-bit integers in a by maximum …\nReduce the packed signed 64-bit integers in a by maximum …\nReduce the packed unsigned 32-bit integers in a by maximum …\nReduce the packed signed 64-bit integers in a by maximum …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by multiplication …\nReduce the packed 64-bit integers in a by multiplication …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by bitwise OR using …\nReduce the packed 64-bit integers in a by bitwise OR using …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast 16-bit integer a to all elements of dst using …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle 8-bit integers in a within 128-bit lanes using the …\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nStore packed 16-bit integers from a into memory using …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed 8-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nCompute the absolute value of packed signed 16-bit …\nComputes the absolute value of packed 32-bit integers in <code>a</code>…\nCompute the absolute value of packed signed 64-bit …\nCompute the absolute value of packed signed 8-bit integers …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 128-byte immediate result, …\nConcatenate a and b into a 128-byte immediate result, …\nConcatenate pairs of 16-byte blocks in a and b into a …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed double-precision (64-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcast the 4 packed 64-bit integers from a to all …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low double-precision (64-bit) floating-point …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 8 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 8 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active single-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nExtract 128 bits (composed of 4 packed single-precision …\nExtract 256 bits (composed of 4 packed double-precision …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nExtract 256 bits (composed of 4 packed 64-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nCopy a to tmp, then insert 256 bits (composed of 4 packed …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nCopy a to tmp, then insert 256 bits (composed of 4 packed …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using zeromask …\nMove packed 32-bit integers from a into dst using zeromask …\nMove packed 64-bit integers from a into dst using zeromask …\nMove packed 8-bit integers from a into dst using zeromask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle packed 8-bit integers in a according to shuffle …\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nSet each bit of mask register k based on the most …\nSet each bit of mask register k based on the most …\nSet each packed 16-bit integer in dst to all ones or all …\nSet each packed 8-bit integer in dst to all ones or all …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nMultiplies elements in packed 64-bit integer vectors a and …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nCompute the bitwise OR of 512 bits (representing integer …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 32-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nReduce the packed 32-bit integers in a by addition. …\nReduce the packed 64-bit integers in a by addition. …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by bitwise AND. …\nReduce the packed 64-bit integers in a by bitwise AND. …\nReduce the packed signed 32-bit integers in a by maximum. …\nReduce the packed signed 64-bit integers in a by maximum. …\nReduce the packed unsigned 32-bit integers in a by …\nReduce the packed unsigned 64-bit integers in a by …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed signed 32-bit integers in a by minimum. …\nReduce the packed signed 64-bit integers in a by minimum. …\nReduce the packed unsigned 32-bit integers in a by …\nReduce the packed unsigned 64-bit integers in a by …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by multiplication. …\nReduce the packed 64-bit integers in a by multiplication. …\nReduce the packed double-precision (64-bit) floating-point …\nReduce the packed single-precision (32-bit) floating-point …\nReduce the packed 32-bit integers in a by bitwise OR. …\nReduce the packed 64-bit integers in a by bitwise OR. …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nCompute the absolute differences of packed unsigned 8-bit …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nBroadcast 32-bit integer <code>a</code> to all elements of <code>dst</code>.\nBroadcast 64-bit integer <code>a</code> to all elements of <code>dst</code>.\nBroadcast 8-bit integer a to all elements of dst.\nBroadcast 64-bit float <code>a</code> to all elements of <code>dst</code>.\nBroadcast 32-bit float <code>a</code> to all elements of <code>dst</code>.\nSet packed 32-bit integers in dst with the repeated 4 …\nSet packed 64-bit integers in dst with the repeated 4 …\nSet packed double-precision (64-bit) floating-point …\nSet packed single-precision (32-bit) floating-point …\nSet packed 16-bit integers in dst with the supplied values.\nSets packed 32-bit integers in <code>dst</code> with the supplied …\nSet packed 64-bit integers in dst with the supplied values.\nSet packed 8-bit integers in dst with the supplied values.\nSet packed double-precision (64-bit) floating-point …\nSets packed 32-bit integers in <code>dst</code> with the supplied …\nSet packed 32-bit integers in dst with the repeated 4 …\nSet packed 64-bit integers in dst with the repeated 4 …\nSet packed double-precision (64-bit) floating-point …\nSet packed single-precision (32-bit) floating-point …\nSets packed 32-bit integers in <code>dst</code> with the supplied …\nSet packed 64-bit integers in dst with the supplied values …\nSet packed double-precision (64-bit) floating-point …\nSets packed 32-bit integers in <code>dst</code> with the supplied …\nReturn vector of type __m512 with all elements set to zero.\nReturn vector of type __m512i with all elements set to …\nReturns vector of type <code>__m512d</code> with all elements set to …\nReturns vector of type <code>__m512d</code> with all elements set to …\nReturns vector of type <code>__m512i</code> with all elements set to …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle packed 8-bit integers in a according to shuffle …\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nStore 512-bits (composed of 16 packed 32-bit integers) …\nStore 512-bits (composed of 8 packed 64-bit integers) from …\nStore 512-bits (composed of 8 packed double-precision …\nStore 512-bits of integer data from a into memory. …\nStore 512-bits of integer data from a into memory. …\nStore 512-bits (composed of 32 packed 16-bit integers) …\nStore 512-bits (composed of 16 packed 32-bit integers) …\nStore 512-bits (composed of 8 packed 64-bit integers) from …\nStore 512-bits (composed of 64 packed 8-bit integers) from …\nStores 512-bits (composed of 8 packed double-precision …\nStores 512-bits (composed of 16 packed single-precision …\nStore 512-bits of integer data from a into memory. …\nStore 512-bits (composed of 8 packed double-precision …\nStore 512-bits (composed of 16 packed single-precision …\nStore 512-bits of integer data from a into memory using a …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nReturn vector of type __m512 with indeterminate elements. …\nReturn vector of type __m512i with indeterminate elements. …\nReturns vector of type <code>__m512d</code> with indeterminate elements.\nReturns vector of type <code>__m512</code> with indeterminate elements. …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nCompute the bitwise XOR of 512 bits (representing integer …\nCast vector of type __m128d to type __m512d; the upper 384 …\nCast vector of type __m256d to type __m512d; the upper 256 …\nCast vector of type __m128 to type __m512; the upper 384 …\nCast vector of type __m256 to type __m512; the upper 256 …\nCast vector of type __m128i to type __m512i; the upper 384 …\nCast vector of type __m256i to type __m512i; the upper 256 …\nComputes the absolute value of each of the packed 16-bit …\nComputes the absolute value of each of the packed 32-bit …\nComputes the absolute value of packed 8-bit signed …\nAdds packed 16-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 32-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 64-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 8-bit integers in <code>a</code> and <code>b</code>.\nAdds packed double-precision (64-bit) floating-point …\nAdds __m128 vectors.\nAdd the lower double-precision (64-bit) floating-point …\nAdd the lower single-precision (32-bit) floating-point …\nReturns a new vector with the low element of <code>a</code> replaced by …\nAdds the first component of <code>a</code> and <code>b</code>, the other components …\nAdds packed 16-bit integers in <code>a</code> and <code>b</code> using saturation.\nAdds packed 8-bit integers in <code>a</code> and <code>b</code> using saturation.\nAdds packed unsigned 16-bit integers in <code>a</code> and <code>b</code> using …\nAdds packed unsigned 8-bit integers in <code>a</code> and <code>b</code> using …\nAlternatively add and subtract packed double-precision …\nAlternatively add and subtract packed single-precision …\nPerforms one round of an AES decryption flow on data …\nPerforms the last round of an AES decryption flow on data …\nPerforms one round of an AES encryption flow on data …\nPerforms the last round of an AES encryption flow on data …\nPerforms the <code>InvMixColumns</code> transformation on <code>a</code>.\nAssist in expanding the AES cipher key.\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate 16-byte blocks in <code>a</code> and <code>b</code> into a 32-byte …\nComputes the bitwise AND of packed double-precision …\nBitwise AND of packed single-precision (32-bit) …\nComputes the bitwise AND of 128 bits (representing integer …\nComputes the bitwise NOT of <code>a</code> and then AND with <code>b</code>.\nBitwise AND-NOT of packed single-precision (32-bit) …\nComputes the bitwise NOT of 128 bits (representing integer …\nAverages packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.\nAverages packed unsigned 8-bit integers in <code>a</code> and <code>b</code>.\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlend packed 16-bit integers from <code>a</code> and <code>b</code> using the mask …\nBlends packed 32-bit integers from <code>a</code> and <code>b</code> using control …\nBlend packed double-precision (64-bit) floating-point …\nBlend packed single-precision (32-bit) floating-point …\nBlend packed 8-bit integers from <code>a</code> and <code>b</code> using <code>mask</code>\nBlend packed double-precision (64-bit) floating-point …\nBlend packed single-precision (32-bit) floating-point …\nBroadcasts a single-precision (32-bit) floating-point …\nBroadcasts the low packed 8-bit integer from <code>a</code> to all …\nBroadcasts the low packed 32-bit integer from <code>a</code> to all …\nBroadcast the low 8-bits from input mask k to all 64-bit …\nBroadcast the low 16-bits from input mask k to all 32-bit …\nBroadcasts the low packed 64-bit integer from <code>a</code> to all …\nBroadcasts the low double-precision (64-bit) …\nBroadcasts the low single-precision (32-bit) …\nBroadcasts the low packed 16-bit integer from a to all …\nShifts <code>a</code> left by <code>IMM8</code> bytes while shifting in zeros.\nShifts <code>a</code> right by <code>IMM8</code> bytes while shifting in zeros.\nCasts a 128-bit floating-point vector of <code>[2 x double]</code> into …\nCasts a 128-bit floating-point vector of <code>[2 x double]</code> into …\nCasts a 128-bit floating-point vector of <code>[4 x float]</code> into …\nCasts a 128-bit floating-point vector of <code>[4 x float]</code> into …\nCasts a 128-bit integer vector into a 128-bit …\nCasts a 128-bit integer vector into a 128-bit …\nRound the packed double-precision (64-bit) floating-point …\nRound the packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nInvalidates and flushes the cache line that contains <code>p</code> …\nPerforms a carry-less multiplication of two 64-bit …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompares packed double-precision (64-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompares packed single-precision (32-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompares the lower double-precision (64-bit) …\nCompare the lower double-precision (64-bit) floating-point …\nCompares the lower single-precision (32-bit) …\nCompare the lower single-precision (32-bit) floating-point …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed 32-bit integers in a and b for equality, …\nCompares packed 64-bit integers in <code>a</code> and <code>b</code> for equality\nCompare packed 64-bit integers in a and b for equality, …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for equality.\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for equality. The …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for greater than or …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 32-bit integers in a and b for …\nCompares packed 64-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 64-bit integers in a and b for …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for greater-than.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for greater than. …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompares packed strings with implicit lengths in <code>a</code> and <code>b</code> …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for less than or …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for less-than.\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for less-than.\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for less-than.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for less-than.\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for less than. The …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for not-equal.\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for inequality. The …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for …\nCompares corresponding elements in <code>a</code> and <code>b</code> for …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the lowest <code>f32</code> of both inputs for not-less-than. …\nCompares corresponding elements in <code>a</code> and <code>b</code> to see if …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nChecks if the lowest <code>f32</code> of both inputs are ordered. The …\nCompares corresponding elements in <code>a</code> and <code>b</code> to see if …\nCompares each of the four floats in <code>a</code> to the corresponding …\nReturns a new vector with the low element of <code>a</code> replaced by …\nChecks if the lowest <code>f32</code> of both inputs are unordered. The …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompares the lower element of <code>a</code> and <code>b</code> for equality.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for …\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for greater-than.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for …\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for less-than.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for not-equal.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nStarting with the initial value in <code>crc</code>, return the …\nStarting with the initial value in <code>crc</code>, return the …\nStarting with the initial value in <code>crc</code>, return the …\nStarting with the initial value in <code>crc</code>, return the …\nConvert the signed 32-bit integer b to a single-precision …\nConvert the signed 64-bit integer b to a double-precision …\nConvert the signed 64-bit integer b to a single-precision …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the signed 32-bit integer b to a single-precision …\nConvert the signed 64-bit integer b to a double-precision …\nConvert the signed 64-bit integer b to a single-precision …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the unsigned 32-bit integer b to a …\nConvert the unsigned 64-bit integer b to a …\nConvert the unsigned 64-bit integer b to a …\nAlias for <code>_mm_cvtsi32_ss</code>.\nAlias for <code>_mm_cvtss_si32</code>.\nSign extend packed 16-bit integers in <code>a</code> to packed 32-bit …\nSign extend packed 16-bit integers in <code>a</code> to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in <code>a</code> to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConverts the lower two packed 32-bit integers in <code>a</code> to …\nConverts packed 32-bit integers in <code>a</code> to packed …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in <code>a</code> to packed 16-bit …\nSign extend packed 8-bit integers in <code>a</code> to packed 32-bit …\nSign extend packed 8-bit integers in the low 8 bytes of <code>a</code> …\nZeroes extend packed unsigned 16-bit integers in <code>a</code> to …\nZeroes extend packed unsigned 16-bit integers in <code>a</code> to …\nZeroes extend packed unsigned 32-bit integers in <code>a</code> to …\nConvert packed unsigned 32-bit integers in a to packed …\nZeroes extend packed unsigned 8-bit integers in <code>a</code> to …\nZeroes extend packed unsigned 8-bit integers in <code>a</code> to …\nZeroes extend packed unsigned 8-bit integers in <code>a</code> to …\nConvert the signed 32-bit integer b to a double-precision …\nConvert the signed 32-bit integer b to a single-precision …\nConvert the signed 64-bit integer b to a double-precision …\nConvert the signed 64-bit integer b to a single-precision …\nConvert packed single-precision (32-bit) floating-point …\nConverts packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConverts packed double-precision (64-bit) floating-point …\nConverts the 4 x 16-bit half-precision float values in the …\nConverts packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConverts packed single-precision (32-bit) floating-point …\nConverts the 4 x 32-bit float values in the 128-bit vector …\nReturns the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConverts the lower double-precision (64-bit) …\nConverts the lower double-precision (64-bit) …\nAlias for <code>_mm_cvtsd_si64</code>\nConverts the lower double-precision (64-bit) …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nReturns the lowest element of <code>a</code>.\nReturns the lowest element of <code>a</code>.\nReturns the lowest element of <code>a</code>.\nReturns <code>a</code> with its lower element replaced by <code>b</code> after …\nReturns a vector whose lowest element is <code>a</code> and all higher …\nConverts a 32 bit integer to a 32 bit float. The result …\nReturns <code>a</code> with its lower element replaced by <code>b</code> after …\nReturns a vector whose lowest element is <code>a</code> and all higher …\nConverts a 64 bit integer to a 32 bit float. The result …\nReturns <code>a</code> with its lower element replaced by <code>b</code> after …\nReturns a vector whose lowest element is <code>a</code> and all higher …\nExtracts the lowest 32 bit float from the input vector.\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConverts the lower single-precision (32-bit) …\nConverts the lowest 32 bit float in the input vector to a …\nConverts the lowest 32 bit float in the input vector to a …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nAlias for <code>_mm_cvttss_si32</code>.\nConverts packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConverts packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConverts the lower double-precision (64-bit) …\nConverts the lower double-precision (64-bit) …\nAlias for <code>_mm_cvttsd_si64</code>\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConverts the lowest 32 bit float in the input vector to a …\nConverts the lowest 32 bit float in the input vector to a …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nConvert the unsigned 32-bit integer b to a …\nConvert the unsigned 32-bit integer b to a …\nConvert the unsigned 64-bit integer b to a …\nConvert the unsigned 64-bit integer b to a …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivides __m128 vectors.\nDivide the lower double-precision (64-bit) floating-point …\nDivide the lower single-precision (32-bit) floating-point …\nReturns a new vector with the low element of <code>a</code> replaced by …\nDivides the first component of <code>b</code> by <code>a</code>, the other …\nReturns the dot product of two __m128d vectors.\nReturns the dot product of two __m128 vectors.\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nReturns the <code>imm8</code> element of <code>a</code>.\nExtracts an 32-bit integer from <code>a</code> selected with <code>IMM8</code>\nExtracts an 64-bit integer from <code>a</code> selected with <code>IMM1</code>\nExtracts an 8-bit integer from <code>a</code>, selected with <code>IMM8</code>. …\nExtracts a single-precision (32-bit) floating-point …\nExtracts the bit range specified by <code>y</code> from the lower 64 …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nRound the packed double-precision (64-bit) floating-point …\nRound the packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiplies the lower double-precision (64-bit) …\nMultiplies the lower single-precision (32-bit) …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiplies the lower double-precision (64-bit) …\nMultiplies the lower single-precision (32-bit) …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiplies the lower double-precision (64-bit) …\nMultiplies the lower single-precision (32-bit) …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiplies the lower double-precision (64-bit) …\nMultiplies the lower single-precision (32-bit) …\nGets the unsigned 32-bit value of the MXCSR control and …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nHorizontally adds the adjacent pairs of values contained …\nHorizontally adds the adjacent pairs of values contained …\nHorizontally adds adjacent pairs of double-precision …\nHorizontally adds adjacent pairs of single-precision …\nHorizontally adds the adjacent pairs of values contained …\nHorizontally subtract the adjacent pairs of values …\nHorizontally subtract the adjacent pairs of values …\nHorizontally subtract adjacent pairs of double-precision …\nHorizontally adds adjacent pairs of single-precision …\nHorizontally subtract the adjacent pairs of values …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns a new vector where the <code>imm8</code> element of <code>a</code> is …\nReturns a copy of <code>a</code> with the 32-bit integer from <code>i</code> …\nReturns a copy of <code>a</code> with the 64-bit integer from <code>i</code> …\nReturns a copy of <code>a</code> with the 8-bit integer from <code>i</code> inserted …\nSelect a single value in <code>a</code> to store at some position in <code>b</code>, …\nInserts the <code>[length:0]</code> bits of <code>y</code> into <code>x</code> at <code>index</code>.\nLoads 128-bits of integer data from unaligned memory. This …\nPerforms a serializing operation on all load-from-memory …\nLoads a double-precision (64-bit) floating-point element …\nConstruct a <code>__m128</code> by duplicating the value read from <code>p</code> …\nLoad 128-bits (composed of 4 packed 32-bit integers) from …\nLoad 128-bits (composed of 2 packed 64-bit integers) from …\nLoads 128-bits (composed of 2 packed double-precision …\nLoads a double-precision (64-bit) floating-point element …\nLoads four <code>f32</code> values from <em>aligned</em> memory into a <code>__m128</code>. …\nAlias for <code>_mm_load1_ps</code>\nLoads a 64-bit double-precision value to the low element …\nLoads 128-bits of integer data from memory into a new …\nConstruct a <code>__m128</code> with the lowest element read from <code>p</code> and …\nLoads a double-precision (64-bit) floating-point element …\nLoads a double-precision value into the high-order bits of …\nLoads 64-bit integer from memory into first element of …\nLoads a double-precision value into the low-order bits of …\nLoads 2 double-precision (64-bit) floating-point elements …\nLoads four <code>f32</code> values from aligned memory into a <code>__m128</code> in …\nLoad 128-bits (composed of 8 packed 16-bit integers) from …\nLoad 128-bits (composed of 4 packed 32-bit integers) from …\nLoad 128-bits (composed of 2 packed 64-bit integers) from …\nLoad 128-bits (composed of 16 packed 8-bit integers) from …\nLoads 128-bits (composed of 2 packed double-precision …\nLoads four <code>f32</code> values from memory into a <code>__m128</code>. There are …\nLoads 128-bits of integer data from memory into a new …\nLoads unaligned 64-bits of integer data from memory into …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiplies and then horizontally add signed 16 bit …\nMultiplies corresponding pairs of packed 8-bit unsigned …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nCompute the absolute value of packed signed 16-bit …\nCompute the absolute value of packed signed 32-bit …\nCompute the absolute value of packed signed 8-bit integers …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd the lower double-precision (64-bit) floating-point …\nAdd the lower single-precision (32-bit) floating-point …\nAdd the lower double-precision (64-bit) floating-point …\nAdd the lower single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate pairs of 16-byte blocks in a and b into a …\nPerforms element-by-element bitwise AND between packed …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlend packed 16-bit integers from a and b using control …\nBlend packed 32-bit integers from a and b using control …\nBlend packed 64-bit integers from a and b using control …\nBlend packed 8-bit integers from a and b using control …\nBlend packed double-precision (64-bit) floating-point …\nBlend packed single-precision (32-bit) floating-point …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for equality, …\nCompare packed 64-bit integers in a and b for equality, …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 32-bit integers in a to packed 16-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 2 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in the low 4 …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 4 …\nZero extend packed unsigned 8-bit integers in the low 2 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert the lower single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nDivide the lower double-precision (64-bit) floating-point …\nDivide the lower single-precision (32-bit) floating-point …\nDivide the lower double-precision (64-bit) floating-point …\nDivide the lower single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active single-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using …\nMove packed 32-bit integers from a to dst using writemask …\nMove packed 64-bit integers from a to dst using writemask …\nMove packed 8-bit integers from a into dst using writemask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nMove the lower double-precision (64-bit) floating-point …\nMove the lower single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of the lower …\nCompute the approximate reciprocal of the lower …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of the …\nCompute the approximate reciprocal square root of the …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast 16-bit integer a to all elements of dst using …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle 8-bit integers in a within 128-bit lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nCompute the square root of the lower double-precision …\nCompute the square root of the lower single-precision …\nCompute the square root of the lower double-precision …\nCompute the square root of the lower single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nStore packed 16-bit integers from a into memory using …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed 8-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract the lower double-precision (64-bit) …\nSubtract the lower single-precision (32-bit) …\nSubtract the lower double-precision (64-bit) …\nSubtract the lower single-precision (32-bit) …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nLoads packed 32-bit integers from memory pointed by …\nLoads packed 64-bit integers from memory pointed by …\nLoads packed double-precision (64-bit) floating-point …\nLoads packed single-precision (32-bit) floating-point …\nConditionally store 8-bit integer elements from <code>a</code> into …\nStores packed 32-bit integers from <code>a</code> into memory pointed …\nStores packed 64-bit integers from <code>a</code> into memory pointed …\nStores packed double-precision (64-bit) floating-point …\nStores packed single-precision (32-bit) floating-point …\nCompute the absolute value of packed signed 16-bit …\nCompute the absolute value of packed signed 32-bit …\nCompute the absolute value of packed signed 8-bit integers …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd the lower double-precision (64-bit) floating-point …\nAdd the lower single-precision (32-bit) floating-point …\nAdd the lower double-precision (64-bit) floating-point …\nAdd the lower single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate a and b into a 32-byte immediate result, shift …\nConcatenate pairs of 16-byte blocks in a and b into a …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert the lower single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 2 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in the low 4 …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in th elow 4 …\nZero extend packed unsigned 8-bit integers in the low 2 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert the lower double-precision (64-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert the lower single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nDivide the lower double-precision (64-bit) floating-point …\nDivide the lower single-precision (32-bit) floating-point …\nDivide the lower double-precision (64-bit) floating-point …\nDivide the lower single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active single-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nFix up the lower double-precision (64-bit) floating-point …\nFix up the lower single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nConvert the exponent of the lower double-precision …\nConvert the exponent of the lower single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nNormalize the mantissas of the lower double-precision …\nNormalize the mantissas of the lower single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using zeromask …\nMove packed 32-bit integers from a into dst using zeromask …\nMove packed 64-bit integers from a into dst using zeromask …\nMove packed 8-bit integers from a into dst using zeromask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nMove the lower double-precision (64-bit) floating-point …\nMove the lower single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of the lower …\nCompute the approximate reciprocal of the lower …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of the …\nCompute the approximate reciprocal square root of the …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle packed 8-bit integers in a according to shuffle …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nCompute the square root of the lower double-precision …\nCompute the square root of the lower single-precision …\nCompute the square root of the lower double-precision …\nCompute the square root of the lower single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract the lower double-precision (64-bit) …\nSubtract the lower single-precision (32-bit) …\nSubtract the lower double-precision (64-bit) …\nSubtract the lower single-precision (32-bit) …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompare packed signed 64-bit integers in a and b, and …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> and returns …\nCompares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and …\nReturns a new vector with the maximum values from …\nCompares packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the first single-precision (32-bit) …\nPerforms a serializing operation on all load-from-memory …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> and returns …\nCompares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and …\nReturns a new vector with the minimum values from …\nCompares packed single-precision (32-bit) floating-point …\nCompare the lower double-precision (64-bit) floating-point …\nCompare the lower single-precision (32-bit) floating-point …\nReturns a new vector with the low element of <code>a</code> replaced by …\nCompares the first single-precision (32-bit) …\nFinds the minimum unsigned 16-bit element in the 128-bit __…\nReturns a vector where the low element is extracted from <code>a</code> …\nConstructs a 128-bit floating-point vector of <code>[2 x double]</code>…\nReturns a <code>__m128</code> with the first component from <code>b</code> and the …\nDuplicate the low double-precision (64-bit) floating-point …\nDuplicate odd-indexed single-precision (32-bit) …\nCombine higher half of <code>a</code> and <code>b</code>. The higher half of <code>b</code> …\nDuplicate even-indexed single-precision (32-bit) …\nCombine lower half of <code>a</code> and <code>b</code>. The lower half of <code>b</code> …\nReturns a mask of the most significant bit of each element …\nReturns a mask of the most significant bit of each element …\nReturns a mask of the most significant bit of each element …\nSet each bit of mask register k based on the most …\nSet each bit of mask register k based on the most …\nSet each packed 16-bit integer in dst to all ones or all …\nSet each packed 8-bit integer in dst to all ones or all …\nSubtracts 8-bit unsigned integer values and computes the …\nMultiplies the low 32-bit integers from each packed 64-bit …\nMultiplies the low unsigned 32-bit integers from each …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies __m128 vectors.\nMultiply the lower double-precision (64-bit) …\nMultiply the lower single-precision (32-bit) …\nReturns a new vector with the low element of <code>a</code> replaced by …\nMultiplies the first component of <code>a</code> and <code>b</code>, the other …\nMultiplies the packed 16-bit integers in <code>a</code> and <code>b</code>.\nMultiplies the packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.\nMultiplies packed 16-bit signed integer values, truncate …\nMultiplies the packed 16-bit integers in <code>a</code> and <code>b</code>.\nMultiplies the packed 32-bit integers in <code>a</code> and <code>b</code>, …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nComputes the bitwise OR of <code>a</code> and <code>b</code>.\nBitwise OR of packed single-precision (32-bit) …\nComputes the bitwise OR of 128 bits (representing integer …\nConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed …\nProvides a hint to the processor that the code sequence is …\nShuffles double-precision (64-bit) floating-point elements …\nShuffles single-precision (32-bit) floating-point elements …\nShuffles double-precision (64-bit) floating-point elements …\nShuffles single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nFetch the cache line that contains address <code>p</code> using the …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of the lower …\nCompute the approximate reciprocal of the lower …\nReturns the approximate reciprocal of packed …\nReturns the approximate reciprocal of the first …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound the packed double-precision (64-bit) floating-point …\nRound the packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nRound the lower double-precision (64-bit) floating-point …\nRound the lower single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of the …\nCompute the approximate reciprocal square root of the …\nReturns the approximate reciprocal square root of packed …\nReturns the approximate reciprocal square root of the …\nSum the absolute differences of packed unsigned 8-bit …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcasts 16-bit integer <code>a</code> to all elements.\nBroadcasts 32-bit integer <code>a</code> to all elements.\nBroadcasts 64-bit integer <code>a</code> to all elements.\nBroadcasts 8-bit integer <code>a</code> to all elements.\nBroadcasts double-precision (64-bit) floating-point value …\nConstruct a <code>__m128</code> with all element set to <code>a</code>.\nSets packed 16-bit integers with the supplied values.\nSets packed 32-bit integers with the supplied values.\nSets packed 64-bit integers with the supplied values, from …\nSets packed 8-bit integers with the supplied values.\nSets packed double-precision (64-bit) floating-point …\nBroadcasts double-precision (64-bit) floating-point value …\nConstruct a <code>__m128</code> from four floating point values highest …\nAlias for <code>_mm_set1_ps</code>\nCopies double-precision (64-bit) floating-point element <code>a</code> …\nConstruct a <code>__m128</code> with the lowest element set to <code>a</code> and …\nSets the MXCSR register with the 32-bit unsigned integer …\nSets packed 16-bit integers with the supplied values in …\nSets packed 32-bit integers with the supplied values in …\nSets packed 8-bit integers with the supplied values in …\nSets packed double-precision (64-bit) floating-point …\nConstruct a <code>__m128</code> from four floating point values lowest …\nReturns packed double-precision (64-bit) floating-point …\nConstruct a <code>__m128</code> with all elements initialized to zero.\nReturns a vector with all elements set to zero.\nPerforms a serializing operation on all store-to-memory …\nPerforms an intermediate calculation for the next four …\nPerforms the final calculation for the next four SHA1 …\nCalculate SHA1 state variable E after four rounds of …\nPerforms four rounds of SHA1 operation using an initial …\nPerforms an intermediate calculation for the next four …\nPerforms the final calculation for the next four SHA256 …\nPerforms 2 rounds of SHA256 operation using an initial …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffles 32-bit integers in <code>a</code> using the control in <code>IMM8</code>.\nShuffles bytes from <code>a</code> according to the content of <code>b</code>.\nConstructs a 128-bit floating-point vector of <code>[2 x double]</code> …\nShuffles packed single-precision (32-bit) floating-point …\nShuffles 16-bit integers in the high 64 bits of <code>a</code> using …\nShuffles 16-bit integers in the low 64 bits of <code>a</code> using the …\nNegates packed 16-bit integers in <code>a</code> when the corresponding …\nNegates packed 32-bit integers in <code>a</code> when the corresponding …\nNegates packed 8-bit integers in <code>a</code> when the corresponding …\nShifts packed 16-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 64-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 16-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts packed 64-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts <code>a</code> left by <code>IMM8</code> bytes while shifting in zeros.\nShift packed 16-bit integers in a left by the amount …\nShifts packed 32-bit integers in <code>a</code> left by the amount …\nShifts packed 64-bit integers in <code>a</code> left by the amount …\nReturns a new vector with the square root of each of the …\nReturns the square root of packed single-precision …\nCompute the square root of the lower double-precision …\nCompute the square root of the lower single-precision …\nReturns a new vector with the low element of <code>a</code> replaced by …\nReturns the square root of the first single-precision …\nShifts packed 16-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>count</code> while …\nShift packed 64-bit integers in a right by count while …\nShifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShifts packed 32-bit integers in <code>a</code> right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShifts packed 16-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 64-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 64-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts <code>a</code> right by <code>IMM8</code> bytes while shifting in zeros.\nShift packed 16-bit integers in a right by the amount …\nShifts packed 32-bit integers in <code>a</code> right by the amount …\nShifts packed 64-bit integers in <code>a</code> right by the amount …\nStores the lower double-precision (64-bit) floating-point …\nStores the lowest 32 bit float of <code>a</code> repeated four times …\nStore 128-bits (composed of 4 packed 32-bit integers) from …\nStore 128-bits (composed of 2 packed 64-bit integers) from …\nStores 128-bits (composed of 2 packed double-precision …\nStores the lower double-precision (64-bit) floating-point …\nStores four 32-bit floats into <em>aligned</em> memory.\nAlias for <code>_mm_store1_ps</code>\nStores the lower 64 bits of a 128-bit vector of …\nStores 128-bits of integer data from <code>a</code> into memory.\nStores the lowest 32 bit float of <code>a</code> into memory.\nStores the upper 64 bits of a 128-bit vector of …\nStores the lower 64-bit integer <code>a</code> to a memory location.\nStores the lower 64 bits of a 128-bit vector of …\nStores 2 double-precision (64-bit) floating-point elements …\nStores four 32-bit floats into <em>aligned</em> memory in reverse …\nStore 128-bits (composed of 8 packed 16-bit integers) from …\nStore 128-bits (composed of 4 packed 32-bit integers) from …\nStore 128-bits (composed of 2 packed 64-bit integers) from …\nStore 128-bits (composed of 16 packed 8-bit integers) from …\nStores 128-bits (composed of 2 packed double-precision …\nStores four 32-bit floats into memory. There are no …\nStores 128-bits of integer data from <code>a</code> into memory.\nStores a 128-bit floating point vector of <code>[2 x double]</code> to …\nStores <code>a</code> into the memory at <code>mem_addr</code> using a non-temporal …\nNon-temporal store of <code>a.0</code> into <code>p</code>.\nStores a 128-bit integer vector to a 128-bit aligned …\nStores a 32-bit integer value in the specified memory …\nStores a 64-bit integer value in the specified memory …\nNon-temporal store of <code>a.0</code> into <code>p</code>.\nSubtracts packed 16-bit integers in <code>b</code> from packed 16-bit …\nSubtract packed 32-bit integers in <code>b</code> from packed 32-bit …\nSubtract packed 64-bit integers in <code>b</code> from packed 64-bit …\nSubtracts packed 8-bit integers in <code>b</code> from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtracts __m128 vectors.\nSubtract the lower double-precision (64-bit) …\nSubtract the lower single-precision (32-bit) …\nReturns a new vector with the low element of <code>a</code> replaced by …\nSubtracts the first component of <code>b</code> from <code>a</code>, the other …\nSubtract packed 16-bit integers in <code>b</code> from packed 16-bit …\nSubtract packed 8-bit integers in <code>b</code> from packed 8-bit …\nSubtract packed unsigned 16-bit integers in <code>b</code> from packed …\nSubtract packed unsigned 8-bit integers in <code>b</code> from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nTests whether the specified bits in <code>a</code> 128-bit integer …\nTests whether the specified bits in a 128-bit integer …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nTests whether the specified bits in a 128-bit integer …\nComputes the bitwise AND of 128 bits (representing …\nComputes the bitwise AND of 128 bits (representing …\nTests whether the specified bits in a 128-bit integer …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nComputes the bitwise AND of 128 bits (representing …\nComputes the bitwise AND of 128 bits (representing …\nTests whether the specified bits in a 128-bit integer …\nComputes the bitwise AND of 128 bits (representing …\nComputes the bitwise AND of 128 bits (representing …\nTests whether the specified bits in a 128-bit integer …\nCounts the number of trailing least significant zero bits.\nCounts the number of trailing least significant zero bits.\nCompares the lower element of <code>a</code> and <code>b</code> for equality.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for …\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for greater-than.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for …\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for less-than.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nCompares the lower element of <code>a</code> and <code>b</code> for not-equal.\nCompares two 32-bit floats from the low-order bits of <code>a</code> …\nReturns vector of type __m128d with indeterminate elements.\nReturns vector of type __m128 with indeterminate elements. …\nReturns vector of type __m128i with indeterminate elements.\nUnpacks and interleave 16-bit integers from the high half …\nUnpacks and interleave 32-bit integers from the high half …\nUnpacks and interleave 64-bit integers from the high half …\nUnpacks and interleave 8-bit integers from the high half …\nThe resulting <code>__m128d</code> element is composed by the low-order …\nUnpacks and interleave single-precision (32-bit) …\nUnpacks and interleave 16-bit integers from the low half …\nUnpacks and interleave 32-bit integers from the low half …\nUnpacks and interleave 64-bit integers from the low half …\nUnpacks and interleave 8-bit integers from the low half of …\nThe resulting <code>__m128d</code> element is composed by the …\nUnpacks and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nComputes the bitwise XOR of <code>a</code> and <code>b</code>.\nBitwise exclusive OR of packed single-precision (32-bit) …\nComputes the bitwise XOR of 128 bits (representing integer …\nUnsigned multiply without affecting flags.\nUnsigned multiply without affecting flags.\nScatter contiguous low order bits of <code>a</code> to the result at …\nScatter contiguous low order bits of <code>a</code> to the result at …\nGathers the bits of <code>x</code> specified by the <code>mask</code> into the …\nGathers the bits of <code>x</code> specified by the <code>mask</code> into the …\nCounts the bits that are set.\nCounts the bits that are set.\nRead a hardware generated 16-bit random value and store …\nRead a hardware generated 32-bit random value and store …\nRead a hardware generated 64-bit random value and store …\nRead a 16-bit NIST SP800-90B and SP800-90C compliant …\nRead a 32-bit NIST SP800-90B and SP800-90C compliant …\nRead a 64-bit NIST SP800-90B and SP800-90C compliant …\nReads the current value of the processor’s time-stamp …\nStore 32-bit mask from a into memory.\nStore 64-bit mask from a into memory.\nAdds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nAdds unsigned 64-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nClears all bits below the least significant zero of <code>x</code> and …\nClears all bits below the least significant zero of <code>x</code> and …\nCounts the number of trailing least significant zero bits.\nCounts the number of trailing least significant zero bits.\nSets all bits below the least significant one of <code>x</code> and …\nSets all bits below the least significant one of <code>x</code> and …\nForces a restricted transactional memory (RTM) region to …\nRetrieves the parameter passed to <code>_xabort</code> when <code>_xbegin</code>’s …\nSpecifies the start of a restricted transactional memory …\nSpecifies the end of a restricted transactional memory …\nReads the contents of the extended control register <code>XCR</code> …\nPerforms a full or partial restore of the enabled …\nPerforms a full or partial restore of the enabled …\nPerforms a full or partial restore of the enabled …\nPerforms a full or partial restore of the enabled …\nPerforms a full or partial save of the enabled processor …\nPerforms a full or partial save of the enabled processor …\nPerforms a full or partial save of the enabled processor …\nPerforms a full or partial save of the enabled processor …\nPerforms a full or partial save of the enabled processor …\nPerforms a full or partial save of the enabled processor …\nPerforms a full or partial save of the enabled processor …\nPerforms a full or partial save of the enabled processor …\nCopies 64-bits from <code>val</code> to the extended control register (…\nQueries whether the processor is executing in a …\nCompares and exchange 16 bytes (128 bits) of data …\nEAX register.\nEBX register.\nECX register.\nEDX register.\nDoes the host support the <code>cpuid</code> instruction?\nA by-value array iterator.\nThe error type returned when a conversion from a slice to …\n\n\nReturns a mutable slice of all elements that have not been …\nReturns an immutable slice of all elements that have not …\n\n\n\n\n\n\n\n\n\nCreates an iterator over <code>T</code> which returns no elements.\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\n\nCreates an array of type [T; N], where each element <code>T</code> is …\nConverts a mutable reference to <code>T</code> into a mutable reference …\nConverts a reference to <code>T</code> into a reference to an array of …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n\n\n\n\nCreates a new iterator over the given <code>array</code>.\nCreates an iterator over the elements in a …\n\n\n\n\n\n\nCreates an array <code>[T; N]</code> where each fallible array element <code>T</code>…\n\n\n\n\nU+0006\nU+0026\nU+0027\nU+002A\nU+0008\nU+0007\nU+0018\nU+0041\nU+0042\nU+0043\nU+0044\nU+0045\nU+0046\nU+0047\nU+0048\nU+0049\nU+004A\nU+004B\nU+004C\nU+004D\nU+004E\nU+004F\nU+0050\nU+0051\nU+0052\nU+0053\nU+0054\nU+0055\nU+0056\nU+0057\nU+0058\nU+0059\nU+005A\nU+000D\nOne of the 128 Unicode characters from U+0000 through …\nU+0009\nU+005E\nU+003A\nU+002C\nU+0040\nU+0010\nU+007F\nU+0014\nU+0011\nU+0013\nU+0012\nU+0030\nU+0031\nU+0032\nU+0033\nU+0034\nU+0035\nU+0036\nU+0037\nU+0038\nU+0039\nU+0024\nU+0019\nU+0003\nU+0004\nU+0017\nU+0005\nU+003D\nU+001B\nAn iterator over the escaped version of a byte.\nU+0021\nU+000C\nU+002E\nU+0060\nU+003E\nU+002D\nU+001C\nU+001F\nU+001D\nU+001E\nU+007B\nU+0028\nU+005B\nU+003C\nU+000A\nU+000B\nU+005F\nU+0015\nU+0000\nU+0023\nU+0025\nU+002B\nU+003F\nU+0022\nU+005C\nU+007D\nU+0029\nU+005D\nU+003B\nU+000F\nU+000E\nU+0061\nU+0062\nU+0063\nU+0064\nU+0065\nU+0066\nU+0067\nU+0068\nU+0069\nU+006A\nU+006B\nU+006C\nU+006D\nU+006E\nU+006F\nU+0070\nU+0071\nU+0072\nU+0073\nU+0074\nU+0075\nU+0076\nU+0077\nU+0078\nU+0079\nU+007A\nU+002F\nU+0020\nU+0001\nU+0002\nU+001A\nU+0016\nU+007E\nU+007C\n\n\nViews this ASCII character as a one-code-unit UTF-8 <code>str</code>.\n\n\n\n\n\n\n\n\n\n\nWhen passed the <em>number</em> <code>0</code>, <code>1</code>, …, <code>9</code>, returns the <em>character</em> …\nWhen passed the <em>number</em> <code>0</code>, <code>1</code>, …, <code>9</code>, returns the <em>character</em> …\n\nReturns an iterator that produces an escaped version of a …\n\n\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates an ascii character from the byte <code>b</code>, or returns <code>None</code>…\nCreates an ASCII character from the byte <code>b</code>, without …\n\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n\n\n\n\n\n\n\n\nGets this ASCII character as a <code>char</code> Unicode Scalar Value.\nGets this ASCII character as a byte.\n\n\n\n\n\n\nAsserts that an expression matches any of the given …\nAsserts that an expression matches any of the given …\nA trait for dealing with asynchronous iterators.\nAn async iterator that was created from iterator.\nThe type of the resulting iterator\nConvert something into an async iterator\nThe type of items yielded by the async iterator.\nThe type of the item yielded by the iterator\n\n\n\n\nReturns the argument unchanged.\nConverts an iterator into an async iterator.\nCalls <code>U::from(self)</code>.\nConverts <code>self</code> into an async iterator\n\nAttempt to pull out the next value of this async iterator, …\n\nReturns the bounds on the remaining length of the async …\nReturns the bounds on the remaining length of the async …\n\n\n\n\nA trait for borrowing data.\nA trait for mutably borrowing data.\nImmutably borrows from an owned value.\nMutably borrows from an owned value.\nAn error returned by <code>RefCell::try_borrow</code>.\nAn error returned by <code>RefCell::try_borrow_mut</code>.\nA mutable memory location.\nA value which is initialized on the first access.\nA cell which can be written to only once.\nWraps a borrowed reference to a value in a <code>RefCell</code> box. A …\nA mutable memory location with dynamically checked borrow …\nA wrapper type for a mutably borrowed value from a …\n<code>UnsafeCell</code>, but <code>Sync</code>.\nThe core primitive for interior mutability in Rust.\nReturns a <code>&amp;[Cell&lt;T&gt;; N]</code> from a <code>&amp;Cell&lt;[T; N]&gt;</code>\nReturns a raw pointer to the underlying data in this cell.\nReturns a raw pointer to the underlying data in this cell.\nReturns a <code>&amp;[Cell&lt;T&gt;]</code> from a <code>&amp;Cell&lt;[T]&gt;</code>\n\n\n\n\nImmutably borrows the wrapped value.\n\n\n\n\n\n\n\n\n\nMutably borrows the wrapped value.\n\n\n\n\n\n\n\n\n\nPanics\nCopies a <code>Ref</code>.\nPanics\n\nPanics\nCreates a new lazy value using <code>Default</code> as the initializing …\n\nCreates a <code>Cell&lt;T&gt;</code>, with the <code>Default</code> value for T.\nCreates a <code>RefCell&lt;T&gt;</code>, with the <code>Default</code> value for T.\nCreates an <code>UnsafeCell</code>, with the <code>Default</code> value for T.\nCreates an <code>SyncUnsafeCell</code>, with the <code>Default</code> value for T.\n\n\n\n\n\n\n\n\nPanics\nMakes a new <code>Ref</code> for an optional component of the borrowed …\nMakes a new <code>RefMut</code> for an optional component of the …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nForces the evaluation of this lazy value and returns a …\nReturns the argument unchanged.\nReturns the argument unchanged.\n\nCreates a new <code>OnceCell&lt;T&gt;</code> which already contains the given …\nReturns the argument unchanged.\n\nCreates a new <code>Cell&lt;T&gt;</code> containing the given value.\nCreates a new <code>RefCell&lt;T&gt;</code> containing the given value.\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n\nCreates a new <code>UnsafeCell&lt;T&gt;</code> containing the given value.\nCreates a new <code>SyncUnsafeCell&lt;T&gt;</code> containing the given value.\nReturns the argument unchanged.\n\nReturns a <code>&amp;Cell&lt;T&gt;</code> from a <code>&amp;mut T</code>\nConverts from <code>&amp;mut T</code> to <code>&amp;mut UnsafeCell&lt;T&gt;</code>.\n\nPanics\nGets the reference to the underlying value.\nReturns a copy of the contained value.\nGets a mutable pointer to the wrapped value.\nGets a mutable pointer to the wrapped value.\nGets the mutable reference to the underlying value.\nReturns a mutable reference to the underlying data.\nReturns a mutable reference to the underlying data.\nReturns a mutable reference to the underlying data.\nReturns a mutable reference to the underlying data.\nGets the contents of the cell, initializing it with <code>f</code> if …\nGets the contents of the cell, initializing it with <code>f</code> if …\n\nPanics\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes this <code>LazyCell</code> returning the stored value.\nConsumes the cell, returning the wrapped value.\nUnwraps the value, consuming the cell.\nConsumes the <code>RefCell</code>, returning the wrapped value.\nUnwraps the value, consuming the cell.\nUnwraps the value, consuming the cell.\n\nPanics\nConvert into a reference to the underlying data.\nConvert into a mutable reference to the underlying data.\n\nPanics\nMakes a new <code>Ref</code> for a component of the borrowed data.\nMakes a new <code>RefMut</code> for a component of the borrowed data, …\nSplits a <code>Ref</code> into multiple <code>Ref</code>s for different components …\nSplits a <code>RefMut</code> into multiple <code>RefMut</code>s for different …\nCreates a new lazy value with the given initializing …\nCreates a new empty cell.\nCreates a new <code>Cell</code> containing the given value.\nCreates a new <code>RefCell</code> containing <code>value</code>.\nConstructs a new instance of <code>UnsafeCell</code> which will wrap …\nConstructs a new instance of <code>SyncUnsafeCell</code> which will …\n\nPanics\nGets a mutable pointer to the wrapped value. The …\nGets a mutable pointer to the wrapped value.\nReplaces the contained value with <code>val</code>, and returns the old …\nReplaces the wrapped value with a new one, returning the …\nReplaces the wrapped value with a new one computed from <code>f</code>, …\nSets the contents of the cell to <code>value</code>.\nSets the contained value.\nSwaps the values of two <code>Cell</code>s. Difference with …\nSwaps the wrapped value of <code>self</code> with the wrapped value of …\nTakes the value out of this <code>OnceCell</code>, moving it back to an …\nTakes the value of the cell, leaving <code>Default::default()</code> in …\nTakes the wrapped value, leaving <code>Default::default()</code> in its …\nImmutably borrows the wrapped value, returning an error if …\nMutably borrows the wrapped value, returning an error if …\nImmutably borrows the wrapped value, returning an error if …\n\n\n\n\n\n\n\n\n\n\nSets the contents of the cell to <code>value</code> if the cell was …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUndo the effect of leaked guards on the borrow state of …\nUpdates the contained value using a function and returns …\nThe error type returned when a conversion from <code>u32</code> to <code>char</code> …\nAn iterator that decodes UTF-16 encoded code points from …\nAn error that can be returned when decoding UTF-16 code …\nAn iterator that yields the literal escape code of a <code>char</code>.\nAn iterator that yields the literal escape code of a <code>char</code>.\nReturns an iterator that yields the hexadecimal Unicode …\nThe highest valid code point a <code>char</code> can have, <code>&#39;\\u{10FFFF}&#39;</code>…\nAn error which can be returned when parsing a char.\n<code>U+FFFD REPLACEMENT CHARACTER</code> (�) is used in Unicode to …\nReturns an iterator that yields the lowercase equivalent …\nReturns an iterator that yields the uppercase equivalent …\nThe error type returned when a checked char conversion …\nThe version of Unicode that the Unicode parts of <code>char</code> and …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreates an iterator over the UTF-16 encoded code points in …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts a digit in the given radix to a <code>char</code>. Use …\nConverts a <code>u32</code> to a <code>char</code>. Use <code>char::from_u32</code> instead.\nConverts a <code>u32</code> to a <code>char</code>, ignoring validity. Use …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the unpaired surrogate which caused this error.\nA common trait for the ability to explicitly duplicate an …\nDerive macro generating an impl of the trait <code>Clone</code>.\nReturns a copy of the value.\nPerforms copy-assignment from <code>source</code>.\nTrait for comparisons corresponding to equivalence …\nDerive macro generating an impl of the trait <code>Eq</code>.\nAn ordering where a compared value is equal to another.\nAn ordering where a compared value is greater than another.\nAn ordering where a compared value is less than another.\nTrait for types that form a total order.\nDerive macro generating an impl of the trait <code>Ord</code>. The …\nAn <code>Ordering</code> is the result of a comparison between two …\nTrait for comparisons using the equality operator.\nDerive macro generating an impl of the trait <code>PartialEq</code>. …\nTrait for types that form a partial order.\nDerive macro generating an impl of the trait <code>PartialOrd</code>. …\nA helper struct for reverse ordering.\n\n\n\n\nRestrict a value to a certain interval.\n\n\n\nThis method returns an <code>Ordering</code> between <code>self</code> and <code>other</code>.\n\n\n\nThis method tests for <code>self</code> and <code>other</code> values to be equal, …\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nThis method tests greater than or equal to (for <code>self</code> and …\n\nThis method tests greater than (for <code>self</code> and <code>other</code>) and is …\n\n\n\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the ordering is the <code>Equal</code> variant.\nReturns <code>true</code> if the ordering is either the <code>Greater</code> or <code>Equal</code>…\nReturns <code>true</code> if the ordering is the <code>Greater</code> variant.\nReturns <code>true</code> if the ordering is either the <code>Less</code> or <code>Equal</code> …\nReturns <code>true</code> if the ordering is the <code>Less</code> variant.\nReturns <code>true</code> if the ordering is not the <code>Equal</code> variant.\nThis method tests less than or equal to (for <code>self</code> and <code>other</code>…\n\nThis method tests less than (for <code>self</code> and <code>other</code>) and is …\n\nCompares and returns the maximum of two values.\nCompares and returns the maximum of two values.\nReturns the maximum of two values with respect to the …\nReturns the element that gives the maximum value from the …\nCompares and returns the minimum of two values.\nCompares and returns the minimum of two values.\nReturns the minimum of two values with respect to the …\nReturns the element that gives the minimum value from the …\nCompares and sorts two values, returning minimum and …\nReturns minimum and maximum values with respect to the …\nReturns minimum and maximum values with respect to the …\nThis method tests for <code>!=</code>. The default implementation is …\nThis method returns an ordering between <code>self</code> and <code>other</code> …\n\n\nReverses the <code>Ordering</code>.\nChains two orderings.\nChains the ordering with the given function.\n\n\n\n\n\n\nUsed to do a cheap mutable-to-mutable reference conversion.\nUsed to do a cheap reference-to-reference conversion.\nThe type returned in the event of a conversion error.\nThe type returned in the event of a conversion error.\nSupporting trait for inherent methods of <code>f32</code> and <code>f64</code> such …\nUsed to do value-to-value conversions while consuming the …\nThe error type for errors that can never happen.\nA value-to-value conversion that consumes the input value. …\nSimple and safe type conversions that may fail in a …\nAn attempted conversion that consumes <code>self</code>, which may or …\nConverts this type into a mutable reference of the …\nConverts this type into a shared reference of the (usually …\n\n\n\n\n\n\n\n\nConverts to this type from the input type.\nReturns the argument unchanged.\n\n\n\nThe identity function.\nConverts this type into the (usually inferred) input type.\nCalls <code>U::from(self)</code>.\n\nPerforms the conversion.\n\nPerforms the conversion.\n\n\nA trait for giving a type a useful default value.\nDerive macro generating an impl of the trait <code>Default</code>.\nReturns the “default value” for a type.\n<code>Error</code> is a trait representing the basic expectations for …\n<code>Request</code> supports generic, type-driven access to data. It’…\nAn iterator over an <code>Error</code> and its sources.\n\n\n\n\n\n\n\nReturns some mutable reference to the inner value if it is …\nForwards to the method defined on the type <code>dyn Error</code>.\nForwards to the method defined on the type <code>dyn Error</code>.\nReturns some reference to the inner value if it is of type …\nForwards to the method defined on the type <code>dyn Error</code>.\nForwards to the method defined on the type <code>dyn Error</code>.\n\n\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n\nForwards to the method defined on the type <code>dyn Error</code>.\nForwards to the method defined on the type <code>dyn Error</code>.\nReturns <code>true</code> if the inner type is the same as <code>T</code>.\n\nProvides type based access to context intended for error …\nProvide a reference. The referee type must be bounded by …\nProvide a reference computed using a closure. The referee …\nProvide a value or other type with only static lifetimes.\nProvide a value or other type with only static lifetimes …\nRequest a reference of type <code>T</code> from the given <code>impl Error</code>.\nRequest a value of type <code>T</code> from the given <code>impl Error</code>.\nThe lower-level source of this error, if any.\nReturns an iterator starting with the current error and …\n\n\n\n\nCheck if the <code>Request</code> would be satisfied if provided with a …\nCheck if the <code>Request</code> would be satisfied if provided with a …\nApproximate number of significant digits in base 10. Use …\nMachine epsilon value for <code>f32</code>. Use <code>f32::EPSILON</code> instead.\nInfinity (∞). Use <code>f32::INFINITY</code> instead.\nNumber of significant digits in base 2. Use …\nLargest finite <code>f32</code> value. Use <code>f32::MAX</code> instead.\nMaximum possible power of 10 exponent. Use <code>f32::MAX_10_EXP</code> …\nMaximum possible power of 2 exponent. Use <code>f32::MAX_EXP</code> …\nSmallest finite <code>f32</code> value. Use <code>f32::MIN</code> instead.\nMinimum possible normal power of 10 exponent. Use …\nOne greater than the minimum possible normal power of 2 …\nSmallest positive normal <code>f32</code> value. Use <code>f32::MIN_POSITIVE</code> …\nNot a Number (NaN). Use <code>f32::NAN</code> instead.\nNegative infinity (−∞). Use <code>f32::NEG_INFINITY</code> instead.\nThe radix or base of the internal representation of <code>f32</code>. …\nBasic mathematical constants.\nEuler’s number (e)\nThe Euler-Mascheroni constant (γ)\n1/π\n1/sqrt(2)\n1/sqrt(3)\n1/sqrt(π)\n2/π\n2/sqrt(π)\nπ/2\nπ/3\nπ/4\nπ/6\nπ/8\nln(10)\nln(2)\nlog10(2)\nlog10(e)\nlog2(10)\nlog2(e)\nThe golden ratio (φ)\nArchimedes’ constant (π)\nsqrt(2)\nsqrt(3)\nThe full circle constant (τ)\nApproximate number of significant digits in base 10. Use …\nMachine epsilon value for <code>f64</code>. Use <code>f64::EPSILON</code> instead.\nInfinity (∞). Use <code>f64::INFINITY</code> instead.\nNumber of significant digits in base 2. Use …\nLargest finite <code>f64</code> value. Use <code>f64::MAX</code> instead.\nMaximum possible power of 10 exponent. Use <code>f64::MAX_10_EXP</code> …\nMaximum possible power of 2 exponent. Use <code>f64::MAX_EXP</code> …\nSmallest finite <code>f64</code> value. Use <code>f64::MIN</code> instead.\nMinimum possible normal power of 10 exponent. Use …\nOne greater than the minimum possible normal power of 2 …\nSmallest positive normal <code>f64</code> value. Use <code>f64::MIN_POSITIVE</code> …\nNot a Number (NaN). Use <code>f64::NAN</code> instead.\nNegative infinity (−∞). Use <code>f64::NEG_INFINITY</code> instead.\nThe radix or base of the internal representation of <code>f64</code>. …\nBasic mathematical constants.\nEuler’s number (e)\nThe Euler-Mascheroni constant (γ)\n1/π\n1/sqrt(2)\n1/sqrt(3)\n1/sqrt(π)\n2/π\n2/sqrt(π)\nπ/2\nπ/3\nπ/4\nπ/6\nπ/8\nln(10)\nln(2)\nlog10(2)\nlog10(e)\nlog2(10)\nlog2(e)\nThe golden ratio (φ)\nArchimedes’ constant (π)\nsqrt(2)\nsqrt(3)\nThe full circle constant (τ)\nRepresentation of a borrowed C string.\nAn error indicating that no nul byte was present.\nAn error indicating that a nul byte was not in the …\nType alias for <code>NonZero</code> version of <code>c_char</code>\nType alias for <code>NonZero</code> version of <code>c_int</code>\nType alias for <code>NonZero</code> version of <code>c_long</code>\nType alias for <code>NonZero</code> version of <code>c_longlong</code>\nType alias for <code>NonZero</code> version of <code>c_schar</code>\nType alias for <code>NonZero</code> version of <code>c_short</code>\nType alias for <code>NonZero</code> version of <code>c_uchar</code>\nType alias for <code>NonZero</code> version of <code>c_uint</code>\nType alias for <code>NonZero</code> version of <code>c_ulong</code>\nType alias for <code>NonZero</code> version of <code>c_ulonglong</code>\nType alias for <code>NonZero</code> version of <code>c_ushort</code>\nA wrapper for a <code>va_list</code>\nx86_64 ABI implementation of a <code>va_list</code>.\nAdvance to the next arg.\nReturns the inner pointer to this C string.\n\nConvert a <code>VaListImpl</code> into a <code>VaList</code> that is …\n\n\n\n\n\n\n\n\n\n\n\n\nEquivalent to C’s <code>char</code> type.\nEquivalent to C’s <code>double</code> type.\nEquivalent to C’s <code>float</code> type.\nEquivalent to C’s <code>signed int</code> (<code>int</code>) type.\nEquivalent to C’s <code>signed long</code> (<code>long</code>) type.\nEquivalent to C’s <code>signed long long</code> (<code>long long</code>) type.\nEquivalent to C’s <code>ptrdiff_t</code> type, from <code>stddef.h</code> (or …\nEquivalent to C’s <code>signed char</code> type.\nEquivalent to C’s <code>signed short</code> (<code>short</code>) type.\nEquivalent to C’s <code>size_t</code> type, from <code>stddef.h</code> (or <code>cstddef</code> …\nEquivalent to C’s <code>ssize_t</code> (on POSIX) or <code>SSIZE_T</code> (on …\nEquivalent to C’s <code>unsigned char</code> type.\nEquivalent to C’s <code>unsigned int</code> type.\nEquivalent to C’s <code>unsigned long</code> type.\nEquivalent to C’s <code>unsigned long long</code> type.\nEquivalent to C’s <code>unsigned short</code> type.\nEquivalent to C’s <code>void</code> type when used as a pointer.\n\n\n\n\nReturns the length of <code>self</code>. Like C’s <code>strlen</code>, this does …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a C string wrapper from a byte slice with any …\nCreates a C string wrapper from a byte slice with exactly …\nUnsafely creates a C string wrapper from a byte slice.\nWraps a raw C string with a safe C string wrapper.\n\n\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if <code>self.to_bytes()</code> has a length of 0.\n\nConverts this C string to a byte slice.\nConverts this C string to a byte slice containing the …\nYields a &amp;str slice if the <code>CStr</code> contains valid UTF-8.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCopies the <code>va_list</code> at the current location.\nPossible alignments returned by <code>Formatter::align</code>\nThis structure represents a safely precompiled version of …\n<code>b</code> formatting.\nIndication that contents should be center-aligned.\n<code>?</code> formatting.\nDerive macro generating an impl of the trait <code>Debug</code>.\nA struct to help with <code>fmt::Debug</code> implementations.\nA struct to help with <code>fmt::Debug</code> implementations.\nA struct to help with <code>fmt::Debug</code> implementations.\nA struct to help with <code>fmt::Debug</code> implementations.\nA struct to help with <code>fmt::Debug</code> implementations.\nFormat trait for an empty format, <code>{}</code>.\nContains the error value\nThe error type which is returned from formatting a message …\nConfiguration for formatting.\nImplements <code>fmt::Debug</code> and <code>fmt::Display</code> using a function.\nIndication that contents should be left-aligned.\n<code>e</code> formatting.\n<code>x</code> formatting.\n<code>o</code> formatting.\nContains the success value\n<code>p</code> formatting.\nThe type returned by formatter methods.\nIndication that contents should be right-aligned.\n<code>E</code> formatting.\n<code>X</code> formatting.\nA trait for writing or formatting into Unicode-accepting …\nFlag indicating what form of alignment was requested.\nDetermines if the <code>#</code> flag was specified.\nGet the formatted string, if it has no arguments to be …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreates a <code>DebugList</code> builder designed to assist with …\nCreates a <code>DebugMap</code> builder designed to assist with …\nCreates a <code>DebugSet</code> builder designed to assist with …\nCreates a <code>DebugStruct</code> builder designed to assist with …\nCreates a <code>DebugTuple</code> builder designed to assist with …\n\n\nAdds the contents of an iterator of entries to the set …\nAdds the contents of an iterator of entries to the list …\nAdds the contents of an iterator of entries to the map …\nAdds a new entry to the set output.\nAdds a new entry to the list output.\nAdds a new entry to the map output.\nAdds a new entry to the set output.\nAdds a new entry to the list output.\n\n\nAdds a new field to the generated struct output.\nAdds a new field to the generated tuple struct output.\nAdds a new field to the generated struct output.\nAdds a new field to the generated tuple struct output.\nCharacter used as ‘fill’ whenever there is alignment.\nFinishes output and returns any error encountered.\nFinishes output and returns any error encountered.\nFinishes output and returns any error encountered.\nFinishes output and returns any error encountered.\nFinishes output and returns any error encountered.\nMarks the struct as non-exhaustive, indicating to the …\nFlags for formatting\nFormats the value using the given formatter.\nFormats the value using the given formatter.\nFormats the value using the given formatter.\nFormats the value using the given formatter.\nFormats the value using the given formatter.\nFormats the value using the given formatter.\nFormats the value using the given formatter.\nFormats the value using the given formatter.\nFormats the value using the given formatter.\n\n\n\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAdds the key part of a new entry to the map output.\nAdds the key part of a new entry to the map output.\nThis function takes a string slice and emits it to the …\nPerforms the correct padding for an integer which has …\n\nOptionally specified precision for numeric types. …\nDetermines if the <code>0</code> flag was specified.\nDetermines if the <code>-</code> flag was specified.\nDetermines if the <code>+</code> flag was specified.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdds the value part of a new entry to the map output.\nAdds the value part of a new entry to the map output.\nOptionally specified integer width that the output should …\nThe <code>write</code> function takes an output stream, and an <code>Arguments</code>…\nWrites a <code>char</code> into this writer, returning whether the …\n\nGlue for usage of the <code>write!</code> macro with implementors of …\n\nWrites some formatted information into this instance.\nWrites a string slice into this writer, returning whether …\n\nWrites some data to the underlying buffer contained within …\nA future represents an asynchronous computation obtained …\nConversion into a <code>Future</code>.\nWhich kind of future are we turning this into?\nThe output that the future will produce on completion.\nThe type of value produced on completion.\nCreates a future which never resolves, representing a …\nA Future that wraps a function returning <code>Poll</code>.\nA future that is immediately ready with a value.\n\n\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a future from a value.\n\n\n\nConsumes the <code>Ready</code>, returning the wrapped value.\nPolls multiple futures simultaneously, returning a tuple …\nCreates a future which never resolves, representing a …\nAttempt to resolve the future to a final value, registering\n\n\n\nCreates a future that wraps a function returning <code>Poll</code>.\nCreates a future that is immediately ready with a value.\n\n\n\n\n\n\n\n\n\nA trait for creating instances of <code>Hasher</code>.\nUsed to create a default <code>BuildHasher</code> instance for types …\nA hashable type.\nDerive macro generating an impl of the trait <code>Hash</code>.\nA trait for hashing an arbitrary stream of bytes.\nType of the hasher that will be created.\nAn implementation of SipHash 2-4.\n\n\n\n\nCreates a new hasher.\n\n\n\n\n\n\nReturns the hash value for the values written so far.\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nFeeds this value into the given <code>Hasher</code>.\nCalculates the hash of a single value.\nFeeds a slice of this type into the given <code>Hasher</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new <code>SipHasher</code> with the two initial keys set to 0.\nCreates a <code>SipHasher</code> that is keyed off the provided keys.\n\n\n\n\n\n\nWrites some data into this <code>Hasher</code>.\n\nWrites a single <code>i128</code> into this hasher.\nWrites a single <code>i16</code> into this hasher.\nWrites a single <code>i32</code> into this hasher.\nWrites a single <code>i64</code> into this hasher.\nWrites a single <code>i8</code> into this hasher.\nWrites a single <code>isize</code> into this hasher.\nWrites a length prefix into this hasher, as part of being …\nWrites a single <code>str</code> into this hasher.\n\nWrites a single <code>u128</code> into this hasher.\nWrites a single <code>u16</code> into this hasher.\nWrites a single <code>u32</code> into this hasher.\nWrites a single <code>u64</code> into this hasher.\nWrites a single <code>u8</code> into this hasher.\nWrites a single <code>usize</code> into this hasher.\nMakes a <em>soundness</em> promise to the compiler that <code>cond</code> holds.\nAn identity function that <em><strong>hints</strong></em> to the compiler to be …\nAn identity function that causes an <code>unused_must_use</code> …\nEmits a machine instruction to signal the processor that …\nInforms the compiler that the site which is calling this …\nThe largest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nAborts the execution of the process.\nPerforms checked integer addition.\nCalculates the offset from a pointer, potentially wrapping.\nA guard for unsafe functions that cannot ever be executed …\nA guard for <code>std::mem::uninitialized</code>. This will statically …\nA guard for unsafe functions that cannot ever be executed …\nInforms the optimizer that a condition is always true. If …\nBitwise and with the current value, returning the previous …\nBitwise and with the current value, returning the previous …\nBitwise and with the current value, returning the previous …\nBitwise and with the current value, returning the previous …\nBitwise and with the current value, returning the previous …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nStores a value if the current value is the same as the <code>old</code> …\nAn atomic fence.\nAn atomic fence.\nAn atomic fence.\nAn atomic fence.\nLoads the current value of the pointer.\nLoads the current value of the pointer.\nLoads the current value of the pointer.\nDo NOT use this intrinsic; “unordered” operations do …\nMaximum with the current value using a signed comparison.\nMaximum with the current value using a signed comparison.\nMaximum with the current value.\nMaximum with the current value using a signed comparison.\nMaximum with the current value using a signed comparison.\nMinimum with the current value using a signed comparison.\nMinimum with the current value using a signed comparison.\nMinimum with the current value using a signed comparison.\nMinimum with the current value using a signed comparison.\nMinimum with the current value using a signed comparison.\nBitwise nand with the current value, returning the …\nBitwise nand with the current value, returning the …\nBitwise nand with the current value, returning the …\nBitwise nand with the current value, returning the …\nBitwise nand with the current value, returning the …\nBitwise or with the current value, returning the previous …\nBitwise or with the current value, returning the previous …\nBitwise or with the current value, returning the previous …\nBitwise or with the current value, returning the previous …\nBitwise or with the current value, returning the previous …\nA compiler-only memory barrier.\nA compiler-only memory barrier.\nA compiler-only memory barrier.\nA compiler-only memory barrier.\nStores the value at the specified memory location.\nStores the value at the specified memory location.\nStores the value at the specified memory location.\nDo NOT use this intrinsic; “unordered” operations do …\nMaximum with the current value using an unsigned …\nMaximum with the current value using an unsigned …\nMaximum with the current value using an unsigned …\nMaximum with the current value using an unsigned …\nMaximum with the current value using an unsigned …\nMinimum with the current value using an unsigned …\nMinimum with the current value using an unsigned …\nMinimum with the current value using an unsigned …\nMinimum with the current value using an unsigned …\nMinimum with the current value using an unsigned …\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nStores the value at the specified memory location, …\nStores the value at the specified memory location, …\nStores the value at the specified memory location, …\nStores the value at the specified memory location, …\nStores the value at the specified memory location, …\nBitwise xor with the current value, returning the previous …\nBitwise xor with the current value, returning the previous …\nBitwise xor with the current value, returning the previous …\nBitwise xor with the current value, returning the previous …\nBitwise xor with the current value, returning the previous …\nSubtract from the current value, returning the previous …\nSubtract from the current value, returning the previous …\nSubtract from the current value, returning the previous …\nSubtract from the current value, returning the previous …\nSubtract from the current value, returning the previous …\nReverses the bits in an integer type <code>T</code>.\nSee documentation of <code>std::hint::black_box</code> for details.\nExecutes a breakpoint trap, for inspection by a debugger.\nReverses the bytes in an integer type <code>T</code>.\nGets a reference to a static <code>Location</code> indicating where it …\nReturns the smallest integer greater than or equal to an …\nReturns the smallest integer greater than or equal to an …\nLexicographically compare <code>[left, left + bytes)</code> and …\nAllocates a block of memory at compile time. At runtime, …\nDeallocates a memory which allocated by …\nSelects which function to call depending on the context.\nCopies <code>count * size_of::&lt;T&gt;()</code> bytes from <code>src</code> to <code>dst</code>. The …\nCopies <code>count * size_of::&lt;T&gt;()</code> bytes from <code>src</code> to <code>dst</code>. The …\nCopies the sign from <code>y</code> to <code>x</code> for <code>f32</code> values.\nCopies the sign from <code>y</code> to <code>x</code> for <code>f64</code> values.\nReturns the cosine of an <code>f32</code>.\nReturns the cosine of an <code>f64</code>.\nReturns the number of leading unset bits (zeroes) in an …\nLike <code>ctlz</code>, but extra-unsafe as it returns <code>undef</code> when given …\nReturns the number of bits set in an integer type <code>T</code>\nReturns the number of trailing unset bits (zeroes) in an …\nLike <code>cttz</code>, but extra-unsafe as it returns <code>undef</code> when given …\nReturns the value of the discriminant for the variant in …\n\nPerforms an exact division, resulting in undefined …\nReturns 2 raised to the power of an <code>f32</code>.\nReturns 2 raised to the power of an <code>f64</code>.\nReturns the exponential of an <code>f32</code>.\nReturns the exponential of an <code>f64</code>.\nReturns the absolute value of an <code>f32</code>.\nReturns the absolute value of an <code>f64</code>.\nFloat addition that allows optimizations based on …\nFloat division that allows optimizations based on …\nConvert with LLVM’s fptoui/fptosi, which may return …\nReturns the largest integer less than or equal to an <code>f32</code>.\nReturns the largest integer less than or equal to an <code>f64</code>.\nReturns <code>a * b + c</code> for <code>f32</code> values.\nReturns <code>a * b + c</code> for <code>f64</code> values.\nFloat multiplication that allows optimizations based on …\nMoves a value out of scope without running drop glue.\nFloat remainder that allows optimizations based on …\nFloat subtraction that allows optimizations based on …\nHints to the compiler that branch condition is likely to …\nReturns the base 10 logarithm of an <code>f32</code>.\nReturns the base 10 logarithm of an <code>f64</code>.\nReturns the base 2 logarithm of an <code>f32</code>.\nReturns the base 2 logarithm of an <code>f64</code>.\nReturns the natural logarithm of an <code>f32</code>.\nReturns the natural logarithm of an <code>f64</code>.\nReturns the maximum of two <code>f32</code> values.\nReturns the maximum of two <code>f64</code> values.\nThe minimum alignment of a type.\nThe required alignment of the referenced value.\nReturns the minimum of two <code>f32</code> values.\nReturns the minimum of two <code>f64</code> values.\nRustc internal tooling for hand-writing MIR.\nPerforms checked integer multiplication\nReturns the nearest integer to an <code>f32</code>. Changing the …\nReturns the nearest integer to an <code>f64</code>. Changing the …\nReturns <code>true</code> if the actual type given as <code>T</code> requires drop …\nEmits a <code>!nontemporal</code> store according to LLVM (see their …\nCalculates the offset from a pointer.\nRaises an <code>f32</code> to an <code>f32</code> power.\nRaises an <code>f64</code> to an <code>f64</code> power.\nRaises an <code>f32</code> to an integer power.\nRaises an <code>f64</code> to an integer power.\nThe preferred alignment of a type.\nThe <code>prefetch</code> intrinsic is a hint to the code generator to …\nThe <code>prefetch</code> intrinsic is a hint to the code generator to …\nThe <code>prefetch</code> intrinsic is a hint to the code generator to …\nThe <code>prefetch</code> intrinsic is a hint to the code generator to …\nSee documentation of <code>&lt;*const T&gt;::guaranteed_eq</code> for details.\nMasks out bits of the pointer according to a mask.\nSee documentation of <code>&lt;*const T&gt;::offset_from</code> for details.\nSee documentation of <code>&lt;*const T&gt;::sub_ptr</code> for details.\nDetermines whether the raw bytes of the two values are …\nThis is an implementation detail of <code>crate::ptr::read</code> and …\nReturns the nearest integer to an <code>f32</code>. Changing the …\nReturns the nearest integer to an <code>f64</code>. Changing the …\nPerforms rotate left.\nPerforms rotate right.\nReturns the nearest integer to an <code>f32</code>. Rounds half-way …\nReturns the nearest integer to an <code>f64</code>. Rounds half-way …\nReturns the nearest integer to an <code>f32</code>. Rounds half-way …\nReturns the nearest integer to an <code>f64</code>. Rounds half-way …\nMagic intrinsic that derives its meaning from attributes …\nComputes <code>a + b</code>, saturating at numeric bounds.\nComputes <code>a - b</code>, saturating at numeric bounds.\nSIMD compiler intrinsics.\nReturns the sine of an <code>f32</code>.\nReturns the sine of an <code>f64</code>.\nThe size of a type in bytes.\nThe size of the referenced value in bytes.\nReturns the square root of an <code>f32</code>\nReturns the square root of an <code>f64</code>\nPerforms checked integer subtraction\nReinterprets the bits of a value of one type as another …\nLike <code>transmute</code>, but even less checked at compile-time: …\nReturns the integer part of an <code>f32</code>.\nReturns the integer part of an <code>f64</code>.\nRust’s “try catch” construct which invokes the …\nGets an identifier which is globally unique to the …\nGets a static string slice containing the name of a type.\nPerforms a volatile load from the <code>src</code> pointer The pointer …\nPerforms a volatile store to the <code>dst</code> pointer. The pointer …\nReturns the result of an unchecked addition, resulting in …\nPerforms an unchecked division, resulting in undefined …\nReturns the result of an unchecked multiplication, …\nReturns the remainder of an unchecked division, resulting …\nPerforms an unchecked left shift, resulting in undefined …\nPerforms an unchecked right shift, resulting in undefined …\nReturns the result of an unchecked subtraction, resulting …\nHints to the compiler that branch condition is likely to …\nInforms the optimizer that this point in the code is not …\nReturns the number of variants of the type <code>T</code> cast to a …\nEquivalent to the appropriate <code>llvm.memmove.p0i8.0i8.*</code> …\nEquivalent to the appropriate <code>llvm.memcpy.p0i8.0i8.*</code> …\nPerforms a volatile load from the <code>src</code> pointer.\nEquivalent to the appropriate <code>llvm.memset.p0i8.*</code> …\nPerforms a volatile store to the <code>dst</code> pointer.\n<code>ptr</code> must point to a vtable. The intrinsic will return the …\n<code>ptr</code> must point to a vtable. The intrinsic will return the …\nReturns (a + b) mod 2N, where N is the width of T in bits.\nReturns (a * b) mod 2N, where N is the width of T in bits.\nReturns (a - b) mod 2N, where N is the width of T in bits.\nSets <code>count * size_of::&lt;T&gt;()</code> bytes of memory starting at <code>dst</code>…\nThis is an implementation detail of <code>crate::ptr::write</code> and …\nUnwinding is just not possible given the ABI of this …\nType representing basic blocks.\nCall a function.\nEmits a <code>CastKind::Transmute</code> cast.\n\nA basic block that lies on an unwind path.\n\n\nGets the discriminant of a place.\nDrop the contents of a place.\nAccess the field with the given index of some place.\n\nWe were already cleaning up for an ongoing unwind, and a …\n\n\nA non-cleanup basic block.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAn unwind action that continues execution in a given basic …\nAn unwind action that continues unwinding.\nA terminator that resumes the unwinding.\nAn unwind action that terminates the execution.\nThe reason we are terminating the process during unwinding.\nAn unwind action that triggers undefined behaviour.\nAdds a variant projection with the given index to the …\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMacro for generating custom MIR.\nHelper macro that allows you to treat a value expression …\n\n\n\n\n\n\n\n\n\n\n\n\nAdd two simd vectors elementwise.\nElementwise vector “and”.\nElementwise calculates the offset from a pointer vector, …\nNumerically cast a vector, elementwise.\nTruncate an integer vector to a bitmask.\nReverse bits of each element.\nSwap bytes of each element.\nNumerically cast a vector, elementwise.\nCast a vector of pointers.\nCount the leading zeros of each element.\nCount the trailing zeros of each element.\nDivide <code>lhs</code> by <code>rhs</code> elementwise.\nTests elementwise equality of two vectors.\nExpose a vector of pointers as a vector of addresses.\nElementwise absolute value of a vector.\nElementwise maximum of a vector.\nElementwise minimum of a vector.\nCreate a vector of pointers from a vector of addresses.\nRead a vector of pointers.\nTests if <code>x</code> is greater than or equal to <code>y</code>, elementwise.\nTests if <code>x</code> is greater than <code>y</code>, elementwise.\nTests if <code>x</code> is less than or equal to <code>y</code>, elementwise.\nTests if <code>x</code> is less than <code>y</code>, elementwise.\nRead a vector of pointers.\nWrite to a vector of pointers.\nMultiply two simd vectors elementwise.\nTests elementwise inequality equality of two vectors.\nElementwise negation of a vector.\nElementwise vector “or”.\nAdd elements within a vector from left to right.\nCheck if all mask values are true.\nLogical “and” all elements together.\nCheck if all mask values are true.\nReturn the maximum element of a vector.\nReturn the minimum element of a vector.\nMultiply elements within a vector from left to right.\nLogical “or” all elements together.\nLogical “exclusive or” all elements together.\nRemainder of two vectors elementwise\nAdd two simd vectors elementwise, with saturation.\nSubtract two simd vectors elementwise, with saturation.\nWrite to a vector of pointers.\nSelect elements from a mask.\nSelect elements from a bitmask.\nElementwise vector left shift, with UB on overflow.\nElementwise vector right shift, with UB on overflow.\nShuffle two vectors by const indices.\nSubtract <code>rhs</code> from <code>lhs</code> elementwise.\nElementwise vector “exclusive or”.\nA borrowed byte buffer which is incrementally filled and …\nA writeable view of the unfilled portion of a <code>BorrowedBuf</code>.\nAdvance the cursor by asserting that <code>n</code> bytes have been …\nAppends data to the cursor, advancing position within its …\nReturns a mutable reference to the whole cursor.\n\n\n\n\nReturns the total capacity of the buffer.\nReturns the available space in the cursor.\nClears the buffer, resetting the filled region to empty.\nInitializes all bytes in the cursor.\nReturns a shared reference to the filled portion of the …\nReturns a mutable reference to the filled portion of the …\n\n\n\nReturns the argument unchanged.\n\nReturns the argument unchanged.\nReturns the length of the initialized part of the buffer.\nReturns a mutable reference to the initialized portion of …\nReturns a shared reference to the initialized portion of …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the length of the filled part of the buffer.\nReborrow this cursor by cloning it with a smaller lifetime.\nAsserts that the first <code>n</code> bytes of the buffer are …\nAsserts that the first <code>n</code> unfilled bytes of the cursor are …\n\n\n\n\n\n\nReturns a cursor over the unfilled part of the buffer.\nReturns a mutable reference to the uninitialized part of …\nReturns the number of bytes written to this cursor since …\nThe largest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nAn iterator over <code>N</code> elements of the iterator at a time.\nLike <code>Iterator::by_ref</code>, but requiring <code>Sized</code> so it can …\nAn iterator that links two iterators together, in a chain.\nAn iterator that clones the elements of an underlying …\nAn iterator that copies the elements of an underlying …\nAn iterator that repeats endlessly.\nAn iterator able to yield elements from both ends.\nAn iterator that yields nothing.\nAn iterator that yields the current count and the element …\nAn iterator that knows its exact length.\nExtend a collection with the contents of an iterator.\nAn iterator that filters the elements of <code>iter</code> with …\nAn iterator that uses <code>f</code> to both filter and map elements …\nAn iterator that maps each element to an iterator, and …\nAn iterator that flattens one level of nesting in an …\nAn iterator where each iteration calls the provided …\nConversion from an <code>Iterator</code>.\nAn iterator that yields <code>None</code> forever after the underlying …\nAn iterator that always continues to yield <code>None</code> when …\n\nAn iterator that calls a function with a reference to each …\nAn iterator adapter that places a separator between all …\nAn iterator adapter that places a separator between all …\nWhich kind of iterator are we turning this into?\nConversion into an <code>Iterator</code>.\nThe type of the elements being iterated over.\nThe type of the elements being iterated over.\nA trait for dealing with iterators.\nAn iterator that maps the values of <code>iter</code> with <code>f</code>.\nAn iterator that only accepts elements while <code>predicate</code> …\nAn iterator over the mapped windows of another iterator.\nAn iterator that yields an element exactly once.\nAn iterator that yields a single element of type <code>A</code> by …\nAn iterator with a <code>peek()</code> that returns an optional …\nTrait to represent types that can be created by …\nAn iterator that repeats an element endlessly.\n\nAn iterator that repeats elements of type <code>A</code> endlessly by …\nA double-ended iterator with the direction inverted.\nAn iterator to maintain state while iterating another …\nAn iterator that skips over <code>n</code> elements of <code>iter</code>.\nAn iterator that rejects elements while <code>predicate</code> returns …\n\nObjects that have a notion of <em>successor</em> and <em>predecessor</em> …\nAn iterator for stepping iterators by a custom amount.\nA new iterator where each successive item is computed …\nTrait to represent types that can be created by summing up …\nAn iterator that only iterates over the first <code>n</code> iterations …\nAn iterator that only accepts elements while <code>predicate</code> …\n\nAn iterator that reports an accurate length using …\n\n\nA type that upholds all invariants of <code>Step</code>.\nAn iterator that iterates two other iterators …\n\n\nAdvances the iterator from the back by <code>n</code> elements.\nAdvances the iterator from the back by <code>n</code> elements.\n\n\n\n\n\n\n\n\n\n\nAdvances the iterator by <code>n</code> elements.\nAdvances the iterator by <code>n</code> elements.\n\n\n\n\n\n\n\n\n\nTests if every element of the iterator matches a predicate.\nTests if every element of the iterator matches a predicate.\nTests if any element of the iterator matches a predicate.\nTests if any element of the iterator matches a predicate.\nReturns an iterator over <code>N</code> elements of the iterator at a …\nReturns an iterator over <code>N</code> elements of the iterator at a …\nReturns the value that would be obtained by taking the …\nReturns the value that would be obtained by taking the …\nReturns the value that would be obtained by taking the …\nReturns the value that would be obtained by taking the …\nReturns the value that would be obtained by taking the …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBorrows an iterator, rather than consuming it.\nBorrows an iterator, rather than consuming it.\nTakes two iterators and creates a new iterator over both …\nTakes two iterators and creates a new iterator over both …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreates an iterator which <code>clone</code>s all of its elements.\nCreates an iterator which <code>clone</code>s all of its elements.\nLexicographically compares the elements of this <code>Iterator</code> …\nLexicographically compares the elements of this <code>Iterator</code> …\nLexicographically compares the elements of this <code>Iterator</code> …\nLexicographically compares the elements of this <code>Iterator</code> …\nTransforms an iterator into a collection.\nTransforms an iterator into a collection.\nCollects all the items from an iterator into a collection.\nCollects all the items from an iterator into a collection.\nCreates an iterator which copies all of its elements.\nCreates an iterator which copies all of its elements.\n\n\nConsumes the iterator, counting the number of iterations …\nConsumes the iterator, counting the number of iterations …\n\n\n\n\n\n\n\n\n\nRepeats an iterator endlessly.\nRepeats an iterator endlessly.\nCreates a <code>Flatten</code> iterator from the default value of <code>I</code>.\n\nCreates a <code>Chain</code> from the default values for <code>A</code> and <code>B</code>.\nCreates a <code>Cloned</code> iterator from the default value of <code>I</code>\nCreates a <code>Copied</code> iterator from the default value of <code>I</code>\nCreates an <code>Enumerate</code> iterator from the default value of <code>I</code>\nCreates a <code>Fuse</code> iterator from the default value of <code>I</code>.\nCreates a <code>Rev</code> iterator from the default value of <code>I</code>\nCreates an iterator that yields nothing.\nCreates an iterator which gives the current iteration …\nCreates an iterator which gives the current iteration …\nDetermines if the elements of this <code>Iterator</code> are equal to …\nDetermines if the elements of this <code>Iterator</code> are equal to …\nDetermines if the elements of this <code>Iterator</code> are equal to …\nDetermines if the elements of this <code>Iterator</code> are equal to …\nExtends a collection with the contents of an iterator.\nExtends a collection with exactly one element.\nExtends a collection with exactly one element.\nReserves capacity in a collection for the given number of …\nReserves capacity in a collection for the given number of …\nCreates an iterator which uses a closure to determine if …\nCreates an iterator which uses a closure to determine if …\nCreates an iterator that both filters and maps.\nCreates an iterator that both filters and maps.\nSearches for an element of an iterator that satisfies a …\nSearches for an element of an iterator that satisfies a …\n\n\n\nApplies function to the elements of iterator and returns …\nApplies function to the elements of iterator and returns …\nCreates an iterator that works like map, but flattens …\nCreates an iterator that works like map, but flattens …\nCreates an iterator that flattens nested structure.\nCreates an iterator that flattens nested structure.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFolds every element into an accumulator by applying an …\nFolds every element into an accumulator by applying an …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCalls a closure on each element of an iterator.\nCalls a closure on each element of an iterator.\n\nReturns the value that would be obtained by taking the …\nReturns the value that would be obtained by taking the …\nReturns the value that would be obtained by taking the …\nReturns the value that would be obtained by taking the …\nReturns the value that would be obtained by taking the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new iterator where each iteration calls the …\nCreates a new iterator where each iteration calls the …\nCreates a value from an iterator.\nCreates an iterator which ends after the first <code>None</code>.\nCreates an iterator which ends after the first <code>None</code>.\nDetermines if the elements of this <code>Iterator</code> are …\nDetermines if the elements of this <code>Iterator</code> are …\nDetermines if the elements of this <code>Iterator</code> are …\nDetermines if the elements of this <code>Iterator</code> are …\nDoes something with each element of an iterator, passing …\nDoes something with each element of an iterator, passing …\nCreates a new iterator which places a copy of <code>separator</code> …\nCreates a new iterator which places a copy of <code>separator</code> …\nCreates a new iterator which places an item generated by …\nCreates a new iterator which places an item generated by …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates an iterator from a value.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns an iterator over the remaining elements of the …\nReturns <code>true</code> if the iterator is empty.\nReturns <code>true</code> if the iterator is empty.\n\n\n\n\n\n\n\n\nChecks if the elements of this iterator are partitioned …\nChecks if the elements of this iterator are partitioned …\nChecks if the elements of this iterator are sorted.\nChecks if the elements of this iterator are sorted.\nChecks if the elements of this iterator are sorted using …\nChecks if the elements of this iterator are sorted using …\nChecks if the elements of this iterator are sorted using …\nChecks if the elements of this iterator are sorted using …\n\n\nConsumes the iterator, returning the last element.\nConsumes the iterator, returning the last element.\n\n\n\n\n\n\nDetermines if the elements of this <code>Iterator</code> are …\nDetermines if the elements of this <code>Iterator</code> are …\n\nReturns the exact remaining length of the iterator.\nReturns the exact remaining length of the iterator.\n\n\n\n\n\n\n\n\n\n\nDetermines if the elements of this <code>Iterator</code> are …\nDetermines if the elements of this <code>Iterator</code> are …\nTakes a closure and creates an iterator which calls that …\nTakes a closure and creates an iterator which calls that …\nCreates an iterator that both yields elements based on a …\nCreates an iterator that both yields elements based on a …\nCalls the given function <code>f</code> for each contiguous window of …\nCalls the given function <code>f</code> for each contiguous window of …\nReturns the maximum element of an iterator.\nReturns the maximum element of an iterator.\nReturns the element that gives the maximum value with …\nReturns the element that gives the maximum value with …\nReturns the element that gives the maximum value from the …\nReturns the element that gives the maximum value from the …\nReturns the minimum element of an iterator.\nReturns the minimum element of an iterator.\nReturns the element that gives the minimum value with …\nReturns the element that gives the minimum value with …\nReturns the element that gives the minimum value from the …\nReturns the element that gives the minimum value from the …\nDetermines if the elements of this <code>Iterator</code> are not equal …\nDetermines if the elements of this <code>Iterator</code> are not equal …\nAdvances the iterator and returns the next value.\n\n\n\n\n\n\n\n\n\n\n\nOverflow Behavior\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRemoves and returns an element from the end of the …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdvances the iterator and returns an array containing the …\nAdvances the iterator and returns an array containing the …\n\n\n\nConsume and return the next value of this iterator if a …\nConsume and return the next item if it is equal to <code>expected</code>…\nReturns the <code>n</code>th element of the iterator.\nReturns the <code>n</code>th element of the iterator.\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the <code>n</code>th element from the end of the iterator.\nReturns the <code>n</code>th element from the end of the iterator.\n\n\n\n\n\n\n\n\n\nCreates an iterator that yields an element exactly once.\nCreates an iterator that lazily generates a value exactly …\nLexicographically compares the <code>PartialOrd</code> elements of this …\nLexicographically compares the <code>PartialOrd</code> elements of this …\nLexicographically compares the elements of this <code>Iterator</code> …\nLexicographically compares the elements of this <code>Iterator</code> …\nConsumes an iterator, creating two collections from it.\nConsumes an iterator, creating two collections from it.\nReorders the elements of this iterator <em>in-place</em> according …\nReorders the elements of this iterator <em>in-place</em> according …\nReturns a reference to the next() value without advancing …\nReturns a mutable reference to the next() value without …\nCreates an iterator which can use the <code>peek</code> and <code>peek_mut</code> …\nCreates an iterator which can use the <code>peek</code> and <code>peek_mut</code> …\nSearches for an element in an iterator, returning its …\nSearches for an element in an iterator, returning its …\nMethod which takes an iterator and generates <code>Self</code> from the …\nIterates over the entire iterator, multiplying all the …\nIterates over the entire iterator, multiplying all the …\nReduces the elements to a single one, by repeatedly …\nReduces the elements to a single one, by repeatedly …\nCreates a new iterator that endlessly repeats a single …\n\nCreates a new iterator that repeats elements of type <code>A</code> …\nReverses an iterator’s direction.\nReverses an iterator’s direction.\nSearches for an element of an iterator from the back that …\nSearches for an element of an iterator from the back that …\n\n\n\n\n\nAn iterator method that reduces the iterator’s elements …\nAn iterator method that reduces the iterator’s elements …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSearches for an element in an iterator from the right, …\nSearches for an element in an iterator from the right, …\nAn iterator adapter which, like <code>fold</code>, holds internal …\nAn iterator adapter which, like <code>fold</code>, holds internal …\n\n\n\n\n\nReturns the bounds on the remaining length of the iterator.\nReturns the bounds on the remaining length of the iterator.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreates an iterator that skips the first <code>n</code> elements.\nCreates an iterator that skips the first <code>n</code> elements.\nCreates an iterator that <code>skip</code>s elements based on a …\nCreates an iterator that <code>skip</code>s elements based on a …\nCreates an iterator starting at the same point, but …\nCreates an iterator starting at the same point, but …\nReturns the number of <em>successor</em> steps required to get from …\nCreates a new iterator where each successive item is …\nMethod which takes an iterator and generates <code>Self</code> from the …\nSums the elements of an iterator.\nSums the elements of an iterator.\nCreates an iterator that yields the first <code>n</code> elements, or …\nCreates an iterator that yields the first <code>n</code> elements, or …\nCreates an iterator that yields elements based on a …\nCreates an iterator that yields elements based on a …\nFallibly transforms an iterator into a collection, short …\nFallibly transforms an iterator into a collection, short …\nApplies function to the elements of iterator and returns …\nApplies function to the elements of iterator and returns …\n\n\nAn iterator method that applies a function as long as it …\nAn iterator method that applies a function as long as it …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAn iterator method that applies a fallible function to …\nAn iterator method that applies a fallible function to …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReduces the elements to a single one by repeatedly …\nReduces the elements to a single one by repeatedly …\n\n\nThis is the reverse version of <code>Iterator::try_fold()</code>: it …\nThis is the reverse version of <code>Iterator::try_fold()</code>: it …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConverts an iterator of pairs into a pair of containers.\nConverts an iterator of pairs into a pair of containers.\nConverts the arguments to iterators and zips them.\n‘Zips up’ two iterators into a single iterator of …\n‘Zips up’ two iterators into a single iterator of …\nA marker for types which can be used as types of <code>const</code> …\nDerive macro generating an impl of the trait <code>ConstParamTy</code>.\nTypes whose values can be duplicated simply by copying …\nDerive macro generating an impl of the trait <code>Copy</code>.\nA marker for types that can be dropped.\nThe type of the discriminant, which must satisfy the trait …\nCompiler-internal trait used to indicate the type of enum …\nA common trait implemented by all function pointers.\nZero-sized type used to mark things that “act like” …\nA marker type which does not implement <code>Unpin</code>.\nA marker for pointer-like types.\nTypes that can be transferred across thread boundaries.\nTypes with a constant size known at compile time.\nRequired trait for constants used in pattern matches.\nRequired trait for constants used in pattern matches.\nTypes for which it is safe to share references between …\nA marker for tuple types.\nTypes that do not require any pinning guarantees.\nTypes that can be “unsized” to a dynamically-sized …\nReturns the address of the function pointer.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\n\n\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n\n\n\n\n\n\n\n\nAssume only that alignment conditions are met.\nWhat transmutation safety conditions shall the compiler …\nAre values of a type transmutable into values of another …\nOpaque type representing the discriminant of an enum.\nAssume only that lifetime conditions are met.\nA wrapper to inhibit compiler from automatically calling <code>T</code>…\nA wrapper type to construct uninitialized instances of <code>T</code>.\nDo not assume that <em>you</em> have ensured any safety properties …\nAssume only that safety conditions are met.\nAssume only that dynamically-satisfiable validity …\n\nReturns the ABI-required minimum alignment of a type in …\nReturns the ABI-required minimum alignment of the type of …\nReturns the ABI-required minimum alignment of the type of …\nWhen <code>true</code>, the compiler assumes that <em>you</em> are ensuring …\nAssume both <code>self</code> and <code>other_assumptions</code>.\nExtracts the values from an array of <code>MaybeUninit</code> …\nReturns the contents of this <code>MaybeUninit</code> as a slice of …\nReturns the contents of this <code>MaybeUninit</code> as a mutable …\nGets a mutable pointer to the contained value. Reading …\nGets a pointer to the contained value. Reading from this …\nExtracts the value from the <code>MaybeUninit&lt;T&gt;</code> container. This …\nDrops the contained value in place.\nGets a mutable (unique) reference to the contained value.\nReads the value from the <code>MaybeUninit&lt;T&gt;</code> container. The …\nGets a shared reference to the contained value.\n\n\n\n\n\n\n\n\nAssume <code>self</code>, excepting <code>other_assumptions</code>.\n\n\n\n\n\nBitwise-copies a value.\n\n\n\nReturns a value uniquely identifying the enum variant in <code>v</code>.\nDisposes of a value.\nManually drops the contained value. This is exactly …\n\n\n\n\n\n\n\nTakes ownership and “forgets” about the value <strong>without </strong>…\nLike <code>forget</code>, but also accepts unsized values.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n\n\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nExtracts the value from the <code>ManuallyDrop</code> container.\nWhen <code>true</code>, the compiler assume that <em>you</em> are ensuring that …\nReturns the ABI-required minimum alignment of a type in …\nReturns the ABI-required minimum alignment of the type of …\nReturns <code>true</code> if dropping values of type <code>T</code> matters.\nWrap a value to be manually dropped.\nCreates a new <code>MaybeUninit&lt;T&gt;</code> initialized with the given …\nExpands to the offset in bytes of a field from the …\n\nMoves <code>src</code> into the referenced <code>dest</code>, returning the previous …\nWhen <code>true</code>, the compiler assumes that <em>you</em> have ensured that …\nReturns the size of a type in bytes.\nReturns the size of the pointed-to value in bytes.\nReturns the size of the pointed-to value in bytes.\nReturns the contents of this slice of <code>MaybeUninit</code> as a …\nReturns the contents of this mutable slice of <code>MaybeUninit</code> …\nGets a mutable pointer to the first element of the array.\nGets a pointer to the first element of the array.\nAssuming all the elements are initialized, get a mutable …\nAssuming all the elements are initialized, get a slice to …\n\nSwaps the values at two mutable locations, without …\nReplaces <code>dest</code> with the default value of <code>T</code>, returning the …\nTakes the value from the <code>ManuallyDrop&lt;T&gt;</code> container out.\nReinterprets the bits of a value of one type as another …\nInterprets <code>src</code> as having type <code>&amp;Dst</code>, and then reads <code>src</code> …\nTransposes a <code>MaybeUninit&lt;[T; N]&gt;</code> into a <code>[MaybeUninit&lt;T&gt;; N]</code>…\n\n\n\n\n\n\n\n\n\n\n\n\nCreates a new <code>MaybeUninit&lt;T&gt;</code> in an uninitialized state.\nCreate a new array of <code>MaybeUninit&lt;T&gt;</code> items, in an …\nBypasses Rust’s normal memory-initialization checks by …\nWhen <code>true</code>, the compiler assumes that <em>you</em> are ensuring that …\nReturns the number of variants in the enum type <code>T</code>.\nSets the value of the <code>MaybeUninit&lt;T&gt;</code>.\nCopies the elements from <code>src</code> to <code>this</code>, returning a mutable …\nClones the elements from <code>src</code> to <code>this</code>, returning a mutable …\nReturns the value of type <code>T</code> represented by the all-zero …\nCreates a new <code>MaybeUninit&lt;T&gt;</code> in an uninitialized state, …\nAn error which can be returned when parsing an IP address …\nAdmin-Local scope.\nThe size of an IPv4 address in bits.\nThe size of an IPv6 address in bits.\nAn IPv4 address representing the broadcast address: …\nGlobal scope.\nInterface-Local scope.\nAn IP address, either IPv4 or IPv6.\nAn IPv4 address.\nAn IPv6 address.\nScope of an IPv6 multicast address as defined in IETF RFC …\nAn IPv4 address with the address pointing to localhost: …\nAn IPv6 address representing localhost: <code>::1</code>.\nLink-Local scope.\nOrganization-Local scope.\nRealm-Local scope.\nSite-Local scope.\nAn internet socket address, either IPv4 or IPv6.\nAn IPv4 socket address.\nAn IPv6 socket address.\nAn IPv4 address representing an unspecified address: …\nAn IPv6 address representing the unspecified address: <code>::</code>\nAn IPv4 address.\nAn IPv4 socket address.\nAn IPv6 address.\nAn IPv6 socket address.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the flow information associated with this address.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCopies this address to a new <code>IpAddr::V4</code>.\nReturns the argument unchanged.\nCreates an <code>IpAddr::V4</code> from a four element byte array.\nCreates an <code>IpAddr::V6</code> from an eight element 16-bit array.\nCopies this address to a new <code>IpAddr::V6</code>.\nCreates an <code>IpAddr::V6</code> from a sixteen element byte array.\nCreates an <code>Ipv4Addr</code> from a four element byte array.\nReturns the argument unchanged.\nUses <code>Ipv4Addr::from_bits</code> to convert a host byte order <code>u32</code> …\nCreates an <code>Ipv6Addr</code> from a sixteen element byte array.\nCreates an <code>Ipv6Addr</code> from an eight element 16-bit array.\nReturns the argument unchanged.\nUses <code>Ipv6Addr::from_bits</code> to convert a host byte order <code>u128</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts a <code>SocketAddrV6</code> into a <code>SocketAddr::V6</code>.\nConverts a tuple struct (Into&lt;<code>IpAddr</code>&gt;, <code>u16</code>) into a …\nReturns the argument unchanged.\nConverts a <code>SocketAddrV4</code> into a <code>SocketAddr::V4</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts a native byte order <code>u32</code> into an IPv4 address.\nConverts a native byte order <code>u128</code> into an IPv6 address.\n\n\n\n\n\n\n\n\n\n\n\n\n\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the IP address associated with this socket address.\nReturns the IP address associated with this socket address.\nReturns the IP address associated with this socket address.\nReturns <code>true</code> if this address is in a range designated for …\nReturns <code>true</code> if this address part of the <code>198.18.0.0/15</code> …\nReturns <code>true</code> if this is an address reserved for …\nReturns <code>true</code> if this is a broadcast address (…\nReturns <code>true</code> if this address is in a range designated for …\nReturns <code>true</code> if this address is in a range designated for …\nReturns <code>true</code> if this is an address reserved for …\nReturns <code>true</code> if the address appears to be globally …\nReturns <code>true</code> if the address appears to be globally …\nReturns <code>true</code> if the address appears to be globally …\nReturns <code>true</code> if this address is an <code>IPv4</code> address, and <code>false</code> …\nReturns <code>true</code> if the IP address in this <code>SocketAddr</code> is an …\nReturns <code>true</code> if this address is an <code>IPv6</code> address, and <code>false</code> …\nReturns <code>true</code> if the IP address in this <code>SocketAddr</code> is an …\nReturns <code>true</code> if the address is link-local (<code>169.254.0.0/16</code>).\nReturns <code>true</code> if this is a loopback address.\nReturns <code>true</code> if this is a loopback address (<code>127.0.0.0/8</code>).\nReturns <code>true</code> if this is the loopback address (<code>::1</code>), as …\nReturns <code>true</code> if this is a multicast address.\nReturns <code>true</code> if this is a multicast address (<code>224.0.0.0/4</code>).\nReturns <code>true</code> if this is a multicast address (<code>ff00::/8</code>).\nReturns <code>true</code> if this is a private address.\nReturns <code>true</code> if this address is reserved by IANA for …\nReturns <code>true</code> if this address is part of the Shared Address …\nReturns <code>true</code> if this is a unicast address, as defined by …\nReturns <code>true</code> if the address is a globally routable unicast …\nReturns <code>true</code> if the address is a unicast address with …\nReturns <code>true</code> if this is a unique local address (<code>fc00::/7</code>).\nReturns <code>true</code> for the special ‘unspecified’ address.\nReturns <code>true</code> for the special ‘unspecified’ address (…\nReturns <code>true</code> for the special ‘unspecified’ address (<code>::</code>…\nReturns the address’s multicast scope if the address is …\nCreates a new IPv4 address from four eight-bit octets.\nCreates a new IPv6 address from eight 16-bit segments.\nCreates a new socket address from an IP address and a port …\nCreates a new socket address from an <code>IPv4</code> address and a …\nCreates a new socket address from an <code>IPv6</code> address, a …\n\n\n\n\nReturns the four eight-bit integers that make up this …\nReturns the sixteen eight-bit integers the IPv6 address …\nParse an IP address from a slice of bytes.\nParse an IPv4 address from a slice of bytes.\nParse an IPv6 address from a slice of bytes.\nParse a socket address from a slice of bytes.\nParse an IPv4 socket address from a slice of bytes.\nParse an IPv6 socket address from a slice of bytes.\n\n\n\n\n\n\n\n\n\n\nReturns the port number associated with this socket …\nReturns the port number associated with this socket …\nReturns the port number associated with this socket …\nReturns the scope ID associated with this address.\nReturns the eight 16-bit segments that make up this …\nChanges the flow information associated with this socket …\nChanges the IP address associated with this socket address.\nChanges the IP address associated with this socket address.\nChanges the IP address associated with this socket address.\nChanges the port number associated with this socket …\nChanges the port number associated with this socket …\nChanges the port number associated with this socket …\nChanges the scope ID associated with this socket address.\n\n\nConverts an IPv4 address into a <code>u32</code> representation using …\nConverts an IPv6 address into a <code>u128</code> representation using …\nConverts this address to an <code>IpAddr::V4</code> if it is an …\nConverts this address to an <code>IpAddr::V4</code> if it is an …\nConverts this address to an <code>IPv4</code> address if it is either …\nConverts this address to an <code>IPv4</code> address if it’s an …\nConverts this address to an IPv4-compatible <code>IPv6</code> address.\nConverts this address to an IPv4-mapped <code>IPv6</code> address.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe size of this non-zero integer type in bits.\nThe size of this non-zero integer type in bits.\nThe size of this non-zero integer type in bits.\nThe size of this non-zero integer type in bits.\nThe size of this non-zero integer type in bits.\nThe size of this non-zero integer type in bits.\nThe size of this non-zero integer type in bits.\nThe size of this non-zero integer type in bits.\nThe size of this non-zero integer type in bits.\nThe size of this non-zero integer type in bits.\nThe size of this non-zero integer type in bits.\nThe size of this non-zero integer type in bits.\nReturns the size of this integer type in bits.\nReturns the size of this integer type in bits.\nReturns the size of this integer type in bits.\nReturns the size of this integer type in bits.\nReturns the size of this integer type in bits.\nReturns the size of this integer type in bits.\nReturns the size of this integer type in bits.\nReturns the size of this integer type in bits.\nReturns the size of this integer type in bits.\nReturns the size of this integer type in bits.\nReturns the size of this integer type in bits.\nReturns the size of this integer type in bits.\nReturns the size of this integer type in bits.\nReturns the size of this integer type in bits.\nReturns the size of this integer type in bits.\nReturns the size of this integer type in bits.\nReturns the size of this integer type in bits.\nReturns the size of this integer type in bits.\nReturns the size of this integer type in bits.\nReturns the size of this integer type in bits.\nReturns the size of this integer type in bits.\nReturns the size of this integer type in bits.\nReturns the size of this integer type in bits.\nReturns the size of this integer type in bits.\nValue being parsed is empty.\nA classification of floating point numbers.\nPositive or negative infinity, which often results from …\nEnum to store the various types of errors that can cause …\nContains an invalid digit in its context.\nThe largest value that can be represented by this non-zero …\nThe largest value that can be represented by this non-zero …\nThe largest value that can be represented by this non-zero …\nThe largest value that can be represented by this non-zero …\nThe largest value that can be represented by this non-zero …\nThe largest value that can be represented by this non-zero …\nThe largest value that can be represented by this non-zero …\nThe largest value that can be represented by this non-zero …\nThe largest value that can be represented by this non-zero …\nThe largest value that can be represented by this non-zero …\nThe largest value that can be represented by this non-zero …\nThe largest value that can be represented by this non-zero …\nReturns the largest value that can be represented by this …\nReturns the largest value that can be represented by this …\nReturns the largest value that can be represented by this …\nReturns the largest value that can be represented by this …\nReturns the largest value that can be represented by this …\nReturns the largest value that can be represented by this …\nReturns the largest value that can be represented by this …\nReturns the largest value that can be represented by this …\nReturns the largest value that can be represented by this …\nReturns the largest value that can be represented by this …\nReturns the largest value that can be represented by this …\nReturns the largest value that can be represented by this …\nReturns the largest value that can be represented by this …\nReturns the largest value that can be represented by this …\nReturns the largest value that can be represented by this …\nReturns the largest value that can be represented by this …\nReturns the largest value that can be represented by this …\nReturns the largest value that can be represented by this …\nReturns the largest value that can be represented by this …\nReturns the largest value that can be represented by this …\nReturns the largest value that can be represented by this …\nReturns the largest value that can be represented by this …\nReturns the largest value that can be represented by this …\nReturns the largest value that can be represented by this …\nThe smallest value that can be represented by this non-zero\nThe smallest value that can be represented by this non-zero\nThe smallest value that can be represented by this non-zero\nThe smallest value that can be represented by this non-zero\nThe smallest value that can be represented by this non-zero\nThe smallest value that can be represented by this non-zero\nThe smallest value that can be represented by this non-zero\nThe smallest value that can be represented by this non-zero\nThe smallest value that can be represented by this non-zero\nThe smallest value that can be represented by this non-zero\nThe smallest value that can be represented by this non-zero\nThe smallest value that can be represented by this non-zero\nReturns the smallest value that can be represented by this …\nReturns the smallest value that can be represented by this …\nReturns the smallest value that can be represented by this …\nReturns the smallest value that can be represented by this …\nReturns the smallest value that can be represented by this …\nReturns the smallest value that can be represented by this …\nReturns the smallest value that can be represented by this …\nReturns the smallest value that can be represented by this …\nReturns the smallest value that can be represented by this …\nReturns the smallest value that can be represented by this …\nReturns the smallest value that can be represented by this …\nReturns the smallest value that can be represented by this …\nReturns the smallest value that can be represented by this …\nReturns the smallest value that can be represented by this …\nReturns the smallest value that can be represented by this …\nReturns the smallest value that can be represented by this …\nReturns the smallest value that can be represented by this …\nReturns the smallest value that can be represented by this …\nReturns the smallest value that can be represented by this …\nReturns the smallest value that can be represented by this …\nReturns the smallest value that can be represented by this …\nReturns the smallest value that can be represented by this …\nReturns the smallest value that can be represented by this …\nReturns the smallest value that can be represented by this …\nNaN (not a number): this value results from calculations …\nInteger is too small to store in target integer type.\nAn integer that is known not to equal zero.\nAn integer that is known not to equal zero.\nAn integer that is known not to equal zero.\nAn integer that is known not to equal zero.\nAn integer that is known not to equal zero.\nAn integer that is known not to equal zero.\nAn integer that is known not to equal zero.\nAn integer that is known not to equal zero.\nAn integer that is known not to equal zero.\nAn integer that is known not to equal zero.\nAn integer that is known not to equal zero.\nAn integer that is known not to equal zero.\nA regular floating point number, not any of the …\nAn error which can be returned when parsing a float.\nAn error which can be returned when parsing an integer.\nInteger is too large to store in target integer type.\nProvides intentionally-saturating arithmetic on <code>T</code>.\n“Subnormal” or “denormal” floating point …\nThe error type returned when a checked integral type …\nProvides intentionally-wrapped arithmetic on <code>T</code>.\nValue was Zero\nPositive or negative zero.\nComputes the absolute value of self. See <code>i8::abs</code> for …\nComputes the absolute value of self. See <code>i16::abs</code> for …\nComputes the absolute value of self. See <code>i32::abs</code> for …\nComputes the absolute value of self. See <code>i64::abs</code> for …\nComputes the absolute value of self. See <code>i128::abs</code> for …\nComputes the absolute value of self. See <code>isize::abs</code> for …\nSaturating absolute value. Computes <code>self.abs()</code>, returning …\nSaturating absolute value. Computes <code>self.abs()</code>, returning …\nSaturating absolute value. Computes <code>self.abs()</code>, returning …\nSaturating absolute value. Computes <code>self.abs()</code>, returning …\nSaturating absolute value. Computes <code>self.abs()</code>, returning …\nSaturating absolute value. Computes <code>self.abs()</code>, returning …\nComputes the absolute value of <code>self</code>, wrapping around at …\nComputes the absolute value of <code>self</code>, wrapping around at …\nComputes the absolute value of <code>self</code>, wrapping around at …\nComputes the absolute value of <code>self</code>, wrapping around at …\nComputes the absolute value of <code>self</code>, wrapping around at …\nComputes the absolute value of <code>self</code>, wrapping around at …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChecked absolute value. Checks for overflow and returns …\nChecked absolute value. Checks for overflow and returns …\nChecked absolute value. Checks for overflow and returns …\nChecked absolute value. Checks for overflow and returns …\nChecked absolute value. Checks for overflow and returns …\nChecked absolute value. Checks for overflow and returns …\nAdds an unsigned integer to a non-zero value. Checks for …\nAdds an unsigned integer to a non-zero value. Checks for …\nAdds an unsigned integer to a non-zero value. Checks for …\nAdds an unsigned integer to a non-zero value. Checks for …\nAdds an unsigned integer to a non-zero value. Checks for …\nAdds an unsigned integer to a non-zero value. Checks for …\nMultiplies two non-zero integers together. Checks for …\nMultiplies two non-zero integers together. Checks for …\nMultiplies two non-zero integers together. Checks for …\nMultiplies two non-zero integers together. Checks for …\nMultiplies two non-zero integers together. Checks for …\nMultiplies two non-zero integers together. Checks for …\nMultiplies two non-zero integers together. Checks for …\nMultiplies two non-zero integers together. Checks for …\nMultiplies two non-zero integers together. Checks for …\nMultiplies two non-zero integers together. Checks for …\nMultiplies two non-zero integers together. Checks for …\nMultiplies two non-zero integers together. Checks for …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> if …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> if …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> if …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> if …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> if …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> if …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nRaises non-zero value to an integer power. Checks for …\nRaises non-zero value to an integer power. Checks for …\nRaises non-zero value to an integer power. Checks for …\nRaises non-zero value to an integer power. Checks for …\nRaises non-zero value to an integer power. Checks for …\nRaises non-zero value to an integer power. Checks for …\nRaises non-zero value to an integer power. Checks for …\nRaises non-zero value to an integer power. Checks for …\nRaises non-zero value to an integer power. Checks for …\nRaises non-zero value to an integer power. Checks for …\nRaises non-zero value to an integer power. Checks for …\nRaises non-zero value to an integer power. Checks for …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\n\n\nReturns the argument unchanged.\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts <code>NonZeroU8</code> to <code>NonZeroU16</code> losslessly.\nReturns the argument unchanged.\nConverts <code>NonZeroU8</code> to <code>NonZeroU32</code> losslessly.\nConverts <code>NonZeroU16</code> to <code>NonZeroU32</code> losslessly.\nReturns the argument unchanged.\nConverts <code>NonZeroU8</code> to <code>NonZeroU64</code> losslessly.\nConverts <code>NonZeroU32</code> to <code>NonZeroU64</code> losslessly.\nReturns the argument unchanged.\nConverts <code>NonZeroU16</code> to <code>NonZeroU64</code> losslessly.\nReturns the argument unchanged.\nConverts <code>NonZeroU64</code> to <code>NonZeroU128</code> losslessly.\nConverts <code>NonZeroU32</code> to <code>NonZeroU128</code> losslessly.\nConverts <code>NonZeroU16</code> to <code>NonZeroU128</code> losslessly.\nConverts <code>NonZeroU8</code> to <code>NonZeroU128</code> losslessly.\n\nConverts <code>NonZeroU16</code> to <code>NonZeroUsize</code> losslessly.\nReturns the argument unchanged.\nConverts <code>NonZeroU8</code> to <code>NonZeroUsize</code> losslessly.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts <code>NonZeroI8</code> to <code>NonZeroI16</code> losslessly.\nConverts <code>NonZeroU8</code> to <code>NonZeroI16</code> losslessly.\nConverts <code>NonZeroU8</code> to <code>NonZeroI32</code> losslessly.\nReturns the argument unchanged.\nConverts <code>NonZeroU16</code> to <code>NonZeroI32</code> losslessly.\nConverts <code>NonZeroI16</code> to <code>NonZeroI32</code> losslessly.\nConverts <code>NonZeroI8</code> to <code>NonZeroI32</code> losslessly.\nConverts <code>NonZeroU32</code> to <code>NonZeroI64</code> losslessly.\nConverts <code>NonZeroI16</code> to <code>NonZeroI64</code> losslessly.\nConverts <code>NonZeroU16</code> to <code>NonZeroI64</code> losslessly.\nConverts <code>NonZeroI8</code> to <code>NonZeroI64</code> losslessly.\nReturns the argument unchanged.\nConverts <code>NonZeroU8</code> to <code>NonZeroI64</code> losslessly.\nConverts <code>NonZeroI32</code> to <code>NonZeroI64</code> losslessly.\nConverts <code>NonZeroI64</code> to <code>NonZeroI128</code> losslessly.\nReturns the argument unchanged.\nConverts <code>NonZeroI8</code> to <code>NonZeroI128</code> losslessly.\nConverts <code>NonZeroU8</code> to <code>NonZeroI128</code> losslessly.\nConverts <code>NonZeroU16</code> to <code>NonZeroI128</code> losslessly.\nConverts <code>NonZeroI16</code> to <code>NonZeroI128</code> losslessly.\nConverts <code>NonZeroU32</code> to <code>NonZeroI128</code> losslessly.\nConverts <code>NonZeroU64</code> to <code>NonZeroI128</code> losslessly.\nConverts <code>NonZeroI32</code> to <code>NonZeroI128</code> losslessly.\nConverts <code>NonZeroI8</code> to <code>NonZeroIsize</code> losslessly.\nReturns the argument unchanged.\nConverts <code>NonZeroI16</code> to <code>NonZeroIsize</code> losslessly.\nConverts <code>NonZeroU8</code> to <code>NonZeroIsize</code> losslessly.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from big endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\nConverts an integer from little endian to the target’s …\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the value as a primitive type.\nReturns the value as a primitive type.\nReturns the value as a primitive type.\nReturns the value as a primitive type.\nReturns the value as a primitive type.\nReturns the value as a primitive type.\nReturns the value as a primitive type.\nReturns the value as a primitive type.\nReturns the value as a primitive type.\nReturns the value as a primitive type.\nReturns the value as a primitive type.\nReturns the value as a primitive type.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if and only if <code>self == (1 &lt;&lt; k)</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == (1 &lt;&lt; k)</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == (1 &lt;&lt; k)</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == (1 &lt;&lt; k)</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == (1 &lt;&lt; k)</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == (1 &lt;&lt; k)</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nOutputs the detailed cause of parsing an integer failing.\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\nCalculates the middle point of <code>self</code> and <code>rhs</code>.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreates a non-zero if the given value is not zero.\nCreates a non-zero if the given value is not zero.\nCreates a non-zero if the given value is not zero.\nCreates a non-zero if the given value is not zero.\nCreates a non-zero if the given value is not zero.\nCreates a non-zero if the given value is not zero.\nCreates a non-zero if the given value is not zero.\nCreates a non-zero if the given value is not zero.\nCreates a non-zero if the given value is not zero.\nCreates a non-zero if the given value is not zero.\nCreates a non-zero if the given value is not zero.\nCreates a non-zero if the given value is not zero.\nCreates a non-zero without checking whether the value is …\nCreates a non-zero without checking whether the value is …\nCreates a non-zero without checking whether the value is …\nCreates a non-zero without checking whether the value is …\nCreates a non-zero without checking whether the value is …\nCreates a non-zero without checking whether the value is …\nCreates a non-zero without checking whether the value is …\nCreates a non-zero without checking whether the value is …\nCreates a non-zero without checking whether the value is …\nCreates a non-zero without checking whether the value is …\nCreates a non-zero without checking whether the value is …\nCreates a non-zero without checking whether the value is …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nReturns the smallest power of two greater than or equal to …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComputes the absolute value of self, with overflow …\nComputes the absolute value of self, with overflow …\nComputes the absolute value of self, with overflow …\nComputes the absolute value of self, with overflow …\nComputes the absolute value of self, with overflow …\nComputes the absolute value of self, with overflow …\nNegates self, overflowing if this is equal to the minimum …\nNegates self, overflowing if this is equal to the minimum …\nNegates self, overflowing if this is equal to the minimum …\nNegates self, overflowing if this is equal to the minimum …\nNegates self, overflowing if this is equal to the minimum …\nNegates self, overflowing if this is equal to the minimum …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nRaises self to the power of <code>exp</code>, using exponentiation by …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReverses the bit pattern of the integer.\nReverses the bit pattern of the integer.\nReverses the bit pattern of the integer.\nReverses the bit pattern of the integer.\nReverses the bit pattern of the integer.\nReverses the bit pattern of the integer.\nReverses the bit pattern of the integer.\nReverses the bit pattern of the integer.\nReverses the bit pattern of the integer.\nReverses the bit pattern of the integer.\nReverses the bit pattern of the integer.\nReverses the bit pattern of the integer.\nReverses the bit pattern of the integer.\nReverses the bit pattern of the integer.\nReverses the bit pattern of the integer.\nReverses the bit pattern of the integer.\nReverses the bit pattern of the integer.\nReverses the bit pattern of the integer.\nReverses the bit pattern of the integer.\nReverses the bit pattern of the integer.\nReverses the bit pattern of the integer.\nReverses the bit pattern of the integer.\nReverses the bit pattern of the integer.\nReverses the bit pattern of the integer.\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nSaturating absolute value, see <code>i8::saturating_abs</code>.\nSaturating absolute value, see <code>i16::saturating_abs</code>.\nSaturating absolute value, see <code>i32::saturating_abs</code>.\nSaturating absolute value, see <code>i64::saturating_abs</code>.\nSaturating absolute value, see <code>i128::saturating_abs</code>.\nSaturating absolute value, see <code>isize::saturating_abs</code>.\nAdds an unsigned integer to a non-zero value. Return …\nAdds an unsigned integer to a non-zero value. Return …\nAdds an unsigned integer to a non-zero value. Return …\nAdds an unsigned integer to a non-zero value. Return …\nAdds an unsigned integer to a non-zero value. Return …\nAdds an unsigned integer to a non-zero value. Return …\nMultiplies two non-zero integers together. Return …\nMultiplies two non-zero integers together. Return …\nMultiplies two non-zero integers together. Return …\nMultiplies two non-zero integers together. Return …\nMultiplies two non-zero integers together. Return …\nMultiplies two non-zero integers together. Return …\nMultiplies two non-zero integers together. Return …\nMultiplies two non-zero integers together. Return …\nMultiplies two non-zero integers together. Return …\nMultiplies two non-zero integers together. Return …\nMultiplies two non-zero integers together. Return …\nMultiplies two non-zero integers together. Return …\nSaturating negation. Computes <code>-self</code>, returning …\nSaturating negation. Computes <code>-self</code>, returning …\nSaturating negation. Computes <code>-self</code>, returning …\nSaturating negation. Computes <code>-self</code>, returning …\nSaturating negation. Computes <code>-self</code>, returning …\nSaturating negation. Computes <code>-self</code>, returning …\nRaise non-zero value to an integer power. Return …\nRaise non-zero value to an integer power. Return …\nRaise non-zero value to an integer power. Return …\nRaise non-zero value to an integer power. Return …\nRaise non-zero value to an integer power. Return …\nRaise non-zero value to an integer power. Return …\nRaise non-zero value to an integer power. Return …\nRaise non-zero value to an integer power. Return …\nRaise non-zero value to an integer power. Return …\nRaise non-zero value to an integer power. Return …\nRaise non-zero value to an integer power. Return …\nRaise non-zero value to an integer power. Return …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns a number representing sign of <code>self</code>.\nReturns a number representing sign of <code>self</code>.\nReturns a number representing sign of <code>self</code>.\nReturns a number representing sign of <code>self</code>.\nReturns a number representing sign of <code>self</code>.\nReturns a number representing sign of <code>self</code>.\nReturns a number representing sign of <code>self</code>.\nReturns a number representing sign of <code>self</code>.\nReturns a number representing sign of <code>self</code>.\nReturns a number representing sign of <code>self</code>.\nReturns a number representing sign of <code>self</code>.\nReturns a number representing sign of <code>self</code>.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nReverses the byte order of the integer.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to big endian from the target’s endianness.\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nConverts <code>self</code> to little endian from the target’s …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\n\n\n\n\nAttempts to convert <code>NonZeroI16</code> to <code>NonZeroU8</code>.\nAttempts to convert <code>NonZeroIsize</code> to <code>NonZeroU8</code>.\nAttempts to convert <code>NonZeroI32</code> to <code>NonZeroU8</code>.\nAttempts to convert <code>NonZeroU128</code> to <code>NonZeroU8</code>.\nAttempts to convert <code>NonZeroI128</code> to <code>NonZeroU8</code>.\nAttempts to convert <code>NonZeroU32</code> to <code>NonZeroU8</code>.\nAttempts to convert <code>NonZeroI64</code> to <code>NonZeroU8</code>.\nAttempts to convert <code>u8</code> to <code>NonZeroU8</code>.\nAttempts to convert <code>NonZeroUsize</code> to <code>NonZeroU8</code>.\n\nAttempts to convert <code>NonZeroU64</code> to <code>NonZeroU8</code>.\nAttempts to convert <code>NonZeroI8</code> to <code>NonZeroU8</code>.\nAttempts to convert <code>NonZeroU16</code> to <code>NonZeroU8</code>.\nAttempts to convert <code>NonZeroU128</code> to <code>NonZeroU16</code>.\nAttempts to convert <code>NonZeroI16</code> to <code>NonZeroU16</code>.\nAttempts to convert <code>u16</code> to <code>NonZeroU16</code>.\n\nAttempts to convert <code>NonZeroI8</code> to <code>NonZeroU16</code>.\nAttempts to convert <code>NonZeroI128</code> to <code>NonZeroU16</code>.\nAttempts to convert <code>NonZeroI64</code> to <code>NonZeroU16</code>.\nAttempts to convert <code>NonZeroIsize</code> to <code>NonZeroU16</code>.\nAttempts to convert <code>NonZeroI32</code> to <code>NonZeroU16</code>.\nAttempts to convert <code>NonZeroU32</code> to <code>NonZeroU16</code>.\nAttempts to convert <code>NonZeroU64</code> to <code>NonZeroU16</code>.\nAttempts to convert <code>NonZeroUsize</code> to <code>NonZeroU16</code>.\nAttempts to convert <code>NonZeroU64</code> to <code>NonZeroU32</code>.\nAttempts to convert <code>NonZeroU128</code> to <code>NonZeroU32</code>.\nAttempts to convert <code>NonZeroI16</code> to <code>NonZeroU32</code>.\nAttempts to convert <code>NonZeroI32</code> to <code>NonZeroU32</code>.\nAttempts to convert <code>NonZeroIsize</code> to <code>NonZeroU32</code>.\nAttempts to convert <code>u32</code> to <code>NonZeroU32</code>.\nAttempts to convert <code>NonZeroI8</code> to <code>NonZeroU32</code>.\nAttempts to convert <code>NonZeroI128</code> to <code>NonZeroU32</code>.\nAttempts to convert <code>NonZeroI64</code> to <code>NonZeroU32</code>.\nAttempts to convert <code>NonZeroUsize</code> to <code>NonZeroU32</code>.\n\nAttempts to convert <code>NonZeroI16</code> to <code>NonZeroU64</code>.\nAttempts to convert <code>NonZeroI32</code> to <code>NonZeroU64</code>.\nAttempts to convert <code>NonZeroIsize</code> to <code>NonZeroU64</code>.\nAttempts to convert <code>NonZeroUsize</code> to <code>NonZeroU64</code>.\nAttempts to convert <code>NonZeroI8</code> to <code>NonZeroU64</code>.\nAttempts to convert <code>NonZeroI64</code> to <code>NonZeroU64</code>.\nAttempts to convert <code>u64</code> to <code>NonZeroU64</code>.\nAttempts to convert <code>NonZeroU128</code> to <code>NonZeroU64</code>.\nAttempts to convert <code>NonZeroI128</code> to <code>NonZeroU64</code>.\n\nAttempts to convert <code>NonZeroI64</code> to <code>NonZeroU128</code>.\nAttempts to convert <code>NonZeroI32</code> to <code>NonZeroU128</code>.\n\nAttempts to convert <code>NonZeroI128</code> to <code>NonZeroU128</code>.\nAttempts to convert <code>NonZeroI8</code> to <code>NonZeroU128</code>.\nAttempts to convert <code>NonZeroI16</code> to <code>NonZeroU128</code>.\nAttempts to convert <code>u128</code> to <code>NonZeroU128</code>.\nAttempts to convert <code>NonZeroIsize</code> to <code>NonZeroU128</code>.\nAttempts to convert <code>NonZeroUsize</code> to <code>NonZeroU128</code>.\nAttempts to convert <code>usize</code> to <code>NonZeroUsize</code>.\nAttempts to convert <code>NonZeroI8</code> to <code>NonZeroUsize</code>.\nAttempts to convert <code>NonZeroI16</code> to <code>NonZeroUsize</code>.\nAttempts to convert <code>NonZeroI128</code> to <code>NonZeroUsize</code>.\nAttempts to convert <code>NonZeroIsize</code> to <code>NonZeroUsize</code>.\nAttempts to convert <code>NonZeroU32</code> to <code>NonZeroUsize</code>.\n\nAttempts to convert <code>NonZeroU128</code> to <code>NonZeroUsize</code>.\nAttempts to convert <code>NonZeroI32</code> to <code>NonZeroUsize</code>.\nAttempts to convert <code>NonZeroU64</code> to <code>NonZeroUsize</code>.\nAttempts to convert <code>NonZeroI64</code> to <code>NonZeroUsize</code>.\nAttempts to convert <code>NonZeroI16</code> to <code>NonZeroI8</code>.\nAttempts to convert <code>NonZeroUsize</code> to <code>NonZeroI8</code>.\nAttempts to convert <code>NonZeroI32</code> to <code>NonZeroI8</code>.\nAttempts to convert <code>NonZeroU64</code> to <code>NonZeroI8</code>.\nAttempts to convert <code>NonZeroU16</code> to <code>NonZeroI8</code>.\nAttempts to convert <code>NonZeroI64</code> to <code>NonZeroI8</code>.\nAttempts to convert <code>NonZeroIsize</code> to <code>NonZeroI8</code>.\nAttempts to convert <code>NonZeroU32</code> to <code>NonZeroI8</code>.\nAttempts to convert <code>NonZeroI128</code> to <code>NonZeroI8</code>.\nAttempts to convert <code>NonZeroU128</code> to <code>NonZeroI8</code>.\nAttempts to convert <code>NonZeroU8</code> to <code>NonZeroI8</code>.\n\nAttempts to convert <code>i8</code> to <code>NonZeroI8</code>.\nAttempts to convert <code>i16</code> to <code>NonZeroI16</code>.\nAttempts to convert <code>NonZeroI64</code> to <code>NonZeroI16</code>.\nAttempts to convert <code>NonZeroI128</code> to <code>NonZeroI16</code>.\nAttempts to convert <code>NonZeroU128</code> to <code>NonZeroI16</code>.\nAttempts to convert <code>NonZeroIsize</code> to <code>NonZeroI16</code>.\nAttempts to convert <code>NonZeroU64</code> to <code>NonZeroI16</code>.\nAttempts to convert <code>NonZeroI32</code> to <code>NonZeroI16</code>.\n\nAttempts to convert <code>NonZeroU32</code> to <code>NonZeroI16</code>.\nAttempts to convert <code>NonZeroU16</code> to <code>NonZeroI16</code>.\nAttempts to convert <code>NonZeroUsize</code> to <code>NonZeroI16</code>.\nAttempts to convert <code>NonZeroU128</code> to <code>NonZeroI32</code>.\nAttempts to convert <code>NonZeroI64</code> to <code>NonZeroI32</code>.\nAttempts to convert <code>NonZeroIsize</code> to <code>NonZeroI32</code>.\nAttempts to convert <code>NonZeroU32</code> to <code>NonZeroI32</code>.\nAttempts to convert <code>NonZeroU64</code> to <code>NonZeroI32</code>.\nAttempts to convert <code>NonZeroI128</code> to <code>NonZeroI32</code>.\nAttempts to convert <code>NonZeroUsize</code> to <code>NonZeroI32</code>.\n\nAttempts to convert <code>i32</code> to <code>NonZeroI32</code>.\nAttempts to convert <code>NonZeroI128</code> to <code>NonZeroI64</code>.\nAttempts to convert <code>i64</code> to <code>NonZeroI64</code>.\nAttempts to convert <code>NonZeroUsize</code> to <code>NonZeroI64</code>.\n\nAttempts to convert <code>NonZeroU64</code> to <code>NonZeroI64</code>.\nAttempts to convert <code>NonZeroU128</code> to <code>NonZeroI64</code>.\nAttempts to convert <code>NonZeroIsize</code> to <code>NonZeroI64</code>.\n\nAttempts to convert <code>i128</code> to <code>NonZeroI128</code>.\nAttempts to convert <code>NonZeroUsize</code> to <code>NonZeroI128</code>.\nAttempts to convert <code>NonZeroIsize</code> to <code>NonZeroI128</code>.\nAttempts to convert <code>NonZeroU128</code> to <code>NonZeroI128</code>.\nAttempts to convert <code>NonZeroI128</code> to <code>NonZeroIsize</code>.\nAttempts to convert <code>NonZeroU64</code> to <code>NonZeroIsize</code>.\nAttempts to convert <code>NonZeroU32</code> to <code>NonZeroIsize</code>.\nAttempts to convert <code>NonZeroI64</code> to <code>NonZeroIsize</code>.\nAttempts to convert <code>NonZeroU16</code> to <code>NonZeroIsize</code>.\n\nAttempts to convert <code>NonZeroUsize</code> to <code>NonZeroIsize</code>.\nAttempts to convert <code>isize</code> to <code>NonZeroIsize</code>.\nAttempts to convert <code>NonZeroI32</code> to <code>NonZeroIsize</code>.\nAttempts to convert <code>NonZeroU128</code> to <code>NonZeroIsize</code>.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdds an unsigned integer to a non-zero value, assuming …\nAdds an unsigned integer to a non-zero value, assuming …\nAdds an unsigned integer to a non-zero value, assuming …\nAdds an unsigned integer to a non-zero value, assuming …\nAdds an unsigned integer to a non-zero value, assuming …\nAdds an unsigned integer to a non-zero value, assuming …\nMultiplies two non-zero integers together, assuming …\nMultiplies two non-zero integers together, assuming …\nMultiplies two non-zero integers together, assuming …\nMultiplies two non-zero integers together, assuming …\nMultiplies two non-zero integers together, assuming …\nMultiplies two non-zero integers together, assuming …\nMultiplies two non-zero integers together, assuming …\nMultiplies two non-zero integers together, assuming …\nMultiplies two non-zero integers together, assuming …\nMultiplies two non-zero integers together, assuming …\nMultiplies two non-zero integers together, assuming …\nMultiplies two non-zero integers together, assuming …\nComputes the absolute value of self without any wrapping …\nComputes the absolute value of self without any wrapping …\nComputes the absolute value of self without any wrapping …\nComputes the absolute value of self without any wrapping …\nComputes the absolute value of self without any wrapping …\nComputes the absolute value of self without any wrapping …\nWrapping absolute value, see <code>i8::wrapping_abs</code>.\nWrapping absolute value, see <code>i16::wrapping_abs</code>.\nWrapping absolute value, see <code>i32::wrapping_abs</code>.\nWrapping absolute value, see <code>i64::wrapping_abs</code>.\nWrapping absolute value, see <code>i128::wrapping_abs</code>.\nWrapping absolute value, see <code>isize::wrapping_abs</code>.\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nThe addition operator <code>+</code>.\nThe addition assignment operator <code>+=</code>.\nThe bitwise AND operator <code>&amp;</code>.\nThe bitwise AND assignment operator <code>&amp;=</code>.\nThe bitwise OR operator <code>|</code>.\nThe bitwise OR assignment operator <code>|=</code>.\nThe bitwise XOR operator <code>^</code>.\nThe bitwise XOR assignment operator <code>^=</code>.\nAn endpoint of a range of keys.\nExit the operation without running subsequent phases.\nTrait that indicates that this is a pointer or a wrapper …\nThe coroutine completed with a return value.\nMove on to the next phase of the operation as normal.\nUsed to tell an operation whether it should exit early or …\nThe trait implemented by builtin coroutine types.\nThe result of a coroutine resumption.\nUsed for immutable dereferencing operations, like <code>*v</code>.\nUsed for mutable dereferencing operations, like in <code>*v = 1;</code>.\n<code>DispatchFromDyn</code> is used in the implementation of object …\nThe division operator <code>/</code>.\nThe division assignment operator <code>/=</code>.\nCustom code within the destructor.\nAn exclusive bound.\nThe version of the call operator that takes an immutable …\nThe version of the call operator that takes a mutable …\nThe version of the call operator that takes a by-value …\nUsed to specify which residuals can be converted into …\nAn inclusive bound.\nUsed for indexing operations (<code>container[index]</code>) in …\nUsed for indexing operations (<code>container[index]</code>) in mutable …\nThe multiplication operator <code>*</code>.\nThe multiplication assignment operator <code>*=</code>.\nThe unary negation operator <code>-</code>.\nThe unary logical negation operator <code>!</code>.\n<code>OneSidedRange</code> is implemented for built-in range types that …\nThe resulting type after applying the <code>+</code> operator.\nThe resulting type after applying the <code>-</code> operator.\nThe resulting type after applying the <code>-</code> operator.\nThe resulting type after applying the <code>!</code> operator.\nThe returned type after the call operator is used.\nThe type of the value produced by <code>?</code> when <em>not</em> …\nThe resulting type after applying the <code>*</code> operator.\nThe resulting type after applying the <code>/</code> operator.\nThe resulting type after applying the <code>%</code> operator.\nThe resulting type after applying the <code>&amp;</code> operator.\nThe resulting type after applying the <code>|</code> operator.\nThe resulting type after applying the <code>^</code> operator.\nThe resulting type after applying the <code>&lt;&lt;</code> operator.\nThe resulting type after applying the <code>&gt;&gt;</code> operator.\nThe returned type after indexing.\nA (half-open) range bounded inclusively below and …\n<code>RangeBounds</code> is implemented by Rust’s built-in range …\nA range only bounded inclusively below (<code>start..</code>).\nAn unbounded range (<code>..</code>).\nA range bounded inclusively below and above (<code>start..=end</code>).\nA range only bounded exclusively above (<code>..end</code>).\nA range only bounded inclusively above (<code>..=end</code>).\n\nThe remainder operator <code>%</code>.\nThe remainder assignment operator <code>%=</code>.\nAllows retrieving the canonical type implementing <code>Try</code> that …\nThe type of the value passed to <code>FromResidual::from_residual</code>\nThe type of value this coroutine returns.\nThe left shift operator <code>&lt;&lt;</code>. Note that because this trait …\nThe left shift assignment operator <code>&lt;&lt;=</code>.\nThe right shift operator <code>&gt;&gt;</code>. Note that because this trait …\nThe right shift assignment operator <code>&gt;&gt;=</code>.\nThe subtraction operator <code>-</code>.\nThe subtraction assignment operator <code>-=</code>.\nThe resulting type after dereferencing.\nThe <code>?</code> operator and <code>try {}</code> blocks.\nThe “return” type of this meta-function.\nAn infinite endpoint. Indicates that there is no bound in …\nImplement <code>FromResidual&lt;Yeet&lt;T&gt;&gt;</code> on your type to enable …\nThe type of value this coroutine yields.\nThe coroutine suspended with a value.\nPerforms the <code>+</code> operation.\nPerforms the <code>+=</code> operation.\n\n\nConverts from <code>&amp;mut Bound&lt;T&gt;</code> to <code>Bound&lt;&amp;mut T&gt;</code>.\nConverts from <code>&amp;Bound&lt;T&gt;</code> to <code>Bound&lt;&amp;T&gt;</code>.\nPerforms the <code>&amp;</code> operation.\nPerforms the <code>&amp;=</code> operation.\nPerforms the <code>|</code> operation.\nPerforms the <code>|=</code> operation.\nPerforms the <code>^</code> operation.\nPerforms the <code>^=</code> operation.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUsed in <code>?</code> to decide whether the operator should produce a …\n\nConverts the <code>ControlFlow</code> into an <code>Option</code> which is <code>Some</code> if …\nPerforms the call operation.\nPerforms the call operation.\nPerforms the call operation.\n\n\n\n\n\n\n\n\n\nMap a <code>Bound&lt;&amp;T&gt;</code> to a <code>Bound&lt;T&gt;</code> by cloning the contents of …\n\nReturns <code>true</code> if <code>item</code> is contained in the range.\nReturns <code>true</code> if <code>item</code> is contained in the range.\nReturns <code>true</code> if <code>item</code> is contained in the range.\nReturns <code>true</code> if <code>item</code> is contained in the range.\nReturns <code>true</code> if <code>item</code> is contained in the range.\nReturns <code>true</code> if <code>item</code> is contained in the range.\nReturns <code>true</code> if <code>item</code> is contained in the range.\nConverts the <code>ControlFlow</code> into an <code>Option</code> which is <code>Some</code> if …\n\n\n\n\nDereferences the value.\nMutably dereferences the value.\nPerforms the <code>/</code> operation.\nPerforms the <code>/=</code> operation.\nExecutes the destructor for this type.\nReturns the upper bound of the range (inclusive).\nThe upper bound of the range (exclusive).\nThe upper bound of the range (exclusive).\nThe upper bound of the range (inclusive)\nEnd index bound.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs the type from its <code>Output</code> type.\n\nConstructs the type from a compatible <code>Residual</code> type.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPerforms the indexing (<code>container[index]</code>) operation.\n\n\n\n\n\n\n\n\n\n\n\n\nPerforms the mutable indexing (<code>container[index]</code>) operation.\n\n\n\n\n\n\n\n\n\n\n\n\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDestructures the <code>RangeInclusive</code> into (lower bound, upper …\n\n\n\nReturns <code>true</code> if this is a <code>Break</code> variant.\nReturns <code>true</code> if this is a <code>Continue</code> variant.\nReturns <code>true</code> if the range contains no items.\nReturns <code>true</code> if the range contains no items.\n\n\n\n\nMaps a <code>Bound&lt;T&gt;</code> to a <code>Bound&lt;U&gt;</code> by applying a function to …\nMaps <code>ControlFlow&lt;B, C&gt;</code> to <code>ControlFlow&lt;T, C&gt;</code> by applying a …\nMaps <code>ControlFlow&lt;B, C&gt;</code> to <code>ControlFlow&lt;B, T&gt;</code> by applying a …\n\n\n\n\nPerforms the <code>*</code> operation.\nPerforms the <code>*=</code> operation.\nPerforms the unary <code>-</code> operation.\nCreates a new inclusive range. Equivalent to writing …\n\n\n\n\n\nPerforms the unary <code>!</code> operation.\n\n\n\n\n\n\nPerforms the <code>%</code> operation.\nPerforms the <code>%=</code> operation.\nResumes the execution of this coroutine.\n\nPerforms the <code>&lt;&lt;</code> operation.\nPerforms the <code>&lt;&lt;=</code> operation.\nPerforms the <code>&gt;&gt;</code> operation.\nPerforms the <code>&gt;&gt;=</code> operation.\n\n\n\nReturns the lower bound of the range (inclusive).\nThe lower bound of the range (inclusive).\nThe lower bound of the range (inclusive).\nStart index bound.\n\n\n\n\n\n\n\n\n\n\n\nPerforms the <code>-</code> operation.\nPerforms the <code>-=</code> operation.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAn iterator over the value in <code>Some</code> variant of an <code>Option</code>.\nAn iterator over a reference to the <code>Some</code> variant of an …\nAn iterator over a mutable reference to the <code>Some</code> variant …\nNo value.\nThe <code>Option</code> type. See the module level documentation for …\nSome value of type <code>T</code>.\nReturns <code>None</code> if the option is <code>None</code>, otherwise returns <code>optb</code>.\nReturns <code>None</code> if the option is <code>None</code>, otherwise calls <code>f</code> with …\nConverts from <code>Option&lt;T&gt;</code> (or <code>&amp;Option&lt;T&gt;</code>) to …\nConverts from <code>Option&lt;T&gt;</code> (or <code>&amp;mut Option&lt;T&gt;</code>) to …\nConverts from <code>&amp;mut Option&lt;T&gt;</code> to <code>Option&lt;&amp;mut T&gt;</code>.\nReturns a mutable slice of the contained value, if any. If …\nConverts from Pin&lt;&amp;mut Option&lt;T&gt;&gt; to Option&lt;Pin&lt;&amp;mut T&gt;&gt;.\nConverts from Pin&lt;&amp;Option&lt;T&gt;&gt; to Option&lt;Pin&lt;&amp;T&gt;&gt;.\nConverts from <code>&amp;Option&lt;T&gt;</code> to <code>Option&lt;&amp;T&gt;</code>.\nReturns a slice of the contained value, if any. If this is …\n\n\n\n\n\n\n\n\n\n\n\n\n\nMaps an <code>Option&lt;&amp;mut T&gt;</code> to an <code>Option&lt;T&gt;</code> by cloning the …\nMaps an <code>Option&lt;&amp;T&gt;</code> to an <code>Option&lt;T&gt;</code> by cloning the contents …\n\nMaps an <code>Option&lt;&amp;mut T&gt;</code> to an <code>Option&lt;T&gt;</code> by copying the …\nMaps an <code>Option&lt;&amp;T&gt;</code> to an <code>Option&lt;T&gt;</code> by copying the contents …\nReturns <code>None</code>.\n\nReturns the contained <code>Some</code> value, consuming the <code>self</code> value.\nReturns <code>None</code> if the option is <code>None</code>, otherwise calls …\nConverts from <code>Option&lt;Option&lt;T&gt;&gt;</code> to <code>Option&lt;T&gt;</code>.\n\n\n\n\nConverts from <code>&amp;mut Option&lt;T&gt;</code> to <code>Option&lt;&amp;mut T&gt;</code>\nConverts from <code>&amp;Option&lt;T&gt;</code> to <code>Option&lt;&amp;T&gt;</code>.\nMoves <code>val</code> into a new <code>Some</code>.\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTakes each element in the <code>Iterator</code>: if it is <code>None</code>, no …\n\n\n\nInserts <code>value</code> into the option if it is <code>None</code>, then returns …\nInserts the default value into the option if it is <code>None</code>, …\nInserts a value computed from <code>f</code> into the option if it is …\n\nInserts <code>value</code> into the option, then returns a mutable …\nCalls the provided closure with a reference to the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n\nReturns a consuming iterator over the possibly contained …\n\n\n\n\nReturns <code>true</code> if the option is a <code>None</code> value.\nReturns <code>true</code> if the option is a <code>Some</code> value.\nReturns <code>true</code> if the option is a <code>Some</code> and the value inside …\nReturns an iterator over the possibly contained value.\nReturns a mutable iterator over the possibly contained …\nMaps an <code>Option&lt;T&gt;</code> to <code>Option&lt;U&gt;</code> by applying a function to a …\nReturns the provided default result (if none), or applies …\nComputes a default function result (if none), or applies a …\n\n\n\n\n\n\nTransforms the <code>Option&lt;T&gt;</code> into a <code>Result&lt;T, E&gt;</code>, mapping …\nTransforms the <code>Option&lt;T&gt;</code> into a <code>Result&lt;T, E&gt;</code>, mapping …\nReturns the option if it contains a value, otherwise …\nReturns the option if it contains a value, otherwise calls …\n\nTakes each element in the <code>Iterator</code>: if it is a <code>None</code>, no …\nReplaces the actual value in the option by the value given …\n\n\n\nTakes each element in the <code>Iterator</code>: if it is a <code>None</code>, no …\nTakes the value out of the option, leaving a <code>None</code> in its …\nTakes the value out of the option, but only if the …\nTransposes an <code>Option</code> of a <code>Result</code> into a <code>Result</code> of an <code>Option</code>…\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the contained <code>Some</code> value, consuming the <code>self</code> value.\nReturns the contained <code>Some</code> value or a provided default.\nReturns the contained <code>Some</code> value or a default.\nReturns the contained <code>Some</code> value or computes it from a …\nReturns the contained <code>Some</code> value, consuming the <code>self</code> value,\nUnzips an option containing a tuple of two options.\nReturns <code>Some</code> if exactly one of <code>self</code>, <code>optb</code> is <code>Some</code>, …\nZips <code>self</code> with another <code>Option</code>.\nZips <code>self</code> and another <code>Option</code> with function <code>f</code>.\nA simple wrapper around a type to assert that it is unwind …\nA struct containing information about the location of a …\nA struct providing information about a panic.\nA marker trait representing types where a shared reference …\nA marker trait which represents “panic safe” types in …\n\n\n\n\n\n\n\nReturns the source location of the caller of this …\nReturns whether the panic handler is allowed to unwind the …\n\n\nReturns the column from which the panic originated.\n\n\n\n\nReturns the name of the source file from which the panic …\n\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n\n\nReturns the line number from which the panic originated.\nReturns information about the location from which the …\nIf the <code>panic!</code> macro from the <code>core</code> crate (not from <code>std</code>) was …\n\nReturns the payload associated with the panic.\n\n\n\n\n\n\n\n\n\n\n\n\nThis function is used instead of panic_fmt in const eval.\nThe underlying implementation of core’s <code>panic!</code> macro …\n\n\nThe entry point for panicking with a formatted message.\nLike <code>panic</code>, but without unwinding and track_caller to …\nLike <code>panic_fmt</code>, but for non-unwinding panics.\nLike <code>panic_nounwind</code>, but also inhibits showing a backtrace.\n\n\nA pointer which pins its pointee in place.\nGets <code>Pin&lt;&amp;mut T&gt;</code> to the underlying pinned value from this …\nGets a mutable reference to the pinned value this <code>Pin&lt;Ptr&gt;</code> …\nGets a shared reference to the pinned value this <code>Pin</code> …\n\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\n\nGets a mutable reference to the data inside of this <code>Pin</code>.\nGets a shared reference out of a pin.\nGets a mutable reference to the data inside of this <code>Pin</code>.\n\n\nCalls <code>U::from(self)</code>.\n\n\nUnwraps this <code>Pin&lt;Ptr&gt;</code>, returning the underlying pointer.\nUnwraps this <code>Pin&lt;Ptr&gt;</code>, returning the underlying <code>Ptr</code>.\nConverts this <code>Pin&lt;&amp;mut T&gt;</code> into a <code>Pin&lt;&amp;T&gt;</code> with the same …\n\n\nConstructs a new pin by mapping the interior value.\nConstruct a new pin by mapping the interior value.\n\nConstruct a new <code>Pin&lt;Ptr&gt;</code> around a pointer to some data of …\nConstruct a new <code>Pin&lt;Ptr&gt;</code> around a reference to some data …\n\nConstructs a Pin&lt;&amp;mut T&gt;, by pinning a <code>value: T</code> locally.\n\n\n\nAssigns a new value to the memory location pointed to by …\n\nGet a pinning mutable reference from a static mutable …\nGet a pinning reference from a <code>&amp;&#39;static</code> reference.\n\n\n\nThe 2015 version of the core prelude.\nThe 2018 version of the core prelude.\nThe 2021 version of the core prelude.\nThe 2024 edition of the core prelude.\nThe first version of the core prelude.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAttribute macro applied to a function to register it as a …\n\nAttribute macro applied to a function to turn it into a …\n\nKeeps the item it’s applied to if the passed path is …\nExpands all <code>#[cfg]</code> and <code>#[cfg_attr]</code> attributes in the code …\n\n\n\n\n\nAttribute macro used to apply derive macros.\nAttribute macro used to apply derive macros for …\n\n\n\n\n\nAttribute macro applied to a static to register it as a …\n\n\n\n\n\n\n\n\nAttribute macro applied to a function to turn it into a …\nAn implementation detail of the <code>#[test]</code> and <code>#[bench]</code> …\n\nUnstable placeholder for type ascription.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA type storing a <code>usize</code> which is a power of two, and thus …\nThe metadata for a <code>Dyn = dyn SomeTrait</code> trait object type.\nThe smallest possible alignment, 1.\nThe type for metadata in pointers and references to <code>Self</code>.\n<code>*mut T</code> but non-zero and covariant.\nProvides the pointer metadata type of any pointed-to type.\nPointers to types implementing this trait alias are …\n\nCalculates the offset from a pointer (convenience for …\nGets the “address” portion of the pointer.\nCompares the <em>addresses</em> of the two pointers for equality, …\nCreate a <code>const</code> raw pointer to a place, without creating an …\nCreate a <code>mut</code> raw pointer to a place, without creating an …\nReturns the alignment of the type associated with this …\nComputes the offset that needs to be applied to the …\nReturns a unique reference to the value. If the value may …\nReturns a raw pointer to the slice’s buffer.\nReturns a non-null pointer to the slice’s buffer.\nReturns the alignment as a <code>NonZeroUsize</code>\nAcquires the underlying <code>*mut</code> pointer.\nReturns a shared reference to the value. If the value may …\nReturns a unique references to the value. In contrast to …\nReturns a shared references to the value. In contrast to …\nReturns a shared reference to a slice of possibly …\nReturns a unique reference to a slice of possibly …\nReturns the alignment as a <code>usize</code>\n\n\n\n\n\n\nCalculates the offset from a pointer in bytes (convenience …\nCalculates the offset from a pointer in bytes.\nCalculates the distance between two pointers. The returned …\nCalculates the offset from a pointer in bytes (convenience …\nCasts to a pointer of another type.\n\n\n\n\n\n\nCopies <code>count * size_of::&lt;T&gt;()</code> bytes from <code>src</code> to <code>dst</code>. The …\nCopies <code>count * size_of&lt;T&gt;</code> bytes from <code>src</code> to <code>self</code>. The …\nCopies <code>count * size_of&lt;T&gt;</code> bytes from <code>src</code> to <code>self</code>. The …\nCopies <code>count * size_of::&lt;T&gt;()</code> bytes from <code>src</code> to <code>dst</code>. The …\nCopies <code>count * size_of&lt;T&gt;</code> bytes from <code>self</code> to <code>dest</code>. The …\nCopies <code>count * size_of&lt;T&gt;</code> bytes from <code>self</code> to <code>dest</code>. The …\nCreates a new <code>NonNull</code> that is dangling, but well-aligned.\n\nExecutes the destructor (if any) of the pointed-to value.\nExecutes the destructor (if any) of the pointed-to value.\nCompares raw pointers for equality.\n\n\n\n\n\n\n\nReturns the argument unchanged.\nConverts a <code>&amp;mut T</code> to a <code>NonNull&lt;T&gt;</code>.\nReturns the argument unchanged.\nConverts a <code>&amp;T</code> to a <code>NonNull&lt;T&gt;</code>.\nReturns the argument unchanged.\nConvert an address back to a pointer, picking up a …\nConvert an address back to a mutable pointer, picking up a …\nConvert a mutable reference to a raw pointer.\nForms a (possibly-wide) raw pointer from a data address …\nPerforms the same functionality as <code>std::ptr::from_raw_parts</code>…\nPerforms the same functionality as <code>from_raw_parts</code>, except …\nConvert a reference to a raw pointer.\nReturns a raw pointer to an element or subslice, without …\nHash a raw pointer.\n\n\n\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates an invalid pointer with the given address.\nCreates an invalid mutable pointer with the given address.\nReturns whether the pointer is properly aligned for <code>T</code>.\nReturns whether the pointer is aligned to <code>align</code>.\nReturns the size and alignment together as a <code>Layout</code>\nReturns the length of a non-null raw slice.\nReturns the base-2 logarithm of the alignment.\nCreates a new pointer by mapping <code>self</code>’s address to a new …\nReturns a bit mask that can be used to match this …\nExtract the metadata component of a pointer.\nCreates a new <code>NonNull</code> if <code>ptr</code> is non-null.\nCreates an <code>Alignment</code> from a <code>usize</code>, or returns <code>None</code> if it’…\nCreates a new <code>NonNull</code>.\nCreates an <code>Alignment</code> from a power-of-two <code>usize</code>.\nCreates a null raw pointer.\nCreates a null mutable raw pointer.\nReturns the alignment for a type.\nCalculates the offset from a pointer.\nCalculates the distance between two pointers. The returned …\n\n\n\nReads the value from <code>src</code> without moving it. This leaves the\nReads the value from <code>self</code> without moving it. This leaves …\nReads the value from <code>src</code> without moving it. This leaves the\nReads the value from <code>self</code> without moving it. This leaves …\nPerforms a volatile read of the value from <code>src</code> without …\nPerforms a volatile read of the value from <code>self</code> without …\nMoves <code>src</code> into the pointed <code>dst</code>, returning the previous <code>dst</code> …\nReplaces the value at <code>self</code> with <code>src</code>, returning the old …\nReturns the size of the type associated with this vtable.\nForms a raw slice from a pointer and a length.\nCreates a non-null raw slice from a thin pointer and a …\nPerforms the same functionality as <code>slice_from_raw_parts</code>, …\nCalculates the offset from a pointer (convenience for …\nCalculates the distance between two pointers, <em>where it’s </em>…\nSwaps the values at two mutable locations of the same …\nSwaps the values at two mutable locations of the same …\nSwaps <code>count * size_of::&lt;T&gt;()</code> bytes between the two regions …\nDecompose a (possibly wide) pointer into its address and …\n\n\n\n\n\n\n\n\n\n\n\nCreates a new pointer with the given address.\nOverwrites a memory location with the given value without …\nOverwrites a memory location with the given value without …\nSets <code>count * size_of::&lt;T&gt;()</code> bytes of memory starting at <code>dst</code>…\nInvokes memset on the specified pointer, setting …\nOverwrites a memory location with the given value without …\nOverwrites a memory location with the given value without …\nPerforms a volatile write of a memory location with the …\nPerforms a volatile write of a memory location with the …\nContains the error value\nAn iterator over the value in a <code>Ok</code> variant of a <code>Result</code>.\nAn iterator over a reference to the <code>Ok</code> variant of a <code>Result</code>.\nAn iterator over a mutable reference to the <code>Ok</code> variant of …\nContains the success value\n<code>Result</code> is a type that represents either success (<code>Ok</code>) or …\nReturns <code>res</code> if the result is <code>Ok</code>, otherwise returns the <code>Err</code> …\nCalls <code>op</code> if the result is <code>Ok</code>, otherwise returns the <code>Err</code> …\nConverts from <code>Result&lt;T, E&gt;</code> (or <code>&amp;Result&lt;T, E&gt;</code>) to …\nConverts from <code>Result&lt;T, E&gt;</code> (or <code>&amp;mut Result&lt;T, E&gt;</code>) to …\nConverts from <code>&amp;mut Result&lt;T, E&gt;</code> to <code>Result&lt;&amp;mut T, &amp;mut E&gt;</code>.\nConverts from <code>&amp;Result&lt;T, E&gt;</code> to <code>Result&lt;&amp;T, &amp;E&gt;</code>.\n\n\n\n\n\n\n\n\n\n\n\n\n\nMaps a <code>Result&lt;&amp;T, E&gt;</code> to a <code>Result&lt;T, E&gt;</code> by cloning the …\nMaps a <code>Result&lt;&amp;mut T, E&gt;</code> to a <code>Result&lt;T, E&gt;</code> by cloning the …\n\nMaps a <code>Result&lt;&amp;T, E&gt;</code> to a <code>Result&lt;T, E&gt;</code> by copying the …\nMaps a <code>Result&lt;&amp;mut T, E&gt;</code> to a <code>Result&lt;T, E&gt;</code> by copying the …\n\nConverts from <code>Result&lt;T, E&gt;</code> to <code>Option&lt;E&gt;</code>.\nReturns the contained <code>Ok</code> value, consuming the <code>self</code> value.\nReturns the contained <code>Err</code> value, consuming the <code>self</code> value.\nConverts from <code>Result&lt;Result&lt;T, E&gt;, E&gt;</code> to <code>Result&lt;T, E&gt;</code>\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTakes each element in the <code>Iterator</code>: if it is an <code>Err</code>, no …\n\n\n\n\nCalls the provided closure with a reference to the …\nCalls the provided closure with a reference to the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the contained <code>Err</code> value, but never panics.\nReturns a consuming iterator over the possibly contained …\n\n\n\n\n\nReturns the contained <code>Ok</code> value, but never panics.\nReturns <code>true</code> if the result is <code>Err</code>.\nReturns <code>true</code> if the result is <code>Err</code> and the value inside of …\nReturns <code>true</code> if the result is <code>Ok</code>.\nReturns <code>true</code> if the result is <code>Ok</code> and the value inside of …\nReturns an iterator over the possibly contained value.\nReturns a mutable iterator over the possibly contained …\nMaps a <code>Result&lt;T, E&gt;</code> to <code>Result&lt;U, E&gt;</code> by applying a function …\nMaps a <code>Result&lt;T, E&gt;</code> to <code>Result&lt;T, F&gt;</code> by applying a function …\nReturns the provided default (if <code>Err</code>), or applies a …\nMaps a <code>Result&lt;T, E&gt;</code> to <code>U</code> by applying fallback function …\n\n\n\n\n\n\nConverts from <code>Result&lt;T, E&gt;</code> to <code>Option&lt;T&gt;</code>.\nReturns <code>res</code> if the result is <code>Err</code>, otherwise returns the <code>Ok</code> …\nCalls <code>op</code> if the result is <code>Err</code>, otherwise returns the <code>Ok</code> …\n\nTakes each element in the <code>Iterator</code>: if it is an <code>Err</code>, no …\n\n\n\nTakes each element in the <code>Iterator</code>: if it is an <code>Err</code>, no …\nTransposes a <code>Result</code> of an <code>Option</code> into an <code>Option</code> of a <code>Result</code>…\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the contained <code>Ok</code> value, consuming the <code>self</code> value.\nReturns the contained <code>Err</code> value, consuming the <code>self</code> value.\nReturns the contained <code>Err</code> value, consuming the <code>self</code> value, …\nReturns the contained <code>Ok</code> value or a provided default.\nReturns the contained <code>Ok</code> value or a default\nReturns the contained <code>Ok</code> value or computes it from a …\nReturns the contained <code>Ok</code> value, consuming the <code>self</code> value, …\nThe number of bytes in a bitmask with this many lanes.\nThis type, reinterpreted as bytes.\nMap from the elements of the input vector to the output …\nNumber of elements in this vector.\nSpecifies the number of lanes in a SIMD vector as a type.\nA SIMD vector mask for <code>N</code> elements of width specified by …\nThe mask element type corresponding to this element type.\nMarker trait for types that may be used as SIMD mask …\nA SIMD vector with the shape of <code>[T; N]</code> but the operations …\nSupporting trait for <code>Simd::cast</code>.  Typically doesn’t need …\nMarker trait for types that may be used as SIMD vector …\nStatically guarantees that a lane count is marked as …\nCreate a vector from the elements of another vector.\nConvert SIMD vectors to vectors of bytes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns true if all elements are set, or false otherwise.\nReturns true if any element is set, or false otherwise.\nReturns an array reference containing the entire SIMD …\n\n\nReturns a mutable array reference containing the entire …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConverts the mask to a mask of any other element size.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTraits for comparing and ordering vectors.\n\nCreate a new vector from the elements of <code>first</code> and <code>second</code>.\nCreate a new vector from the elements of <code>first</code> and <code>second</code>.\nCreate a new mask from the elements of <code>first</code> and <code>second</code>.\nCreate a new mask from the elements of <code>first</code> and <code>second</code>.\nWrites a SIMD vector to the first <code>N</code> elements of a slice.\n\n\n\n\nDeinterleave two vectors.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA SIMD vector with one element of type <code>f32</code>.\nA SIMD vector with 16 elements of type <code>f32</code>.\nA SIMD vector with two elements of type <code>f32</code>.\nA SIMD vector with 32 elements of type <code>f32</code>.\nA SIMD vector with four elements of type <code>f32</code>.\nA SIMD vector with 64 elements of type <code>f32</code>.\nA SIMD vector with eight elements of type <code>f32</code>.\nA SIMD vector with one element of type <code>f64</code>.\nA SIMD vector with 16 elements of type <code>f64</code>.\nA SIMD vector with two elements of type <code>f64</code>.\nA SIMD vector with 32 elements of type <code>f64</code>.\nA SIMD vector with four elements of type <code>f64</code>.\nA SIMD vector with 64 elements of type <code>f64</code>.\nA SIMD vector with eight elements of type <code>f64</code>.\nFind the index of the first set element.\n\nA <code>Simd&lt;T, N&gt;</code> has a debug format like the one for <code>[T]</code>:\nReturns the argument unchanged.\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConverts an array of bools to a SIMD mask.\nConverts an array to a SIMD vector.\nCreate an integer value from its representation as a byte …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreate a mask from a bitmask.\nCreate a mask from a bitmask vector.\n\n\n\n\nConverts a vector of integers to a mask, where 0 …\nConverts a vector of integers to a mask, where 0 …\nCreate an integer value from its representation as a byte …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreate a native endian integer value from its memory …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConverts a slice to a SIMD vector containing <code>slice[..N]</code>.\nReads from potentially discontiguous indices in <code>slice</code> to …\nReads from indices in <code>slice</code> to construct a SIMD vector. If …\nRead elementwise from pointers into a SIMD vector.\nReads from indices in <code>slice</code> to construct a SIMD vector. …\nConditionally read elementwise from pointers into a SIMD …\nReads from indices in <code>slice</code> to construct a SIMD vector. …\n\nA SIMD vector with one element of type <code>i16</code>.\nA SIMD vector with 16 elements of type <code>i16</code>.\nA SIMD vector with two elements of type <code>i16</code>.\nA SIMD vector with 32 elements of type <code>i16</code>.\nA SIMD vector with four elements of type <code>i16</code>.\nA SIMD vector with 64 elements of type <code>i16</code>.\nA SIMD vector with eight elements of type <code>i16</code>.\nA SIMD vector with one element of type <code>i32</code>.\nA SIMD vector with 16 elements of type <code>i32</code>.\nA SIMD vector with two elements of type <code>i32</code>.\nA SIMD vector with 32 elements of type <code>i32</code>.\nA SIMD vector with four elements of type <code>i32</code>.\nA SIMD vector with 64 elements of type <code>i32</code>.\nA SIMD vector with eight elements of type <code>i32</code>.\nA SIMD vector with one element of type <code>i64</code>.\nA SIMD vector with 16 elements of type <code>i64</code>.\nA SIMD vector with two elements of type <code>i64</code>.\nA SIMD vector with 32 elements of type <code>i64</code>.\nA SIMD vector with four elements of type <code>i64</code>.\nA SIMD vector with 64 elements of type <code>i64</code>.\nA SIMD vector with eight elements of type <code>i64</code>.\nA SIMD vector with one element of type <code>i8</code>.\nA SIMD vector with 16 elements of type <code>i8</code>.\nA SIMD vector with two elements of type <code>i8</code>.\nA SIMD vector with 32 elements of type <code>i8</code>.\nA SIMD vector with four elements of type <code>i8</code>.\nA SIMD vector with 64 elements of type <code>i8</code>.\nA SIMD vector with eight elements of type <code>i8</code>.\n\n\nInterleave two vectors.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA SIMD vector with one element of type <code>isize</code>.\nA SIMD vector with 16 elements of type <code>isize</code>.\nA SIMD vector with two elements of type <code>isize</code>.\nA SIMD vector with 32 elements of type <code>isize</code>.\nA SIMD vector with four elements of type <code>isize</code>.\nA SIMD vector with 64 elements of type <code>isize</code>.\nA SIMD vector with eight elements of type <code>isize</code>.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the number of elements in this SIMD vector.\nA SIMD mask with one element for vectors with 16-bit …\nA SIMD mask with 16 elements for vectors with 16-bit …\nA SIMD mask with two elements for vectors with 16-bit …\nA SIMD mask with 32 elements for vectors with 16-bit …\nA SIMD mask with four elements for vectors with 16-bit …\nA SIMD mask with 64 elements for vectors with 16-bit …\nA SIMD mask with eight elements for vectors with 16-bit …\nA SIMD mask with one element for vectors with 32-bit …\nA SIMD mask with 16 elements for vectors with 32-bit …\nA SIMD mask with two elements for vectors with 32-bit …\nA SIMD mask with 32 elements for vectors with 32-bit …\nA SIMD mask with four elements for vectors with 32-bit …\nA SIMD mask with 64 elements for vectors with 32-bit …\nA SIMD mask with eight elements for vectors with 32-bit …\nA SIMD mask with one element for vectors with 64-bit …\nA SIMD mask with 16 elements for vectors with 64-bit …\nA SIMD mask with two elements for vectors with 64-bit …\nA SIMD mask with 32 elements for vectors with 64-bit …\nA SIMD mask with four elements for vectors with 64-bit …\nA SIMD mask with 64 elements for vectors with 64-bit …\nA SIMD mask with eight elements for vectors with 64-bit …\nA SIMD mask with one element for vectors with 8-bit …\nA SIMD mask with 16 elements for vectors with 8-bit …\nA SIMD mask with two elements for vectors with 8-bit …\nA SIMD mask with 32 elements for vectors with 8-bit …\nA SIMD mask with four elements for vectors with 8-bit …\nA SIMD mask with 64 elements for vectors with 8-bit …\nA SIMD mask with eight elements for vectors with 8-bit …\nA SIMD mask with one element for vectors with …\nA SIMD mask with 16 elements for vectors with …\nA SIMD mask with two elements for vectors with …\nA SIMD mask with 32 elements for vectors with …\nA SIMD mask with four elements for vectors with …\nA SIMD mask with 64 elements for vectors with …\nA SIMD mask with eight elements for vectors with …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTraits for vectors with numeric elements.\n\n\nThe portable SIMD prelude.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTraits for vectors of pointers.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nResize a vector.\nReverse the order of the elements in the vector.\n\n\n\n\n\n\n\n\n\n\nRotates the vector such that the first <code>OFFSET</code> elements of …\nRotates the vector such that the first <code>self.len() - OFFSET</code> …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWrites the values in a SIMD vector to potentially …\nWrite pointers elementwise into a SIMD vector.\nWrites values from a SIMD vector to multiple potentially …\nConditionally write pointers elementwise into a SIMD …\nWrites values from a SIMD vector to multiple potentially …\nChoose elements from two vectors.\nChoose elements from two masks.\nSets the value of the specified element.\nSets the value of the specified element.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConstructs a new SIMD vector by copying elements from …\nConstruct a mask by setting all elements to the given …\nConstructs a new SIMD vector with all elements set to the …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreate a new vector from the elements of <code>vector</code>.\nCreate a new vector from the elements of <code>vector</code>.\nSwizzle a vector of bytes according to the index vector. …\nCreate a new mask from the elements of <code>mask</code>.\nCreate a new mask from the elements of <code>mask</code>.\nTests the value of the specified element.\nTests the value of the specified element.\nConverts a SIMD mask to an array of bools.\nConverts a SIMD vector to an array.\nReturn the memory representation of this integer as a byte …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreate a bitmask from a mask.\nCreate a bitmask vector from a mask.\n\n\n\n\nConverts the mask to a vector of integers, where 0 …\n\n\nReturn the memory representation of this integer as a byte …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturn the memory representation of this integer as a byte …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA SIMD vector with one element of type <code>u16</code>.\nA SIMD vector with 16 elements of type <code>u16</code>.\nA SIMD vector with two elements of type <code>u16</code>.\nA SIMD vector with 32 elements of type <code>u16</code>.\nA SIMD vector with four elements of type <code>u16</code>.\nA SIMD vector with 64 elements of type <code>u16</code>.\nA SIMD vector with eight elements of type <code>u16</code>.\nA SIMD vector with one element of type <code>u32</code>.\nA SIMD vector with 16 elements of type <code>u32</code>.\nA SIMD vector with two elements of type <code>u32</code>.\nA SIMD vector with 32 elements of type <code>u32</code>.\nA SIMD vector with four elements of type <code>u32</code>.\nA SIMD vector with 64 elements of type <code>u32</code>.\nA SIMD vector with eight elements of type <code>u32</code>.\nA SIMD vector with one element of type <code>u64</code>.\nA SIMD vector with 16 elements of type <code>u64</code>.\nA SIMD vector with two elements of type <code>u64</code>.\nA SIMD vector with 32 elements of type <code>u64</code>.\nA SIMD vector with four elements of type <code>u64</code>.\nA SIMD vector with 64 elements of type <code>u64</code>.\nA SIMD vector with eight elements of type <code>u64</code>.\nA SIMD vector with one element of type <code>u8</code>.\nA SIMD vector with 16 elements of type <code>u8</code>.\nA SIMD vector with two elements of type <code>u8</code>.\nA SIMD vector with 32 elements of type <code>u8</code>.\nA SIMD vector with four elements of type <code>u8</code>.\nA SIMD vector with 64 elements of type <code>u8</code>.\nA SIMD vector with eight elements of type <code>u8</code>.\nA SIMD vector with one element of type <code>usize</code>.\nA SIMD vector with 16 elements of type <code>usize</code>.\nA SIMD vector with two elements of type <code>usize</code>.\nA SIMD vector with 32 elements of type <code>usize</code>.\nA SIMD vector with four elements of type <code>usize</code>.\nA SIMD vector with 64 elements of type <code>usize</code>.\nA SIMD vector with eight elements of type <code>usize</code>.\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe mask type returned by each comparison.\nParallel <code>Ord</code>.\nParallel <code>PartialEq</code>.\nParallel <code>PartialOrd</code>.\nRestrict each element to a certain interval.\nTest if each element is equal to the corresponding element …\nTest if each element is greater than or equal to the …\nTest if each element is greater than the corresponding …\nTest if each element is less than or equal to the …\nTest if each element is less than the corresponding …\nReturns the element-wise maximum with <code>other</code>.\nReturns the element-wise minimum with <code>other</code>.\nTest if each element is equal to the corresponding element …\nBit representation of this SIMD vector type.\nA SIMD vector with a different element type.\nA SIMD vector with a different element type.\nA SIMD vector with a different element type.\nMask type used for manipulating this SIMD vector type.\nMask type used for manipulating this SIMD vector type.\nScalar type contained by this SIMD vector type.\nScalar type contained by this SIMD vector type.\nScalar type contained by this SIMD vector type.\nOperations on SIMD vectors of floats.\nOperations on SIMD vectors of signed integers.\nOperations on SIMD vectors of unsigned integers.\nA SIMD vector of unsigned integers with the same element …\nProduces a vector where every element has the absolute …\nLanewise absolute value, implemented in Rust. Every …\nPerforms elementwise conversion of this vector’s …\nPerforms elementwise conversion of this vector’s …\nPerforms elementwise conversion of this vector’s …\nReturns each element with the magnitude of <code>self</code> and the …\nRaw transmutation from an unsigned integer vector type …\nReturns true for each element if its value is neither …\nReturns true for each element if its value is positive …\nReturns true for each element if its value is <code>NaN</code>.\nReturns true for each negative element and false if it is …\nReturns true for each element if its value is neither …\nReturns true for each positive element and false if it is …\nReturns true for each element if it has a negative sign, …\nReturns true for each element if it has a positive sign, …\nReturns true for each element if its value is subnormal.\nReturns the number of leading ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nTakes the reciprocal (inverse) of each element, <code>1/x</code>.\nReturns the cumulative bitwise “and” across the …\nReturns the cumulative bitwise “and” across the …\nReturns the maximum element in the vector.\nReturns the maximum element in the vector.\nReturns the maximum element in the vector.\nReturns the minimum element in the vector.\nReturns the minimum element in the vector.\nReturns the minimum element in the vector.\nReturns the cumulative bitwise “or” across the …\nReturns the cumulative bitwise “or” across the …\nReducing multiply.  Returns the product of the elements of …\nReturns the product of the elements of the vector, with …\nReturns the product of the elements of the vector, with …\nReturns the sum of the elements of the vector.\nReturns the sum of the elements of the vector, with …\nReturns the sum of the elements of the vector, with …\nReturns the cumulative bitwise “xor” across the …\nReturns the cumulative bitwise “xor” across the …\nReverses the order of bits in each elemnent. The least …\nReverses the order of bits in each elemnent. The least …\nLanewise saturating absolute value, implemented in Rust. …\nLanewise saturating add.\nLanewise saturating add.\nLanewise saturating negation, implemented in Rust. As …\nLanewise saturating subtract.\nLanewise saturating subtract.\nReplaces each element with a number that represents its …\nReturns numbers representing the sign of each element.\nRestrict each element to a certain interval unless it is …\nReturns the maximum of each element.\nReturns the minimum of each element.\nReverses the byte order of each element.\nReverses the byte order of each element.\nRaw transmutation to an unsigned integer vector type with …\nConverts each element from radians to degrees.\nRounds toward zero and converts to the same-width integer …\nConverts each element from degrees to radians.\nReturns the number of trailing ones in the binary …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nWrapping negation.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVector of const pointers with the same number of elements.\nVector of const pointers with the same number of elements.\nVector of constant pointers to the same type.\nVector of <code>isize</code> with the same number of elements.\nVector of <code>isize</code> with the same number of elements.\nMask type used for manipulating this SIMD vector type.\nMask type used for manipulating this SIMD vector type.\nVector of mutable pointers to the same type.\nOperations on SIMD vectors of constant pointers.\nOperations on SIMD vectors of mutable pointers.\nVector of <code>usize</code> with the same number of elements.\nVector of <code>usize</code> with the same number of elements.\nGets the “address” portion of the pointer.\nGets the “address” portion of the pointer.\nCasts to a pointer of another type.\nCasts to a pointer of another type.\nChanges constness without changing the type.\nChanges constness without changing the type.\nGets the “address” portion of the pointer, and “…\nGets the “address” portion of the pointer, and “…\nConvert an address back to a pointer, picking up a …\nConvert an address back to a pointer, picking up a …\nReturns <code>true</code> for each element that is null.\nReturns <code>true</code> for each element that is null.\nCreates a new pointer with the given address.\nCreates a new pointer with the given address.\nCalculates the offset from a pointer using wrapping …\nCalculates the offset from a pointer using wrapping …\nCalculates the offset from a pointer using wrapping …\nCalculates the offset from a pointer using wrapping …\nCalculates the offset from a pointer using wrapping …\nCalculates the offset from a pointer using wrapping …\nAn iterator over a slice in (non-overlapping) chunks (<code>N</code> …\nAn iterator over a slice in (non-overlapping) mutable …\nA windowed iterator over a slice in overlapping chunks (<code>N</code> …\nAn iterator over a slice in (non-overlapping) chunks (…\nAn iterator over a slice in (non-overlapping) chunks (…\nAn iterator over a slice in (non-overlapping) mutable …\nAn iterator over a slice in (non-overlapping) mutable …\nAn iterator over the escaped version of a byte slice.\nThe error type returned by <code>get_many_mut&lt;N&gt;</code>.\nAn iterator over slice in (non-overlapping) chunks …\nAn iterator over slice in (non-overlapping) mutable chunks …\nThe element type of the slice being matched on.\nImmutable slice iterator\nMutable slice iterator.\nThe output type returned by methods.\nAn iterator over a slice in (non-overlapping) chunks (…\nAn iterator over a slice in (non-overlapping) chunks (…\nAn iterator over a slice in (non-overlapping) mutable …\nAn iterator over a slice in (non-overlapping) mutable …\nAn iterator over subslices separated by elements that …\nAn iterator over the subslices of the vector which are …\nAn iterator over subslices separated by elements that …\nAn iterator over subslices separated by elements that …\nA helper trait used for indexing operations.\nPatterns in slices - currently, only used by <code>strip_prefix</code> …\nAn iterator over subslices separated by elements that …\nAn iterator over subslices separated by elements that …\nAn iterator over the mutable subslices of the vector which …\nAn iterator over the mutable subslices of the vector which …\nAn iterator over subslices separated by elements that …\nAn iterator over subslices separated by elements that …\nAn iterator over overlapping subslices of length <code>size</code>.\n\n\n\n\n\n\n\n\nViews the underlying data as a mutable subslice of the …\n\n\nCurrently, the consumers of <code>SlicePattern</code> need a slice.\nViews the underlying data as a subslice of the original …\nViews the underlying data as a subslice of the original …\nReturns a slice which contains items not yet handled by …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreates an empty slice iterator.\nCreates an empty slice iterator.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts a reference to T into a slice of length 1 …\nForms a mutable slice from a pointer range.\nForms a slice from a pointer range.\nForms a slice from a pointer and a length.\nPerforms the same functionality as <code>from_raw_parts</code>, except …\nConverts a reference to T into a slice of length 1 …\nReturns a shared reference to the output at this location, …\nReturns a mutable reference to the output at this …\nReturns a shared reference to the output at this location, …\nReturns a mutable reference to the output at this …\n\nReturns a shared reference to the output at this location, …\nReturns a mutable reference to the output at this …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the remainder of the original slice that is not …\nReturns the remainder of the original slice that is not …\nReturns the remainder of the original slice that is not …\nViews the underlying data as a subslice of the original …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPure rust memchr implementation, taken from rust-memchr\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPerforms bounds-checking of a range.\nReturns the remainder of the original slice that is not …\nReturns the remainder of the original slice that is not …\nReturns the remainder of the original slice that is not …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSlice sorting\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the first index matching the byte <code>x</code> in <code>text</code>.\nReturns the last index matching the byte <code>x</code> in <code>text</code>.\nInternal type used by merge_sort.\n\n\n\n\nReturns the argument unchanged.\nSorts <code>v</code> using heapsort, which guarantees <em>O</em>(<em>n</em> * log(<em>n</em>)) …\nCalls <code>U::from(self)</code>.\nThis merge sort borrows some (but not all) ideas from …\nSorts <code>v</code> using pattern-defeating quicksort, which is <em>O</em>(<em>n</em> * …\n\n\n\nAn iterator over the bytes of a string slice.\nAn iterator over the <code>char</code>s of a string slice, and their …\nAn iterator over the <code>char</code>s of a string slice.\nAn iterator of <code>u16</code> over the string encoded as UTF-16.\nThe associated error which can be returned from parsing.\nThe return type of <code>str::escape_debug</code>.\nThe return type of <code>str::escape_default</code>.\nThe return type of <code>str::escape_unicode</code>.\nParse a value from a string\nAn iterator over the lines of a string, as string slices.\nCreated with the method <code>lines_any</code>.\nCreated with the method <code>match_indices</code>.\nCreated with the method <code>matches</code>.\nAn error returned when parsing a <code>bool</code> using <code>from_str</code> fails\nCreated with the method <code>rmatch_indices</code>.\nCreated with the method <code>rmatches</code>.\nCreated with the method <code>rsplit</code>.\nCreated with the method <code>rsplitn</code>.\nCreated with the method <code>rsplit_terminator</code>.\nCreated with the method <code>split</code>.\nAn iterator over the non-ASCII-whitespace substrings of a …\nAn iterator over the substrings of a string, terminated by …\nCreated with the method <code>splitn</code>.\nCreated with the method <code>split_terminator</code>.\nAn iterator over the non-whitespace substrings of a string,\nAn item returned by the <code>Utf8Chunks</code> iterator.\nAn iterator used to decode a slice of mostly UTF-8 bytes …\nErrors which can occur when attempting to interpret a …\n\n\n\nViews the underlying data as a subslice of the original …\nViews the underlying data as a subslice of the original …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProvides more information about the failure:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParses a string <code>s</code> to return a value of this type.\nConverts a slice of bytes to a string slice.\nConverts a mutable slice of bytes to a mutable string …\nConverts a slice of bytes to a string slice without …\nConverts a slice of bytes to a string slice without …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the invalid sequence that caused a failure.\n\n\n\n\n\n\n\n\nCreates a new iterator to decode the bytes.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReads the next code point out of a byte iterator (assuming …\n\n\nReturns the byte position of the next character, or the …\nThe string Pattern API.\n\nReturns remainder of the split string.\nReturns remainder of the split string.\nReturns remainder of the split string.\nReturns remainder of the split string.\nReturns remainder of the split string.\nReturns remainder of the split string.\nReturns remainder of the split string.\nReturns remainder of the split string\nReturns remainder of the split string.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGiven a first byte, determines how many bytes are in this …\nReturns the next validated UTF-8 substring.\nReturns the index in the given string up to which valid …\nAssociated type for <code>&lt;&amp;[char; N] as Pattern&lt;&#39;a&gt;&gt;::Searcher</code>.\nAssociated type for <code>&lt;[char; N] as Pattern&lt;&#39;a&gt;&gt;::Searcher</code>.\nAssociated type for <code>&lt;F as Pattern&lt;&#39;a&gt;&gt;::Searcher</code>.\nAssociated type for <code>&lt;char as Pattern&lt;&#39;a&gt;&gt;::Searcher</code>.\nAssociated type for <code>&lt;&amp;[char] as Pattern&lt;&#39;a&gt;&gt;::Searcher</code>.\nExpresses that every byte of the haystack has been …\nA marker trait to express that a <code>ReverseSearcher</code> can be …\nExpresses that a match of the pattern has been found at …\nA string pattern.\nExpresses that <code>haystack[a..b]</code> has been rejected as a …\nA reverse searcher for a string pattern.\nResult of calling <code>Searcher::next()</code> or …\nA searcher for a string pattern.\nAssociated searcher for this pattern\nAssociated type for <code>&lt;&amp;str as Pattern&lt;&#39;a&gt;&gt;::Searcher</code>.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGetter for the underlying string to be searched in\n\n\n\n\n\n\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstructs the associated searcher from <code>self</code> and the …\nChecks whether the pattern matches anywhere in the haystack\nChecks whether the pattern matches at the front of the …\nChecks whether the pattern matches at the back of the …\nPerforms the next search step starting from the front.\n\n\n\n\n\n\nPerforms the next search step starting from the back.\n\n\n\n\n\n\nFinds the next <code>Match</code> result. See <code>next()</code>.\n\n\n\n\n\n\nFinds the next <code>Match</code> result. See <code>next_back()</code>.\n\n\n\n\n\n\nFinds the next <code>Reject</code> result. See <code>next()</code> and <code>next_match()</code>.\n\n\n\n\nFinds the next <code>Reject</code> result. See <code>next_back()</code>.\n\n\n\n\nRemoves the pattern from the front of haystack, if it …\nRemoves the pattern from the back of haystack, if it …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<code>Exclusive</code> provides only <em>mutable</em> access, also referred to …\nAtomic types\n\n\n\n\n\n\n\nReturns the argument unchanged.\n\nBuild a <em>mutable</em> reference to an <code>Exclusive&lt;T&gt;</code> from a <em>mutable</em>…\nBuild a <em>pinned mutable</em> reference to an <code>Exclusive&lt;T&gt;</code> from a …\nGet exclusive access to the underlying value.\nGet pinned exclusive access to the underlying value.\nCalls <code>U::from(self)</code>.\n\nUnwrap the value contained in the <code>Exclusive</code>\n\n\n\n\nWrap a value in an <code>Exclusive</code>\n\n\n\n\n\n\n\nAn <code>AtomicBool</code> initialized to <code>false</code>.\nAn <code>AtomicIsize</code> initialized to <code>0</code>.\nAn <code>AtomicUsize</code> initialized to <code>0</code>.\nHas the effects of both <code>Acquire</code> and <code>Release</code> together: For …\nWhen coupled with a load, if the loaded value was written …\nA boolean type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nA raw pointer type which can be safely shared between …\nAn integer type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nAtomic memory orderings\nNo ordering constraints, only atomic operations.\nWhen coupled with a store, all previous operations become …\nLike <code>Acquire</code>/<code>Release</code>/<code>AcqRel</code> (for load, store, and …\nReturns a mutable pointer to the underlying <code>bool</code>.\nReturns a mutable pointer to the underlying pointer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStores a value into the <code>bool</code> if the current value is the …\nStores a value into the pointer if the current value is …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the <code>bool</code> if the current value is the …\nStores a value into the pointer if the current value is …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the <code>bool</code> if the current value is the …\nStores a value into the pointer if the current value is …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nA compiler memory fence.\nCreates an <code>AtomicBool</code> initialized to <code>false</code>.\nCreates a null <code>AtomicPtr&lt;T&gt;</code>.\n\n\n\n\n\n\n\n\n\n\n\nAn atomic fence.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nLogical “and” with a boolean value.\nPerforms a bitwise “and” operation on the address of …\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nOffsets the pointer’s address by adding <code>val</code> <em>bytes</em>, …\nOffsets the pointer’s address by subtracting <code>val</code> <em>bytes</em>, …\nMaximum with the current value.\nMaximum with the current value.\nMaximum with the current value.\nMaximum with the current value.\nMaximum with the current value.\nMaximum with the current value.\nMaximum with the current value.\nMaximum with the current value.\nMaximum with the current value.\nMaximum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nLogical “nand” with a boolean value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nLogical “not” with a boolean value.\nLogical “or” with a boolean value.\nPerforms a bitwise “or” operation on the address of …\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nOffsets the pointer’s address by adding <code>val</code> (in units of …\nOffsets the pointer’s address by subtracting <code>val</code> (in …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nLogical “xor” with a boolean value.\nPerforms a bitwise “xor” operation on the address of …\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\nConverts a <code>bool</code> into an <code>AtomicBool</code>.\nConverts a <code>*mut T</code> into an <code>AtomicPtr&lt;T&gt;</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts an <code>i8</code> into an <code>AtomicI8</code>.\nConverts an <code>u8</code> into an <code>AtomicU8</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts an <code>i16</code> into an <code>AtomicI16</code>.\nReturns the argument unchanged.\nConverts an <code>u16</code> into an <code>AtomicU16</code>.\nConverts an <code>i32</code> into an <code>AtomicI32</code>.\nReturns the argument unchanged.\nConverts an <code>u32</code> into an <code>AtomicU32</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts an <code>i64</code> into an <code>AtomicI64</code>.\nReturns the argument unchanged.\nConverts an <code>u64</code> into an <code>AtomicU64</code>.\nConverts an <code>isize</code> into an <code>AtomicIsize</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts an <code>usize</code> into an <code>AtomicUsize</code>.\nGet atomic access to a <code>&amp;mut bool</code>.\nGet atomic access to a pointer.\nGet atomic access to a <code>&amp;mut i8</code>.\nGet atomic access to a <code>&amp;mut u8</code>.\nGet atomic access to a <code>&amp;mut i16</code>.\nGet atomic access to a <code>&amp;mut u16</code>.\nGet atomic access to a <code>&amp;mut i32</code>.\nGet atomic access to a <code>&amp;mut u32</code>.\nGet atomic access to a <code>&amp;mut i64</code>.\nGet atomic access to a <code>&amp;mut u64</code>.\nGet atomic access to a <code>&amp;mut isize</code>.\nGet atomic access to a <code>&amp;mut usize</code>.\nGet atomic access to a <code>&amp;mut [bool]</code> slice.\nGet atomic access to a slice of pointers.\nGet atomic access to a <code>&amp;mut [i8]</code> slice.\nGet atomic access to a <code>&amp;mut [u8]</code> slice.\nGet atomic access to a <code>&amp;mut [i16]</code> slice.\nGet atomic access to a <code>&amp;mut [u16]</code> slice.\nGet atomic access to a <code>&amp;mut [i32]</code> slice.\nGet atomic access to a <code>&amp;mut [u32]</code> slice.\nGet atomic access to a <code>&amp;mut [i64]</code> slice.\nGet atomic access to a <code>&amp;mut [u64]</code> slice.\nGet atomic access to a <code>&amp;mut [isize]</code> slice.\nGet atomic access to a <code>&amp;mut [usize]</code> slice.\nCreates a new <code>AtomicBool</code> from a pointer.\nCreates a new <code>AtomicPtr</code> from a pointer.\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nReturns a mutable reference to the underlying <code>bool</code>.\nReturns a mutable reference to the underlying pointer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nGet non-atomic access to a <code>&amp;mut [AtomicBool]</code> slice.\nGet non-atomic access to a <code>&amp;mut [AtomicPtr]</code> slice.\nGet non-atomic access to a <code>&amp;mut [AtomicI8]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicU8]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicI16]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicU16]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicI32]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicU32]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicI64]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicU64]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicIsize]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicUsize]</code> slice\n\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nLoads a value from the bool.\nLoads a value from the pointer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nCreates a new <code>AtomicBool</code>.\nCreates a new <code>AtomicPtr</code>.\nCreates a new atomic integer.\nCreates a new atomic integer.\nCreates a new atomic integer.\nCreates a new atomic integer.\nCreates a new atomic integer.\nCreates a new atomic integer.\nCreates a new atomic integer.\nCreates a new atomic integer.\nCreates a new atomic integer.\nCreates a new atomic integer.\nSignals the processor that it is inside a busy-wait …\nStores a value into the bool.\nStores a value into the pointer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the bool, returning the previous value.\nStores a value into the pointer, returning the previous …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe context of an asynchronous task.\nA helper constant for internal desugaring – produces …\nA helper constant for internal desugaring – produces …\nRepresents that a value is not ready yet.\nIndicates whether a value is available or if the current …\nA <code>RawWaker</code> allows the implementor of a task executor to …\nA virtual function pointer table (vtable) that specifies …\nRepresents that a value is immediately ready.\nA <code>Waker</code> is a handle for waking up a task by notifying its …\nGet a reference to the underlying <code>RawWaker</code>.\nA helper function for internal desugaring – produces …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGet the <code>data</code> pointer used to create this <code>RawWaker</code>.\n\n\n\n\n\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\n\nReturns the argument unchanged.\nMoves the value into a <code>Poll::Ready</code> to make a <code>Poll&lt;T&gt;</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\n\n\nCreates a new <code>Waker</code> from <code>RawWaker</code>.\n\n\nCreate a new <code>Context</code> from a <code>&amp;Waker</code>.\n\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the poll is a <code>Pending</code> value.\nReturns <code>true</code> if the poll is a <code>Poll::Ready</code> value.\nMaps a <code>Poll&lt;T&gt;</code> to <code>Poll&lt;U&gt;</code> by applying a function to a …\nMaps a <code>Poll::Ready&lt;Option&lt;Result&lt;T, E&gt;&gt;&gt;</code> to …\nMaps a <code>Poll::Ready&lt;Result&lt;T, E&gt;&gt;</code> to …\nMaps a <code>Poll&lt;Result&lt;T, E&gt;&gt;</code> to <code>Poll&lt;Result&lt;U, E&gt;&gt;</code> by …\nMaps a <code>Poll&lt;Option&lt;Result&lt;T, E&gt;&gt;&gt;</code> to …\nCreates a new <code>RawWaker</code> from the provided <code>data</code> pointer and …\nCreates a new <code>RawWakerVTable</code> from the provided <code>clone</code>, <code>wake</code>,\nCreates a new <code>Waker</code> that does nothing when <code>wake</code> is called.\n\nExtracts the successful type of a <code>Poll&lt;T&gt;</code>.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGet the <code>vtable</code> pointer used to create this <code>RawWaker</code>.\nWake up the task associated with this <code>Waker</code>.\nWake up the task associated with this <code>Waker</code> without …\nReturns a reference to the <code>Waker</code> for the current task.\nReturns <code>true</code> if this <code>Waker</code> and another <code>Waker</code> would awake …\nA <code>Duration</code> type to represent a span of time, typically …\nThe maximum duration.\nThe duration of one microsecond.\nThe duration of one millisecond.\nThe duration of one nanosecond.\nThe duration of one second.\nAn error which can be returned when converting a …\nA duration of zero time.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\n\n\nReturns the total number of whole microseconds contained …\nReturns the total number of whole milliseconds contained …\nReturns the total number of nanoseconds contained by this …\nReturns the number of <em>whole</em> seconds contained by this …\nReturns the number of seconds contained by this <code>Duration</code> …\nReturns the number of seconds contained by this <code>Duration</code> …\n\n\n\n\nChecked <code>Duration</code> addition. Computes <code>self + other</code>, …\nChecked <code>Duration</code> division. Computes <code>self / other</code>, …\nChecked <code>Duration</code> multiplication. Computes <code>self * other</code>, …\nChecked <code>Duration</code> subtraction. Computes <code>self - other</code>, …\n\n\n\n\n\n\nDivide <code>Duration</code> by <code>Duration</code> and return <code>f32</code>.\nDivide <code>Duration</code> by <code>Duration</code> and return <code>f64</code>.\nDivide <code>Duration</code> by <code>f32</code>.\nDivide <code>Duration</code> by <code>f64</code>.\n\n\n\n\n\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new <code>Duration</code> from the specified number of …\nCreates a new <code>Duration</code> from the specified number of …\nCreates a new <code>Duration</code> from the specified number of …\nCreates a new <code>Duration</code> from the specified number of whole …\nCreates a new <code>Duration</code> from the specified number of …\nCreates a new <code>Duration</code> from the specified number of …\n\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if this <code>Duration</code> spans no time.\n\n\nMultiplies <code>Duration</code> by <code>f32</code>.\nMultiplies <code>Duration</code> by <code>f64</code>.\nCreates a new <code>Duration</code> from the specified number of whole …\n\nSaturating <code>Duration</code> addition. Computes <code>self + other</code>, …\nSaturating <code>Duration</code> multiplication. Computes <code>self * other</code>, …\nSaturating <code>Duration</code> subtraction. Computes <code>self - other</code>, …\n\n\nReturns the fractional part of this <code>Duration</code>, in whole …\nReturns the fractional part of this <code>Duration</code>, in whole …\nReturns the fractional part of this <code>Duration</code>, in …\n\n\n\n\nThe checked version of <code>from_secs_f32</code>.\nThe checked version of <code>from_secs_f64</code>.\n\n\n\n\nThe largest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\n\n\nThe version of Unicode that the Unicode parts of <code>char</code> and …\n\n\n\nThe largest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …".split("\n"));if(typeof exports!=='undefined')exports.RUSTDOC_SEARCH_DESC=RUSTDOC_SEARCH_DESC;if(typeof onRustdocDesc!=='undefined')onRustdocDesc('core');